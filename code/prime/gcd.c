#include <stdio.h>
#include <string.h>

#include "gcd.h"

#define GCD_DEBUG

/*##############################################################
  # debug definition
  #############################################################*/

#ifdef GCD_DEBUG
#define STMT(stuff)   do { stuff } while (0)
#define GCD_debug(a) STMT(                             \
        printf("[%s(%04d)] ", __FILE__[0] == '/'?   \
        ((strrchr(__FILE__,'/')==NULL)?__FILE__:(strrchr(__FILE__,'/')+1)):   \
        ((strrchr(__FILE__,'\\')==NULL)?__FILE__:(strrchr(__FILE__,'\\')+1)), \
             __LINE__);                                     \
    printf a;)
#else
#define GCD_debug(a)
#endif

/*##############################################################
  # global function implementations
  #############################################################*/

/*
 * http://en.wikipedia.org/wiki/Euclidean_algorithm#B.C3.A9zout.27s_identity
 *
 * BÃ©zout's identity states that the greatest common divisor g of two integers a and b
 * can be represented as a linear sum of the original two numbers a and b.
 * In other words, it is always possible to find integers s and t such that
 *
 *      a * x0 + b * y0 = gcd(a, b)
 *
 * The set of all possible sums of integer multiples of two numbers (a and b) is equivalent
 * to the set of multiples of GCD(a, b). The GCD is said to be the generator of the ideal
 * of a and b. This GCD definition led to the modern abstract algebraic concepts of a principal
 * ideal (an ideal generated by a single element) and a principal ideal domain (a domain in
 * which every ideal is a principal ideal).
 *
 * return 0 means no gcd (i.e., infinity).
 */
int get_gcd_2(int a, int b, int *x0, int *y0, int *steps)
{

    int aa, bb, gcd, r, q;
    int _steps, _x0, _y0, x_1, y_1, x_2, y_2;   /* _x0 is x(n), x_1 is x(n-1), x_2 is x(n-2) */

    int swapped = 0;            /* |a| < |b| ? */

    /* abs: make them all positive, since (a, b) = (|a|, |b|) */
    if (a < 0)
        aa = -a;
    else
        aa = a;
    if (b < 0)
        bb = -b;
    else
        bb = b;

    /* swap: make sure aa >= bb */
    if (aa < bb) {
        int tmp = aa;
        aa = bb;
        bb = tmp;
        swapped = 1;
    }

    _steps = 0;

    /* handle trivial cases */
    if (aa == 0 && bb == 0) {
        gcd = 0;
        _x0 = _y0 = 0;
        goto RET;
    }

    if (aa == 0) {
        gcd = bb;
        _x0 = 0;
        _y0 = 1;
        goto RET;
    }

    if (bb == 0) {
        gcd = aa;
        _x0 = 1;
        _y0 = 0;
        goto RET;
    }

    /* main loop for normalized pair (aa, bb) */
    gcd = bb;
    _x0 = 0;
    _y0 = 1;
    while ((r = aa % bb)) {

        q = aa / bb;

        /* steps:
           0:     a=bq1+r1   => r1=a-bq1    => (x1,y1)=(1,     -q1) 
           1:     b=r1q2+r2  => r2=b-r1q2   => (x2,y2)=(-q2x1, -q2y1) + ( 0,  1)
           2:     r1=r2q3+r3 => r3=r1-r2q3  => (x3,y3)=(-q3x2, -q3y2) + (x1, y1)
           3:     r2=r3q4+r4 => r4=r2-r3q4  => (x4,y4)=(-q4x3, -q4y3) + (x2, y2)
           ...
         */
        if (_steps == 0) {
            _x0 = 1;
            _y0 = -q;

        } else if (_steps == 1) {
            /* save the previous (x, y) */
            x_1 = _x0;
            y_1 = _y0;
            /* calcuate the new (x, y) */
            _x0 = -q * _x0;
            _y0 = -q * _y0 + 1;
        } else {
            /* save two previous (x, y) */
            x_2 = x_1;
            y_2 = y_1;
            x_1 = _x0;
            y_1 = _y0;
            /* calcuate the new (x, y) */
            _x0 = -q * _x0 + x_2;
            _y0 = -q * _y0 + y_2;
        }

        /* GCD_debug(("\nstep=%2d, (%4d, %4d), r=%4d", *steps, aa, bb, r)); */

        /* prepare for the next step */
        aa = bb;
        bb = r;
        gcd = r;

        _steps += 1;
    }

 RET:

    /* handle the "swap" & "abs" cases for (x0, y0) */
    if (swapped) {
        int tmp = _x0;
        _x0 = _y0;
        _y0 = tmp;
    }
    _x0 *= (a < 0) ? -1 : 1;
    _y0 *= (b < 0) ? -1 : 1;

    /* assign return values */
    if (steps)
        *steps = _steps;
    if (x0)
        *x0 = _x0;
    if (y0)
        *y0 = _y0;

#if (0)
    /* verify the value */
    if ((a * _x0 + b * _y0) != gcd) {
        GCD_debug(("ERROR: %d * %d + %d * %d != %d\n", a, _x0, b, _y0, gcd));
    } else {
        GCD_debug(("OK: %d * %d + %d * %d = %d ", a, _x0, b, _y0, gcd));
    }
#endif

    /* GCD_debug((" ==> gcd(%d, %d)=%d\n", a, b, gcd)); */

    return gcd;
}

int get_gcd_n(int n, int a[])
{
    int i, gcd;

    if (n < 2) {
        GCD_debug(("ERROR: get_gcd_n(n=%d<2), return 0.\n", n));
        return 0;
    }

    gcd = get_gcd_2(a[0], a[1], NULL, NULL, NULL);

    for (i = 2; i < n; i++) {
        gcd = get_gcd_2(gcd, a[i], NULL, NULL, NULL);
    }

    return gcd;
}
