/*
** Copyright (C) 2004 Yuwu (Bruin) Xiong <xiongyw@hotmail.com>
**  
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software 
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif


/* created(bruin, 2002.11.24) */

/*--------------------------------------------------------------------+
 | includes                                                           |
 +--------------------------------------------------------------------*/

#include <malloc.h>
#include <stdlib.h>
#include <math.h>
#include "bmp2jpg.h"


/*--------------------------------------------------------------------+
 |                                                                    |
 | static global variables                                            |
 |                                                                    |
 +--------------------------------------------------------------------*/

/* convertion betw 8x8 array and 64x1 vector, the zig-zagged sequence */
static const BYTE s_zigzag[8][8] = {
    { 0,  1,  5,  6, 14, 15, 27, 28},
    { 2,  4,  7, 13, 16, 26, 29, 42},
    { 3,  8, 12, 17, 25, 30, 41, 43},
    { 9, 11, 18, 24, 31, 40, 44, 53},
    {10, 19, 23, 32, 39, 45, 52, 54},
    {20, 22, 33, 38, 46, 51, 55, 60},
    {21, 34, 37, 47, 50, 56, 59, 61},
    {35, 36, 48, 49, 57, 58, 62, 63}
};

/* default quantization tables for luminance and chrominance
   provided by "ISO/IEC 10918, 1993(e)" Annex K:

   luminance quantization table:

    16  11  10  16   24   40   51   61 
    12  12  14  19   26   58   60   55  
    14  13  16  24   40   57   69   56  
    14  17  22  29   51   87   80   62  
    18  22  37  56   68  109  103   77  
    24  35  55  64   81  104  113   92  
    49  64  78  87  103  121  120  101  
    72  92  95  98  112  100  103   99

   chrominance quantization table:

    17  18  24  47  99  99  99  99 
    18  21  26  66  99  99  99  99 
    24  26  56  99  99  99  99  99 
    47  66  99  99  99  99  99  99 
    99  99  99  99  99  99  99  99 
    99  99  99  99  99  99  99  99 
    99  99  99  99  99  99  99  99 
    99  99  99  99  99  99  99  99

*/

/* standard DQT, #0 for luminance, #1 for chrominance */
static BYTE s_std_dqt[] = {
    0xff, DQT,   /* marker */
    0x00, 0x84,  /* segment size */

#if (1)    
    0x00,        /* #0, 8-bit precision */
    16,  11,  12,  14,  12,  10,  16,  14,
    13,  14,  18,  17,  16,  19,  24,  40,
    26,  24,  22,  22,  24,  49,  35,  37, 
    29,  40,  58,  51,  61,  60,  57,  51,
    56,  55,  64,  72,  92,  78,  64,  68, 
    87,  69,  55,  56,  80, 109,  81,  87,
    95,  98, 103, 104, 103,  62,  77, 113,
   121, 112, 100, 120,  92, 101, 103,  99,

    0x01,       /* #1, 8-bit precision */
    17, 18, 18, 24, 21, 24, 47, 26, 
    26, 47, 99, 66, 56, 66, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99
#endif
#if (0)
    0x00,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    0x01,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1
#endif
};
static const BYTE* s_lumin_qt = s_std_dqt + 5;
static const BYTE* s_chrom_qt = s_std_dqt + 70;


/* standard APP0 (JFIF) table */
static const BYTE s_std_app0[] = {
    0xff, APP0,  /* marker */
    0x00, 0x10,  /* size */
    0x4a, 0x46, 0x49, 0x46, 0x00, /* "JFIF." identifier */
    0x01, 0x01,  /* version major id, version minor id */
    0x00,        /* units: next two fileds specify pixel per inch */
    0x00, 0x01,  /* horizontal pixel density */
    0x00, 0x01,  /* vertical pixel density */
    0x00, 0x00   /* x, y thumbnail */
};

static const BYTE s_std_com[] = {
    0xff, COM,  /* marker */
    0x00, 0x09, /* size */
    0x62, 0x72, 0x75, 0x69, 0x6e, 0x3a, 0x29 /* "bruin:)" */
};

/* standard SOF0. image width and height are not determined */
static BYTE s_std_sof0[] = { 
    0xff, SOF0, /* marker */
    0x00, 0x11, /* 8 + components * 3 = 17 */
    0x08,       /* 8-bit precision */
    0x00, 0x00, /* image height in pixel */
    0x00, 0x00, /* image weidth in pixel */
    0x03,       /* components: Y, U, V */
    0x01,       /* component id: Y  */
    0x22,       /* sampling frequency, 2x2 */
    0x00,       /* DQT #0 */
    0x02,       /* component id: U */
    0x11,       /* sampling freqnency, 1x1 */
    0x01,       /* DQT #1 */
    0x03,       /* component id: V */
    0x11,       /* sampling freqnency, 1x1 */
    0x01        /* DQT #1 */
};


/* JPEG DHT format of 4 typical huffman tables given in "ISO/IEC 10918-1, 1993(e), Annex K": 

   + luminance DC coefficient difference,
   + luminance AC coefficient, 
   + chrominance DC coefficient difference, and
   + chrominance AC coeeficient

   this block of data can be obtained by simply dumping a typical jpeg file.
*/
static const BYTE s_std_dht[] = {

    0xff,DHT,  /* marker */
    0x01,0xa2, /* size */  

    0x00,      /* DC Luminance. followed by its BITS (16 bytes) and HUFFVALS */
    0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,

    0x10,     /* AC Luminance */
    0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,0x00,0x01,0x7d,
    0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
    0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
    0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
    0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
    0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
    0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
    0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
    0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
    0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
    0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    0xf9,0xfa,

    0x01,     /* DC Chrominance */
    0x00,0x03,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,                    

    0x11,     /* AC Chrominance */
    0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,0x02,0x77,
    0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
    0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
    0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
    0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
    0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
    0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
    0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
    0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
    0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
    0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    0xf9,0xfa
};

static BYTE s_std_sos[] = {
    0xff,SOS,  /* marker */
    0x00,0x0c, /* size: 6 + 2 * (nr of components in scan) */  
    0x03,      /* nr of components: Y, U, V */
    0x01,       /* component id: Y  */
    0x00,       /* DHT # for AC (bit 0..3) and DC (bit 4..7) */
    0x02,       /* component id: U */
    0x11,       /* DHT # for AC (bit 0..3) and DC (bit 4..7) */
    0x03,       /* component id: V */
    0x11,       /* DHT # for AC (bit 0..3) and DC (bit 4..7) */
    0x00,       /* spectral selection start */
    0x3f,       /* spectral selection end */
    0x00        /* successive approximation */
};


/* the following are huffman tables derived from above DHT data by using algorithms 
   given in "ISO/IEC 10918-1, 1993(e), Annex C".

   given: BITS (a 16 byte list giving the nr of codes for each code length from 1 to 16 )
          HUFFVAL (a list of 8-bit symbol values, each of which is assigned a huffman
                   code, the symbol values are placed in the list in the order of increasing
                   code length. code lengths greater then 16 are not allowed.)
   to create:
          HUFFSIZE (a list of code lengths, the list size is the sum of 16 byte in BITS)
          HUFFCODE (the huffman codes corresponding to those lengths in HUFFSIZE)

  the following code fragment could be used to create HUFFSIZE table:
        
        k = 0;
        for(i = 0; i < 16; i ++)
                for(j = 0; j < BITS[i]; j ++){
                        HUFFSIZE[k++] = i + 1;
                }
        huffsize_table_size = k;

  the following code fragment could be used to create HUFFCODE table:

        code = 0x00;
        for(i = 0; i < huffsize_table_size; i ++){
                if(i == 0 || (HUFFCODE[i] == HUFFCODE[i - 1])){
                        HUFFCODE[i] = code;
                        code ++;
                }
                else{
                        code <<= (HUFFSIZE[i] - HUFFSIZE[i - 1]);
                        HUFFCODE[i] = code;
                        code ++;
                }
        }

  the following code fragment coould be used to check validity of the given BITS,
  in case one need to check a given BITS:
  
    bool check_bits(unsigned char bits[16]){
        int i;
        int c = 0xffff;
        for(i = 0; i < 16; i ++){
                printf("i=%d, c=%d\n", i, c);
                if((c = c - bits[i] * pow(2, (15 - i))) < 0){
                        printf("error at %d, bits[%d]=%d\n", i, i, bits[i]);
                        return false;
                }
        }
        return true;
    }

  in the following 4 generated huffman tables, the array index is symbol values (HUFFVAL), 
  while each element contains the code length (HUFFSIZE) and the code (HUFFCODE) for 
  the corresponding symbol value (also the "code word" is illustrated in the comments
  for each element). 

  be noted that in AC tables, for those symbol values do not included the huffman table, 
  it's HUFFSIZE and HUFFCODE been set to 0.

*/
static HUFF_ENTRY s_lumin_dc[12] = {
    { 2, 0x0000}, /*               00 */
    { 3, 0x0002}, /*              010 */
    { 3, 0x0003}, /*              011 */
    { 3, 0x0004}, /*              100 */
    { 3, 0x0005}, /*              101 */
    { 3, 0x0006}, /*              110 */
    { 4, 0x000e}, /*             1110 */
    { 5, 0x001e}, /*            11110 */
    { 6, 0x003e}, /*           111110 */
    { 7, 0x007e}, /*          1111110 */
    { 8, 0x00fe}, /*         11111110 */
    { 9, 0x01fe}  /*        111111110 */
};

static HUFF_ENTRY s_chrom_dc[12] = {
    { 2, 0x0000}, /*               00 */
    { 2, 0x0001}, /*               01 */
    { 2, 0x0002}, /*               10 */
    { 3, 0x0006}, /*              110 */
    { 4, 0x000e}, /*             1110 */
    { 5, 0x001e}, /*            11110 */
    { 6, 0x003e}, /*           111110 */
    { 7, 0x007e}, /*          1111110 */
    { 8, 0x00fe}, /*         11111110 */
    { 9, 0x01fe}, /*        111111110 */
    {10, 0x03fe}, /*       1111111110 */
    {11, 0x07fe}  /*      11111111110 */
};

/* 162 valid entries */
static HUFF_ENTRY s_lumin_ac[256] = {

    { 4, 0x000a}, /* 0x00:              1010 */
    { 2, 0x0000}, /* 0x01:                00 */
    { 2, 0x0001}, /* 0x02:                01 */
    { 3, 0x0004}, /* 0x03:               100 */
    { 4, 0x000b}, /* 0x04:              1011 */
    { 5, 0x001a}, /* 0x05:             11010 */
    { 7, 0x0078}, /* 0x06:           1111000 */
    { 8, 0x00f8}, /* 0x07:          11111000 */
    {10, 0x03f6}, /* 0x08:        1111110110 */
    {16, 0xff82}, /* 0x09:  1111111110000010 */
    {16, 0xff83}, /* 0x0a:  1111111110000011 */
    { 0, 0x0000}, /* 0x0b:                   */
    { 0, 0x0000}, /* 0x0c:                   */
    { 0, 0x0000}, /* 0x0d:                   */
    { 0, 0x0000}, /* 0x0e:                   */
    { 0, 0x0000}, /* 0x0f:                   */
    { 0, 0x0000}, /* 0x10:                   */
    { 4, 0x000c}, /* 0x11:              1100 */
    { 5, 0x001b}, /* 0x12:             11011 */
    { 7, 0x0079}, /* 0x13:           1111001 */
    { 9, 0x01f6}, /* 0x14:         111110110 */
    {11, 0x07f6}, /* 0x15:       11111110110 */
    {16, 0xff84}, /* 0x16:  1111111110000100 */
    {16, 0xff85}, /* 0x17:  1111111110000101 */
    {16, 0xff86}, /* 0x18:  1111111110000110 */
    {16, 0xff87}, /* 0x19:  1111111110000111 */
    {16, 0xff88}, /* 0x1a:  1111111110001000 */
    { 0, 0x0000}, /* 0x1b:                   */
    { 0, 0x0000}, /* 0x1c:                   */
    { 0, 0x0000}, /* 0x1d:                   */
    { 0, 0x0000}, /* 0x1e:                   */
    { 0, 0x0000}, /* 0x1f:                   */
    { 0, 0x0000}, /* 0x20:                   */
    { 5, 0x001c}, /* 0x21:             11100 */
    { 8, 0x00f9}, /* 0x22:          11111001 */
    {10, 0x03f7}, /* 0x23:        1111110111 */
    {12, 0x0ff4}, /* 0x24:      111111110100 */
    {16, 0xff89}, /* 0x25:  1111111110001001 */
    {16, 0xff8a}, /* 0x26:  1111111110001010 */
    {16, 0xff8b}, /* 0x27:  1111111110001011 */
    {16, 0xff8c}, /* 0x28:  1111111110001100 */
    {16, 0xff8d}, /* 0x29:  1111111110001101 */
    {16, 0xff8e}, /* 0x2a:  1111111110001110 */
    { 0, 0x0000}, /* 0x2b:                   */
    { 0, 0x0000}, /* 0x2c:                   */
    { 0, 0x0000}, /* 0x2d:                   */
    { 0, 0x0000}, /* 0x2e:                   */
    { 0, 0x0000}, /* 0x2f:                   */
    { 0, 0x0000}, /* 0x30:                   */
    { 6, 0x003a}, /* 0x31:            111010 */
    { 9, 0x01f7}, /* 0x32:         111110111 */
    {12, 0x0ff5}, /* 0x33:      111111110101 */
    {16, 0xff8f}, /* 0x34:  1111111110001111 */
    {16, 0xff90}, /* 0x35:  1111111110010000 */
    {16, 0xff91}, /* 0x36:  1111111110010001 */
    {16, 0xff92}, /* 0x37:  1111111110010010 */
    {16, 0xff93}, /* 0x38:  1111111110010011 */
    {16, 0xff94}, /* 0x39:  1111111110010100 */
    {16, 0xff95}, /* 0x3a:  1111111110010101 */
    { 0, 0x0000}, /* 0x3b:                   */
    { 0, 0x0000}, /* 0x3c:                   */
    { 0, 0x0000}, /* 0x3d:                   */
    { 0, 0x0000}, /* 0x3e:                   */
    { 0, 0x0000}, /* 0x3f:                   */
    { 0, 0x0000}, /* 0x40:                   */
    { 6, 0x003b}, /* 0x41:            111011 */
    {10, 0x03f8}, /* 0x42:        1111111000 */
    {16, 0xff96}, /* 0x43:  1111111110010110 */
    {16, 0xff97}, /* 0x44:  1111111110010111 */
    {16, 0xff98}, /* 0x45:  1111111110011000 */
    {16, 0xff99}, /* 0x46:  1111111110011001 */
    {16, 0xff9a}, /* 0x47:  1111111110011010 */
    {16, 0xff9b}, /* 0x48:  1111111110011011 */
    {16, 0xff9c}, /* 0x49:  1111111110011100 */
    {16, 0xff9d}, /* 0x4a:  1111111110011101 */
    { 0, 0x0000}, /* 0x4b:                   */
    { 0, 0x0000}, /* 0x4c:                   */
    { 0, 0x0000}, /* 0x4d:                   */
    { 0, 0x0000}, /* 0x4e:                   */
    { 0, 0x0000}, /* 0x4f:                   */
    { 0, 0x0000}, /* 0x50:                   */
    { 7, 0x007a}, /* 0x51:           1111010 */
    {11, 0x07f7}, /* 0x52:       11111110111 */
    {16, 0xff9e}, /* 0x53:  1111111110011110 */
    {16, 0xff9f}, /* 0x54:  1111111110011111 */
    {16, 0xffa0}, /* 0x55:  1111111110100000 */
    {16, 0xffa1}, /* 0x56:  1111111110100001 */
    {16, 0xffa2}, /* 0x57:  1111111110100010 */
    {16, 0xffa3}, /* 0x58:  1111111110100011 */
    {16, 0xffa4}, /* 0x59:  1111111110100100 */
    {16, 0xffa5}, /* 0x5a:  1111111110100101 */
    { 0, 0x0000}, /* 0x5b:                   */
    { 0, 0x0000}, /* 0x5c:                   */
    { 0, 0x0000}, /* 0x5d:                   */
    { 0, 0x0000}, /* 0x5e:                   */
    { 0, 0x0000}, /* 0x5f:                   */
    { 0, 0x0000}, /* 0x60:                   */
    { 7, 0x007b}, /* 0x61:           1111011 */
    {12, 0x0ff6}, /* 0x62:      111111110110 */
    {16, 0xffa6}, /* 0x63:  1111111110100110 */
    {16, 0xffa7}, /* 0x64:  1111111110100111 */
    {16, 0xffa8}, /* 0x65:  1111111110101000 */
    {16, 0xffa9}, /* 0x66:  1111111110101001 */
    {16, 0xffaa}, /* 0x67:  1111111110101010 */
    {16, 0xffab}, /* 0x68:  1111111110101011 */
    {16, 0xffac}, /* 0x69:  1111111110101100 */
    {16, 0xffad}, /* 0x6a:  1111111110101101 */
    { 0, 0x0000}, /* 0x6b:                   */
    { 0, 0x0000}, /* 0x6c:                   */
    { 0, 0x0000}, /* 0x6d:                   */
    { 0, 0x0000}, /* 0x6e:                   */
    { 0, 0x0000}, /* 0x6f:                   */
    { 0, 0x0000}, /* 0x70:                   */
    { 8, 0x00fa}, /* 0x71:          11111010 */
    {12, 0x0ff7}, /* 0x72:      111111110111 */
    {16, 0xffae}, /* 0x73:  1111111110101110 */
    {16, 0xffaf}, /* 0x74:  1111111110101111 */
    {16, 0xffb0}, /* 0x75:  1111111110110000 */
    {16, 0xffb1}, /* 0x76:  1111111110110001 */
    {16, 0xffb2}, /* 0x77:  1111111110110010 */
    {16, 0xffb3}, /* 0x78:  1111111110110011 */
    {16, 0xffb4}, /* 0x79:  1111111110110100 */
    {16, 0xffb5}, /* 0x7a:  1111111110110101 */
    { 0, 0x0000}, /* 0x7b:                   */
    { 0, 0x0000}, /* 0x7c:                   */
    { 0, 0x0000}, /* 0x7d:                   */
    { 0, 0x0000}, /* 0x7e:                   */
    { 0, 0x0000}, /* 0x7f:                   */
    { 0, 0x0000}, /* 0x80:                   */
    { 9, 0x01f8}, /* 0x81:         111111000 */
    {15, 0x7fc0}, /* 0x82:   111111111000000 */
    {16, 0xffb6}, /* 0x83:  1111111110110110 */
    {16, 0xffb7}, /* 0x84:  1111111110110111 */
    {16, 0xffb8}, /* 0x85:  1111111110111000 */
    {16, 0xffb9}, /* 0x86:  1111111110111001 */
    {16, 0xffba}, /* 0x87:  1111111110111010 */
    {16, 0xffbb}, /* 0x88:  1111111110111011 */
    {16, 0xffbc}, /* 0x89:  1111111110111100 */
    {16, 0xffbd}, /* 0x8a:  1111111110111101 */
    { 0, 0x0000}, /* 0x8b:                   */
    { 0, 0x0000}, /* 0x8c:                   */
    { 0, 0x0000}, /* 0x8d:                   */
    { 0, 0x0000}, /* 0x8e:                   */
    { 0, 0x0000}, /* 0x8f:                   */
    { 0, 0x0000}, /* 0x90:                   */
    { 9, 0x01f9}, /* 0x91:         111111001 */
    {16, 0xffbe}, /* 0x92:  1111111110111110 */
    {16, 0xffbf}, /* 0x93:  1111111110111111 */
    {16, 0xffc0}, /* 0x94:  1111111111000000 */
    {16, 0xffc1}, /* 0x95:  1111111111000001 */
    {16, 0xffc2}, /* 0x96:  1111111111000010 */
    {16, 0xffc3}, /* 0x97:  1111111111000011 */
    {16, 0xffc4}, /* 0x98:  1111111111000100 */
    {16, 0xffc5}, /* 0x99:  1111111111000101 */
    {16, 0xffc6}, /* 0x9a:  1111111111000110 */
    { 0, 0x0000}, /* 0x9b:                   */
    { 0, 0x0000}, /* 0x9c:                   */
    { 0, 0x0000}, /* 0x9d:                   */
    { 0, 0x0000}, /* 0x9e:                   */
    { 0, 0x0000}, /* 0x9f:                   */
    { 0, 0x0000}, /* 0xa0:                   */
    { 9, 0x01fa}, /* 0xa1:         111111010 */
    {16, 0xffc7}, /* 0xa2:  1111111111000111 */
    {16, 0xffc8}, /* 0xa3:  1111111111001000 */
    {16, 0xffc9}, /* 0xa4:  1111111111001001 */
    {16, 0xffca}, /* 0xa5:  1111111111001010 */
    {16, 0xffcb}, /* 0xa6:  1111111111001011 */
    {16, 0xffcc}, /* 0xa7:  1111111111001100 */
    {16, 0xffcd}, /* 0xa8:  1111111111001101 */
    {16, 0xffce}, /* 0xa9:  1111111111001110 */
    {16, 0xffcf}, /* 0xaa:  1111111111001111 */
    { 0, 0x0000}, /* 0xab:                   */
    { 0, 0x0000}, /* 0xac:                   */
    { 0, 0x0000}, /* 0xad:                   */
    { 0, 0x0000}, /* 0xae:                   */
    { 0, 0x0000}, /* 0xaf:                   */
    { 0, 0x0000}, /* 0xb0:                   */
    {10, 0x03f9}, /* 0xb1:        1111111001 */
    {16, 0xffd0}, /* 0xb2:  1111111111010000 */
    {16, 0xffd1}, /* 0xb3:  1111111111010001 */
    {16, 0xffd2}, /* 0xb4:  1111111111010010 */
    {16, 0xffd3}, /* 0xb5:  1111111111010011 */
    {16, 0xffd4}, /* 0xb6:  1111111111010100 */
    {16, 0xffd5}, /* 0xb7:  1111111111010101 */
    {16, 0xffd6}, /* 0xb8:  1111111111010110 */
    {16, 0xffd7}, /* 0xb9:  1111111111010111 */
    {16, 0xffd8}, /* 0xba:  1111111111011000 */
    { 0, 0x0000}, /* 0xbb:                   */
    { 0, 0x0000}, /* 0xbc:                   */
    { 0, 0x0000}, /* 0xbd:                   */
    { 0, 0x0000}, /* 0xbe:                   */
    { 0, 0x0000}, /* 0xbf:                   */
    { 0, 0x0000}, /* 0xc0:                   */
    {10, 0x03fa}, /* 0xc1:        1111111010 */
    {16, 0xffd9}, /* 0xc2:  1111111111011001 */
    {16, 0xffda}, /* 0xc3:  1111111111011010 */
    {16, 0xffdb}, /* 0xc4:  1111111111011011 */
    {16, 0xffdc}, /* 0xc5:  1111111111011100 */
    {16, 0xffdd}, /* 0xc6:  1111111111011101 */
    {16, 0xffde}, /* 0xc7:  1111111111011110 */
    {16, 0xffdf}, /* 0xc8:  1111111111011111 */
    {16, 0xffe0}, /* 0xc9:  1111111111100000 */
    {16, 0xffe1}, /* 0xca:  1111111111100001 */
    { 0, 0x0000}, /* 0xcb:                   */
    { 0, 0x0000}, /* 0xcc:                   */
    { 0, 0x0000}, /* 0xcd:                   */
    { 0, 0x0000}, /* 0xce:                   */
    { 0, 0x0000}, /* 0xcf:                   */
    { 0, 0x0000}, /* 0xd0:                   */
    {11, 0x07f8}, /* 0xd1:       11111111000 */
    {16, 0xffe2}, /* 0xd2:  1111111111100010 */
    {16, 0xffe3}, /* 0xd3:  1111111111100011 */
    {16, 0xffe4}, /* 0xd4:  1111111111100100 */
    {16, 0xffe5}, /* 0xd5:  1111111111100101 */
    {16, 0xffe6}, /* 0xd6:  1111111111100110 */
    {16, 0xffe7}, /* 0xd7:  1111111111100111 */
    {16, 0xffe8}, /* 0xd8:  1111111111101000 */
    {16, 0xffe9}, /* 0xd9:  1111111111101001 */
    {16, 0xffea}, /* 0xda:  1111111111101010 */
    { 0, 0x0000}, /* 0xdb:                   */
    { 0, 0x0000}, /* 0xdc:                   */
    { 0, 0x0000}, /* 0xdd:                   */
    { 0, 0x0000}, /* 0xde:                   */
    { 0, 0x0000}, /* 0xdf:                   */
    { 0, 0x0000}, /* 0xe0:                   */
    {16, 0xffeb}, /* 0xe1:  1111111111101011 */
    {16, 0xffec}, /* 0xe2:  1111111111101100 */
    {16, 0xffed}, /* 0xe3:  1111111111101101 */
    {16, 0xffee}, /* 0xe4:  1111111111101110 */
    {16, 0xffef}, /* 0xe5:  1111111111101111 */
    {16, 0xfff0}, /* 0xe6:  1111111111110000 */
    {16, 0xfff1}, /* 0xe7:  1111111111110001 */
    {16, 0xfff2}, /* 0xe8:  1111111111110010 */
    {16, 0xfff3}, /* 0xe9:  1111111111110011 */
    {16, 0xfff4}, /* 0xea:  1111111111110100 */
    { 0, 0x0000}, /* 0xeb:                   */
    { 0, 0x0000}, /* 0xec:                   */
    { 0, 0x0000}, /* 0xed:                   */
    { 0, 0x0000}, /* 0xee:                   */
    { 0, 0x0000}, /* 0xef:                   */
    {11, 0x07f9}, /* 0xf0:       11111111001 */
    {16, 0xfff5}, /* 0xf1:  1111111111110101 */
    {16, 0xfff6}, /* 0xf2:  1111111111110110 */
    {16, 0xfff7}, /* 0xf3:  1111111111110111 */
    {16, 0xfff8}, /* 0xf4:  1111111111111000 */
    {16, 0xfff9}, /* 0xf5:  1111111111111001 */
    {16, 0xfffa}, /* 0xf6:  1111111111111010 */
    {16, 0xfffb}, /* 0xf7:  1111111111111011 */
    {16, 0xfffc}, /* 0xf8:  1111111111111100 */
    {16, 0xfffd}, /* 0xf9:  1111111111111101 */
    {16, 0xfffe}, /* 0xfa:  1111111111111110 */
    { 0, 0x0000}, /* 0xfb:                   */
    { 0, 0x0000}, /* 0xfc:                   */
    { 0, 0x0000}, /* 0xfd:                   */
    { 0, 0x0000}, /* 0xfe:                   */
    { 0, 0x0000}, /* 0xff:                   */
};

/* 162 valid entries */
static HUFF_ENTRY s_chrom_ac[256] = {

    { 2, 0x0000}, /* 0x00:                00 */
    { 2, 0x0001}, /* 0x01:                01 */
    { 3, 0x0004}, /* 0x02:               100 */
    { 4, 0x000a}, /* 0x03:              1010 */
    { 5, 0x0018}, /* 0x04:             11000 */
    { 5, 0x0019}, /* 0x05:             11001 */
    { 6, 0x0038}, /* 0x06:            111000 */
    { 7, 0x0078}, /* 0x07:           1111000 */
    { 9, 0x01f4}, /* 0x08:         111110100 */
    {10, 0x03f6}, /* 0x09:        1111110110 */
    {12, 0x0ff4}, /* 0x0a:      111111110100 */
    { 0, 0x0000}, /* 0x0b:                   */
    { 0, 0x0000}, /* 0x0c:                   */
    { 0, 0x0000}, /* 0x0d:                   */
    { 0, 0x0000}, /* 0x0e:                   */
    { 0, 0x0000}, /* 0x0f:                   */
    { 0, 0x0000}, /* 0x10:                   */
    { 4, 0x000b}, /* 0x11:              1011 */
    { 6, 0x0039}, /* 0x12:            111001 */
    { 8, 0x00f6}, /* 0x13:          11110110 */
    { 9, 0x01f5}, /* 0x14:         111110101 */
    {11, 0x07f6}, /* 0x15:       11111110110 */
    {12, 0x0ff5}, /* 0x16:      111111110101 */
    {16, 0xff88}, /* 0x17:  1111111110001000 */
    {16, 0xff89}, /* 0x18:  1111111110001001 */
    {16, 0xff8a}, /* 0x19:  1111111110001010 */
    {16, 0xff8b}, /* 0x1a:  1111111110001011 */
    { 0, 0x0000}, /* 0x1b:                   */
    { 0, 0x0000}, /* 0x1c:                   */
    { 0, 0x0000}, /* 0x1d:                   */
    { 0, 0x0000}, /* 0x1e:                   */
    { 0, 0x0000}, /* 0x1f:                   */
    { 0, 0x0000}, /* 0x20:                   */
    { 5, 0x001a}, /* 0x21:             11010 */
    { 8, 0x00f7}, /* 0x22:          11110111 */
    {10, 0x03f7}, /* 0x23:        1111110111 */
    {12, 0x0ff6}, /* 0x24:      111111110110 */
    {15, 0x7fc2}, /* 0x25:   111111111000010 */
    {16, 0xff8c}, /* 0x26:  1111111110001100 */
    {16, 0xff8d}, /* 0x27:  1111111110001101 */
    {16, 0xff8e}, /* 0x28:  1111111110001110 */
    {16, 0xff8f}, /* 0x29:  1111111110001111 */
    {16, 0xff90}, /* 0x2a:  1111111110010000 */
    { 0, 0x0000}, /* 0x2b:                   */
    { 0, 0x0000}, /* 0x2c:                   */
    { 0, 0x0000}, /* 0x2d:                   */
    { 0, 0x0000}, /* 0x2e:                   */
    { 0, 0x0000}, /* 0x2f:                   */
    { 0, 0x0000}, /* 0x30:                   */
    { 5, 0x001b}, /* 0x31:             11011 */
    { 8, 0x00f8}, /* 0x32:          11111000 */
    {10, 0x03f8}, /* 0x33:        1111111000 */
    {12, 0x0ff7}, /* 0x34:      111111110111 */
    {16, 0xff91}, /* 0x35:  1111111110010001 */
    {16, 0xff92}, /* 0x36:  1111111110010010 */
    {16, 0xff93}, /* 0x37:  1111111110010011 */
    {16, 0xff94}, /* 0x38:  1111111110010100 */
    {16, 0xff95}, /* 0x39:  1111111110010101 */
    {16, 0xff96}, /* 0x3a:  1111111110010110 */
    { 0, 0x0000}, /* 0x3b:                   */
    { 0, 0x0000}, /* 0x3c:                   */
    { 0, 0x0000}, /* 0x3d:                   */
    { 0, 0x0000}, /* 0x3e:                   */
    { 0, 0x0000}, /* 0x3f:                   */
    { 0, 0x0000}, /* 0x40:                   */
    { 6, 0x003a}, /* 0x41:            111010 */
    { 9, 0x01f6}, /* 0x42:         111110110 */
    {16, 0xff97}, /* 0x43:  1111111110010111 */
    {16, 0xff98}, /* 0x44:  1111111110011000 */
    {16, 0xff99}, /* 0x45:  1111111110011001 */
    {16, 0xff9a}, /* 0x46:  1111111110011010 */
    {16, 0xff9b}, /* 0x47:  1111111110011011 */
    {16, 0xff9c}, /* 0x48:  1111111110011100 */
    {16, 0xff9d}, /* 0x49:  1111111110011101 */
    {16, 0xff9e}, /* 0x4a:  1111111110011110 */
    { 0, 0x0000}, /* 0x4b:                   */
    { 0, 0x0000}, /* 0x4c:                   */
    { 0, 0x0000}, /* 0x4d:                   */
    { 0, 0x0000}, /* 0x4e:                   */
    { 0, 0x0000}, /* 0x4f:                   */
    { 0, 0x0000}, /* 0x50:                   */
    { 6, 0x003b}, /* 0x51:            111011 */
    {10, 0x03f9}, /* 0x52:        1111111001 */
    {16, 0xff9f}, /* 0x53:  1111111110011111 */
    {16, 0xffa0}, /* 0x54:  1111111110100000 */
    {16, 0xffa1}, /* 0x55:  1111111110100001 */
    {16, 0xffa2}, /* 0x56:  1111111110100010 */
    {16, 0xffa3}, /* 0x57:  1111111110100011 */
    {16, 0xffa4}, /* 0x58:  1111111110100100 */
    {16, 0xffa5}, /* 0x59:  1111111110100101 */
    {16, 0xffa6}, /* 0x5a:  1111111110100110 */
    { 0, 0x0000}, /* 0x5b:                   */
    { 0, 0x0000}, /* 0x5c:                   */
    { 0, 0x0000}, /* 0x5d:                   */
    { 0, 0x0000}, /* 0x5e:                   */
    { 0, 0x0000}, /* 0x5f:                   */
    { 0, 0x0000}, /* 0x60:                   */
    { 7, 0x0079}, /* 0x61:           1111001 */
    {11, 0x07f7}, /* 0x62:       11111110111 */
    {16, 0xffa7}, /* 0x63:  1111111110100111 */
    {16, 0xffa8}, /* 0x64:  1111111110101000 */
    {16, 0xffa9}, /* 0x65:  1111111110101001 */
    {16, 0xffaa}, /* 0x66:  1111111110101010 */
    {16, 0xffab}, /* 0x67:  1111111110101011 */
    {16, 0xffac}, /* 0x68:  1111111110101100 */
    {16, 0xffad}, /* 0x69:  1111111110101101 */
    {16, 0xffae}, /* 0x6a:  1111111110101110 */
    { 0, 0x0000}, /* 0x6b:                   */
    { 0, 0x0000}, /* 0x6c:                   */
    { 0, 0x0000}, /* 0x6d:                   */
    { 0, 0x0000}, /* 0x6e:                   */
    { 0, 0x0000}, /* 0x6f:                   */
    { 0, 0x0000}, /* 0x70:                   */
    { 7, 0x007a}, /* 0x71:           1111010 */
    {11, 0x07f8}, /* 0x72:       11111111000 */
    {16, 0xffaf}, /* 0x73:  1111111110101111 */
    {16, 0xffb0}, /* 0x74:  1111111110110000 */
    {16, 0xffb1}, /* 0x75:  1111111110110001 */
    {16, 0xffb2}, /* 0x76:  1111111110110010 */
    {16, 0xffb3}, /* 0x77:  1111111110110011 */
    {16, 0xffb4}, /* 0x78:  1111111110110100 */
    {16, 0xffb5}, /* 0x79:  1111111110110101 */
    {16, 0xffb6}, /* 0x7a:  1111111110110110 */
    { 0, 0x0000}, /* 0x7b:                   */
    { 0, 0x0000}, /* 0x7c:                   */
    { 0, 0x0000}, /* 0x7d:                   */
    { 0, 0x0000}, /* 0x7e:                   */
    { 0, 0x0000}, /* 0x7f:                   */
    { 0, 0x0000}, /* 0x80:                   */
    { 8, 0x00f9}, /* 0x81:          11111001 */
    {16, 0xffb7}, /* 0x82:  1111111110110111 */
    {16, 0xffb8}, /* 0x83:  1111111110111000 */
    {16, 0xffb9}, /* 0x84:  1111111110111001 */
    {16, 0xffba}, /* 0x85:  1111111110111010 */
    {16, 0xffbb}, /* 0x86:  1111111110111011 */
    {16, 0xffbc}, /* 0x87:  1111111110111100 */
    {16, 0xffbd}, /* 0x88:  1111111110111101 */
    {16, 0xffbe}, /* 0x89:  1111111110111110 */
    {16, 0xffbf}, /* 0x8a:  1111111110111111 */
    { 0, 0x0000}, /* 0x8b:                   */
    { 0, 0x0000}, /* 0x8c:                   */
    { 0, 0x0000}, /* 0x8d:                   */
    { 0, 0x0000}, /* 0x8e:                   */
    { 0, 0x0000}, /* 0x8f:                   */
    { 0, 0x0000}, /* 0x90:                   */
    { 9, 0x01f7}, /* 0x91:         111110111 */
    {16, 0xffc0}, /* 0x92:  1111111111000000 */
    {16, 0xffc1}, /* 0x93:  1111111111000001 */
    {16, 0xffc2}, /* 0x94:  1111111111000010 */
    {16, 0xffc3}, /* 0x95:  1111111111000011 */
    {16, 0xffc4}, /* 0x96:  1111111111000100 */
    {16, 0xffc5}, /* 0x97:  1111111111000101 */
    {16, 0xffc6}, /* 0x98:  1111111111000110 */
    {16, 0xffc7}, /* 0x99:  1111111111000111 */
    {16, 0xffc8}, /* 0x9a:  1111111111001000 */
    { 0, 0x0000}, /* 0x9b:                   */
    { 0, 0x0000}, /* 0x9c:                   */
    { 0, 0x0000}, /* 0x9d:                   */
    { 0, 0x0000}, /* 0x9e:                   */
    { 0, 0x0000}, /* 0x9f:                   */
    { 0, 0x0000}, /* 0xa0:                   */
    { 9, 0x01f8}, /* 0xa1:         111111000 */
    {16, 0xffc9}, /* 0xa2:  1111111111001001 */
    {16, 0xffca}, /* 0xa3:  1111111111001010 */
    {16, 0xffcb}, /* 0xa4:  1111111111001011 */
    {16, 0xffcc}, /* 0xa5:  1111111111001100 */
    {16, 0xffcd}, /* 0xa6:  1111111111001101 */
    {16, 0xffce}, /* 0xa7:  1111111111001110 */
    {16, 0xffcf}, /* 0xa8:  1111111111001111 */
    {16, 0xffd0}, /* 0xa9:  1111111111010000 */
    {16, 0xffd1}, /* 0xaa:  1111111111010001 */
    { 0, 0x0000}, /* 0xab:                   */
    { 0, 0x0000}, /* 0xac:                   */
    { 0, 0x0000}, /* 0xad:                   */
    { 0, 0x0000}, /* 0xae:                   */
    { 0, 0x0000}, /* 0xaf:                   */
    { 0, 0x0000}, /* 0xb0:                   */
    { 9, 0x01f9}, /* 0xb1:         111111001 */
    {16, 0xffd2}, /* 0xb2:  1111111111010010 */
    {16, 0xffd3}, /* 0xb3:  1111111111010011 */
    {16, 0xffd4}, /* 0xb4:  1111111111010100 */
    {16, 0xffd5}, /* 0xb5:  1111111111010101 */
    {16, 0xffd6}, /* 0xb6:  1111111111010110 */
    {16, 0xffd7}, /* 0xb7:  1111111111010111 */
    {16, 0xffd8}, /* 0xb8:  1111111111011000 */
    {16, 0xffd9}, /* 0xb9:  1111111111011001 */
    {16, 0xffda}, /* 0xba:  1111111111011010 */
    { 0, 0x0000}, /* 0xbb:                   */
    { 0, 0x0000}, /* 0xbc:                   */
    { 0, 0x0000}, /* 0xbd:                   */
    { 0, 0x0000}, /* 0xbe:                   */
    { 0, 0x0000}, /* 0xbf:                   */
    { 0, 0x0000}, /* 0xc0:                   */
    { 9, 0x01fa}, /* 0xc1:         111111010 */
    {16, 0xffdb}, /* 0xc2:  1111111111011011 */
    {16, 0xffdc}, /* 0xc3:  1111111111011100 */
    {16, 0xffdd}, /* 0xc4:  1111111111011101 */
    {16, 0xffde}, /* 0xc5:  1111111111011110 */
    {16, 0xffdf}, /* 0xc6:  1111111111011111 */
    {16, 0xffe0}, /* 0xc7:  1111111111100000 */
    {16, 0xffe1}, /* 0xc8:  1111111111100001 */
    {16, 0xffe2}, /* 0xc9:  1111111111100010 */
    {16, 0xffe3}, /* 0xca:  1111111111100011 */
    { 0, 0x0000}, /* 0xcb:                   */
    { 0, 0x0000}, /* 0xcc:                   */
    { 0, 0x0000}, /* 0xcd:                   */
    { 0, 0x0000}, /* 0xce:                   */
    { 0, 0x0000}, /* 0xcf:                   */
    { 0, 0x0000}, /* 0xd0:                   */
    {11, 0x07f9}, /* 0xd1:       11111111001 */
    {16, 0xffe4}, /* 0xd2:  1111111111100100 */
    {16, 0xffe5}, /* 0xd3:  1111111111100101 */
    {16, 0xffe6}, /* 0xd4:  1111111111100110 */
    {16, 0xffe7}, /* 0xd5:  1111111111100111 */
    {16, 0xffe8}, /* 0xd6:  1111111111101000 */
    {16, 0xffe9}, /* 0xd7:  1111111111101001 */
    {16, 0xffea}, /* 0xd8:  1111111111101010 */
    {16, 0xffeb}, /* 0xd9:  1111111111101011 */
    {16, 0xffec}, /* 0xda:  1111111111101100 */
    { 0, 0x0000}, /* 0xdb:                   */
    { 0, 0x0000}, /* 0xdc:                   */
    { 0, 0x0000}, /* 0xdd:                   */
    { 0, 0x0000}, /* 0xde:                   */
    { 0, 0x0000}, /* 0xdf:                   */
    { 0, 0x0000}, /* 0xe0:                   */
    {14, 0x3fe0}, /* 0xe1:    11111111100000 */
    {16, 0xffed}, /* 0xe2:  1111111111101101 */
    {16, 0xffee}, /* 0xe3:  1111111111101110 */
    {16, 0xffef}, /* 0xe4:  1111111111101111 */
    {16, 0xfff0}, /* 0xe5:  1111111111110000 */
    {16, 0xfff1}, /* 0xe6:  1111111111110001 */
    {16, 0xfff2}, /* 0xe7:  1111111111110010 */
    {16, 0xfff3}, /* 0xe8:  1111111111110011 */
    {16, 0xfff4}, /* 0xe9:  1111111111110100 */
    {16, 0xfff5}, /* 0xea:  1111111111110101 */
    { 0, 0x0000}, /* 0xeb:                   */
    { 0, 0x0000}, /* 0xec:                   */
    { 0, 0x0000}, /* 0xed:                   */
    { 0, 0x0000}, /* 0xee:                   */
    { 0, 0x0000}, /* 0xef:                   */
    {10, 0x03fa}, /* 0xf0:        1111111010 */
    {15, 0x7fc3}, /* 0xf1:   111111111000011 */
    {16, 0xfff6}, /* 0xf2:  1111111111110110 */
    {16, 0xfff7}, /* 0xf3:  1111111111110111 */
    {16, 0xfff8}, /* 0xf4:  1111111111111000 */
    {16, 0xfff9}, /* 0xf5:  1111111111111001 */
    {16, 0xfffa}, /* 0xf6:  1111111111111010 */
    {16, 0xfffb}, /* 0xf7:  1111111111111011 */
    {16, 0xfffc}, /* 0xf8:  1111111111111100 */
    {16, 0xfffd}, /* 0xf9:  1111111111111101 */
    {16, 0xfffe}, /* 0xfa:  1111111111111110 */
    { 0, 0x0000}, /* 0xfb:                   */
    { 0, 0x0000}, /* 0xfc:                   */
    { 0, 0x0000}, /* 0xfd:                   */
    { 0, 0x0000}, /* 0xfe:                   */
    { 0, 0x0000}  /* 0xff:                   */
};

/*--------------------------------------------------------------------+
 |                                                                    |
 | static routine forward declarations                                |
 |                                                                    |
 +--------------------------------------------------------------------*/

static int    s_get_palette_index(BYTE* line_data, int bitcount, int col);
static DWORD  s_get_pixel_rgb(unsigned char* pline, int bitcount, unsigned int col);
static char** s_alloc_2d_byte_array(WORD row, WORD col);
static void   s_free_2d_byte_array(char** array, WORD row);
static void   s_do_fdct(int blk[8][8], int fdct[8][8]);
static BYTE   s_get_category(short value);
static int    s_is_huffman_bits_valid(BYTE bits[16]);
static int    s_pack_bits(BYTE** p,       /* <--> */
                       BYTE*  offset,  /* <--> */
                       BYTE   size,
                       short  code);

/*--------------------------------------------------------------------+
 |                                                                    |
 | exported routines implementations                                  |
 |                                                                    |
 +--------------------------------------------------------------------*/


/* created(bruin, 2002.11.24)
 * -------------------------------------------------------------------
 * purpose: get the RGB color component of a pixel in the bmp image
 * inputs: 
 *     pbmp: pointer to the start of the whole bmp file data 
 *     row, col: the pixel position within the image
 * outputs:
 * returns: 0xeebbggrr
 *     ee: BMP_ERROR_CODE
 *     bb: blue
 *     gg: green
 *     rr: red
 * -------------------------------------------------------------------
*/
DWORD bmp_get_rgb_of_pixel(BYTE* pbmp, WORD row, WORD col){

    int   palette_size, line_size, idx;
    BYTE* p;
    xBITMAPFILEHEADER* bmfh = (xBITMAPFILEHEADER*)pbmp; 
    xBITMAPINFO*       bmi = (xBITMAPINFO*)(pbmp + sizeof(xBITMAPFILEHEADER)); 


    /* sanity checks */
    if(bmfh->bfType != (('M'<<8) | 'B')){
        return BMP_FORMAT_ERROR << 24;
    }
    if(bmi->bmiHeader.biCompression != xBI_RGB){
        return BMP_NOT_SUPPORT << 24;
    }
    if(bmi->bmiHeader.biSize < /* != */ sizeof(xBITMAPINFOHEADER))
        return BMP_FORMAT_ERROR << 24;
    if(col > bmi->bmiHeader.biWidth)
        return BMP_X_OUT_OF_RANGE << 24;
    if(row > ((bmi->bmiHeader.biHeight > 0)? bmi->bmiHeader.biHeight : - 1 * bmi->bmiHeader.biHeight))
        return BMP_Y_OUT_OF_RANGE << 24;


    if(bmi->bmiHeader.biBitCount > 8) 
        palette_size = 0; 
    else if(bmi->bmiHeader.biClrUsed == 0) 
        palette_size = 1 << bmi->bmiHeader.biBitCount; 
    else 
        palette_size = bmi->bmiHeader.biClrUsed; 
    
    line_size = (bmi->bmiHeader.biWidth * bmi->bmiHeader.biBitCount + 31) >> 5 << 2; /* 4 byte alignment */


    /* make p points to the start of the image data of the requested row */
    p = (bmi->bmiHeader.biHeight < 0) ? pbmp + bmfh->bfOffBits + row * line_size : pbmp + bmfh->bfOffBits + (bmi->bmiHeader.biHeight - 1 - row) * line_size;

    if(palette_size > 0){
        if((idx = s_get_palette_index(p, bmi->bmiHeader.biBitCount, col)) < 0)
            return BMP_WRONG_BITCOUNT << 24;
        else
            return bmi->bmiColors[idx].rgbBlue << 16 | bmi->bmiColors[idx].rgbGreen << 8 | bmi->bmiColors[idx].rgbRed;
    }
    else{
        return s_get_pixel_rgb(p, bmi->bmiHeader.biBitCount, col);
    }
}


/* created(bruin, 2002.11.24)
 * -------------------------------------------------------------------
 * purpose: build a coordinate mapping from original size (row0, col0) 
 *     to new size (row, col)
 * inputs:
 *     row0, col0: original image size
 *     row, col: new image size to be mapped to
 * outputs:
 *     prow, pcol: pointer to array of mapped coordinates. array idx is 
 *                 the row/col in new image size, while array value at 
 *                 the idx is the row/col in original image size.
 * returns: 0 is ok, otherwise fail.
 * notes: caller is responsible to free "prow" and "pcol" arrays.
 * -------------------------------------------------------------------
*/
int util_get_coord_map(WORD row0, WORD col0, WORD row, WORD col, WORD** prow, WORD** pcol){

    int     i;
    float   rx, ry;

    if(row0 == 0 || col0 == 0 || row == 0 || col == 0)
        return - 1;

    *prow = 0;
    *pcol = 0;

    if(!(*prow = (WORD*)malloc(sizeof(WORD)*row)))
        return - 1;

    if(!(*pcol = (WORD*)malloc(sizeof(WORD)*col))){
        free(*prow);
        *prow = 0;
        return - 1;
    }

    rx = (float)col0 / col;
    ry = (float)row0 / row;
    
    for(i = 0; i < row; i ++)
        (*prow)[i] = (WORD)(i * ry);
    for(i = 0; i < col; i ++)
        (*pcol)[i] = (WORD)(i * rx);

    return 0;
}

/* created(bruin, 2002.11.24)
 * -------------------------------------------------------------------
 * purpose: build YUV12 data structure from original bmp file
 * inputs:
 *     pbmp: pointer to the begining of the whole bmp file data
 * outputs:
 * returns: 0 for failure, otherwise a pointer to the converted YUV12
 *          structure.
 * notes: caller is responsible to free memory by "free_yuv12()"
 * -------------------------------------------------------------------
*/
YUV12* bmp_rgb_to_yuv12(BYTE* pbmp){

    int                i, j, k, palette_size, row_size, off1, off2;
    YUV12*             yuv;
    xBITMAPFILEHEADER* bmfh = (xBITMAPFILEHEADER*)pbmp; 
    xBITMAPINFO*       bmi = (xBITMAPINFO*)(pbmp + sizeof(xBITMAPFILEHEADER)); 
    BYTE               r[2][2], g[2][2], b[2][2], rm, gm, bm, c, mask, idx;
	BYTE               *p, *p0, *p1;

    /* sanity checks */
    if(bmfh->bfType != (('M'<<8) | 'B'))
        return 0;

    if(bmi->bmiHeader.biCompression != xBI_RGB)
        return 0;

    if(bmi->bmiHeader.biSize < /* != */ sizeof(xBITMAPINFOHEADER))
        return 0;

    if(!(yuv = (YUV12*)malloc(sizeof(YUV12))))
        return 0;

    /* original size */
    yuv->col0 = (WORD)bmi->bmiHeader.biWidth;
    yuv->row0 = (WORD)abs(bmi->bmiHeader.biHeight);

    /* new size to be MCU (macroblock in MPEG)dividable */
    yuv->col = (yuv->col0 + 15) / 16 * 16;
    yuv->row = (yuv->row0 + 15) / 16 * 16;

    /* allocate memory for each 2D array: Y, U, V */
    if(!(yuv->y = s_alloc_2d_byte_array(yuv->row, yuv->col)))
        return 0;
    if(!(yuv->u = s_alloc_2d_byte_array(yuv->row >> 1, yuv->col >> 1))){
        s_free_2d_byte_array(yuv->y, yuv->row);
        return 0;
    }
    if(!(yuv->v = s_alloc_2d_byte_array(yuv->row >> 1, yuv->col >> 1))){
        s_free_2d_byte_array(yuv->y, yuv->row);
        s_free_2d_byte_array(yuv->u, yuv->row >> 1);
        return 0;
    }

	/* get palette size */
	if(bmi->bmiHeader.biBitCount > 8) 
        palette_size = 0; 
    else if(bmi->bmiHeader.biClrUsed == 0) 
        palette_size = 1 << bmi->bmiHeader.biBitCount; 
    else 
        palette_size = bmi->bmiHeader.biClrUsed; 

    /* make p points to the top line of the image */
    row_size = (bmi->bmiHeader.biWidth * bmi->bmiHeader.biBitCount + 31) >> 5 << 2; /* 4 byte alignment */
	if(bmi->bmiHeader.biHeight > 0){
		p = pbmp + bmfh->bfOffBits + (bmi->bmiHeader.biHeight - 1) * row_size;
		row_size = - row_size;
	}
	else{
		p = pbmp + bmfh->bfOffBits;
	}

	for(i = 0; i < yuv->row / 2; i ++){
        /* jpeg standard recommends duplicating the last row or column
           of pixels to fill out incomplete data units */
		k = MIN(2 * i, yuv->row0 - 1);
		p0 = p + k * row_size;
		k = MIN(2 * i + 1, yuv->row0 - 1);
		p1 = p + k * row_size;

		for(j = 0; j < yuv->col / 2; j ++){

			/* process each MCU to get r[2][2], g[2][2], b[2][2]:
				 (i*2,  j*2) | (i*2,  j*2+1)
				 ------------+---------------
				 (i*2+1,j*2) | (i*2+1,j*2+1)    
			*/
			if(palette_size > 0){
				/* [0][0] */
				off1 = bmi->bmiHeader.biBitCount * (2 * j) / 8;
				if(off1 > (abs(row_size) - 1))
					off1 = abs(row_size) - 1;
				c = p0[off1];
				off2 = bmi->bmiHeader.biBitCount * (2 * j) % 8;
				mask = 0;
				for(k = 1; k <= bmi->bmiHeader.biBitCount; k ++)
					mask |= 1 << (8 - off2 - k);

				idx = (c & mask) >> (8 - off2 - bmi->bmiHeader.biBitCount);

				r[0][0] = bmi->bmiColors[idx].rgbRed;
				b[0][0] = bmi->bmiColors[idx].rgbBlue;
				g[0][0] = bmi->bmiColors[idx].rgbGreen;

				/* [0][1] */
				off1 = bmi->bmiHeader.biBitCount * (2 * j + 1) / 8;
				if(off1 > (abs(row_size) - 1))
					off1 = abs(row_size) - 1;
				c = p0[off1];
				off2 = bmi->bmiHeader.biBitCount * (2 * j + 1) % 8;
				mask = 0;
				for(k = 1; k <= bmi->bmiHeader.biBitCount; k ++)
					mask |= 1 << (8 - off2 - k);

				idx = (c & mask) >> (8 - off2 - bmi->bmiHeader.biBitCount);

				r[0][1] = bmi->bmiColors[idx].rgbRed;
				b[0][1] = bmi->bmiColors[idx].rgbBlue;
				g[0][1] = bmi->bmiColors[idx].rgbGreen;

				/* [1][0] */
				off1 = bmi->bmiHeader.biBitCount * (2 * j) / 8;
				if(off1 > (abs(row_size) - 1))
					off1 = abs(row_size) - 1;
				c = p1[off1];
				off2 = bmi->bmiHeader.biBitCount * (2 * j) % 8;
				mask = 0;
				for(k = 1; k <= bmi->bmiHeader.biBitCount; k ++)
					mask |= 1 << (8 - off2 - k);

				idx = (c & mask) >> (8 - off2 - bmi->bmiHeader.biBitCount);

				r[1][0] = bmi->bmiColors[idx].rgbRed;
				b[1][0] = bmi->bmiColors[idx].rgbBlue;
				g[1][0] = bmi->bmiColors[idx].rgbGreen;

				/* [1][1] */
				off1 = bmi->bmiHeader.biBitCount * (2 * j + 1) / 8;
				if(off1 > (abs(row_size) - 1))
					off1 = abs(row_size) - 1;
				c = p1[off1];
				off2 = bmi->bmiHeader.biBitCount * (2 * j + 1) % 8;
				mask = 0;
				for(k = 1; k <= bmi->bmiHeader.biBitCount; k ++)
					mask |= 1 << (8 - off2 - k);

				idx = (c & mask) >> (8 - off2 - bmi->bmiHeader.biBitCount);

				r[1][1] = bmi->bmiColors[idx].rgbRed;
				b[1][1] = bmi->bmiColors[idx].rgbBlue;
				g[1][1] = bmi->bmiColors[idx].rgbGreen;

			}
			else{

				/* [0][0] & [1][0] */
				k = MIN(2 * j, bmi->bmiHeader.biWidth - 1);
				off1 = bmi->bmiHeader.biBitCount * k / 8;

				switch(bmi->bmiHeader.biBitCount){
					case 16:
						/* A 5-5-5 16-bit image, where the blue mask is 0x001F, 
						   the green mask is 0x03E0, and the red mask is 0x7C00 */
						r[0][0] = (*((unsigned short*)(p0 + off1)) & 0x7c00) >> 16;
						g[0][0] = (*((unsigned short*)(p0 + off1)) & 0x03e0) >> 8;
						b[0][0] = (*((unsigned short*)(p0 + off1)) & 0x001f);
						break;
					case 24:
						b[0][0] = p0[off1];
						g[0][0] = p0[off1 + 1];
						r[0][0] = p0[off1 + 2];
						break;
					case 32:
						b[0][0] = p0[off1 + 1];
						g[0][0] = p0[off1 + 2];
						r[0][0] = p0[off1 + 3];
						break;
				}

				/* [1][0] */
				switch(bmi->bmiHeader.biBitCount){
					case 16:
						/* A 5-5-5 16-bit image, where the blue mask is 0x001F, 
						   the green mask is 0x03E0, and the red mask is 0x7C00 */
						r[1][0] = (*((unsigned short*)(p1 + off1)) & 0x7c00) >> 16;
						g[1][0] = (*((unsigned short*)(p1 + off1)) & 0x03e0) >> 8;
						b[1][0] = (*((unsigned short*)(p1 + off1)) & 0x001f);
						break;
					case 24:
						b[1][0] = p1[off1];
						g[1][0] = p1[off1 + 1];
						r[1][0] = p1[off1 + 2];
						break;
					case 32:
						b[1][0] = p1[off1 + 1];
						g[1][0] = p1[off1 + 2];
						r[1][0] = p1[off1 + 3];
						break;
				}



				/* [0][1] & [1][1] */
				k = MIN(2 * j + 1, bmi->bmiHeader.biWidth - 1);
				off1 = bmi->bmiHeader.biBitCount * k / 8;

				switch(bmi->bmiHeader.biBitCount){
					case 16:
						/* A 5-5-5 16-bit image, where the blue mask is 0x001F, 
						   the green mask is 0x03E0, and the red mask is 0x7C00 */
						r[0][1] = (*((unsigned short*)(p0 + off1)) & 0x7c00) >> 16;
						g[0][1] = (*((unsigned short*)(p0 + off1)) & 0x03e0) >> 8;
						b[0][1] = (*((unsigned short*)(p0 + off1)) & 0x001f);
						break;
					case 24:
						b[0][1] = p0[off1];
						g[0][1] = p0[off1 + 1];
						r[0][1] = p0[off1 + 2];
						break;
					case 32:
						b[0][1] = p0[off1 + 1];
						g[0][1] = p0[off1 + 2];
						r[0][1] = p0[off1 + 3];
						break;
				}

				/* [1][1] */
				switch(bmi->bmiHeader.biBitCount){
					case 16:
						/* A 5-5-5 16-bit image, where the blue mask is 0x001F, 
						   the green mask is 0x03E0, and the red mask is 0x7C00 */
						r[1][1] = (*((unsigned short*)(p1 + off1)) & 0x7c00) >> 16;
						g[1][1] = (*((unsigned short*)(p1 + off1)) & 0x03e0) >> 8;
						b[1][1] = (*((unsigned short*)(p1 + off1)) & 0x001f);
						break;
					case 24:
						b[1][1] = p1[off1];
						g[1][1] = p1[off1 + 1];
						r[1][1] = p1[off1 + 2];
						break;
					case 32:
						b[1][1] = p1[off1 + 1];
						g[1][1] = p1[off1 + 2];
						r[1][1] = p1[off1 + 3];
						break;
				}
			}

            /* calculate 4 Y values */
            yuv->y[i * 2    ][j * 2    ] = (char)(0.299 * r[0][0] + 0.587 * g[0][0] + 0.114 * b[0][0] - 128);
            yuv->y[i * 2    ][j * 2 + 1] = (char)(0.299 * r[0][1] + 0.587 * g[0][1] + 0.114 * b[0][1] - 128);
            yuv->y[i * 2 + 1][j * 2    ] = (char)(0.299 * r[1][0] + 0.587 * g[1][0] + 0.114 * b[1][0] - 128);
            yuv->y[i * 2 + 1][j * 2 + 1] = (char)(0.299 * r[1][1] + 0.587 * g[1][1] + 0.114 * b[1][1] - 128);

            /* calculate U/V values */
			/*
            rm = (char)((r[0][0] + r[0][1] + r[1][0] + r[1][1]) / 4.0);
            gm = (char)((g[0][0] + g[0][1] + g[1][0] + g[1][1]) / 4.0);
            bm = (char)((b[0][0] + b[0][1] + b[1][0] + b[1][1]) / 4.0);
			*/
			rm = r[0][0];
			gm = g[0][0];
			bm = b[0][0];
            yuv->u[i][j] = (char)(- 0.1687 * rm - 0.3313 * gm + 0.5000 * bm);
            yuv->v[i][j] = (char)(  0.5000 * rm - 0.4187 * gm - 0.0813 * bm);
		}
			
	}



#if (0) /* this is a slower version. make sense when processing big files */
    /* process each MCU: 

         (i*2,  j*2) | (i*2,  j*2+1)
         ------------+---------------
         (i*2+1,j*2) | (i*2+1,j*2+1)    

    */
    for(i = 0; i < yuv->row / 2; i ++){
        for(j = 0; j < yuv->col / 2; j ++){

            /* get r[2][2], g[2][2], b[2][2] */

            m = i * 2;
            n = j * 2;
            /* jpeg standard recommends duplicating the last column or row
               of pixels to fill out incomplete data units */
            if(m > (yuv->row0 - 1))
                m = yuv->row0 - 1;
            if(n > (yuv->col0 - 1))
                n = yuv->col0 - 1;
            bgr =  bmp_get_rgb_of_pixel(pbmp, m, n);
            r[0][0] = (BYTE)(bgr & 0x000000ff);
            b[0][0] = (BYTE)((bgr & 0x00ff0000) >> 16);
            g[0][0] = (BYTE)((bgr & 0x0000ff00) >> 8);

            m = i * 2;
            n = j * 2 + 1;
            if(m > (yuv->row0 - 1))
                m = yuv->row0 - 1;
            if(n > (yuv->col0 - 1))
                n = yuv->col0 - 1;
            bgr =  bmp_get_rgb_of_pixel(pbmp, m, n);
            r[0][1] = (BYTE)(bgr & 0x000000ff);
            b[0][1] = (BYTE)((bgr & 0x00ff0000) >> 16);
            g[0][1] = (BYTE)((bgr & 0x0000ff00) >> 8);

            m = i * 2 + 1;
            n = j * 2;
            if(m > (yuv->row0 - 1))
                m = yuv->row0 - 1;
            if(n > (yuv->col0 - 1))
                n = yuv->col0 - 1;
            bgr =  bmp_get_rgb_of_pixel(pbmp, m, n);
            r[1][0] = (BYTE)(bgr & 0x000000ff);
            b[1][0] = (BYTE)((bgr & 0x00ff0000) >> 16);
            g[1][0] = (BYTE)((bgr & 0x0000ff00) >> 8);

            m = i * 2 + 1;
            n = j * 2 + 1;
            if(m > (yuv->row0 - 1))
                m = yuv->row0 - 1;
            if(n > (yuv->col0 - 1))
                n = yuv->col0 - 1;
            bgr =  bmp_get_rgb_of_pixel(pbmp, m, n);
            r[1][1] = (BYTE)(bgr & 0x000000ff);
            b[1][1] = (BYTE)((bgr & 0x00ff0000) >> 16);
            g[1][1] = (BYTE)((bgr & 0x0000ff00) >> 8);

            /* calculate 4 Y values */
            yuv->y[i * 2    ][j * 2    ] = (char)(0.299 * r[0][0] + 0.587 * g[0][0] + 0.114 * b[0][0] - 128);
            yuv->y[i * 2    ][j * 2 + 1] = (char)(0.299 * r[0][1] + 0.587 * g[0][1] + 0.114 * b[0][1] - 128);
            yuv->y[i * 2 + 1][j * 2    ] = (char)(0.299 * r[1][0] + 0.587 * g[1][0] + 0.114 * b[1][0] - 128);
            yuv->y[i * 2 + 1][j * 2 + 1] = (char)(0.299 * r[1][1] + 0.587 * g[1][1] + 0.114 * b[1][1] - 128);

            /* calculate U/V values */

            rm = (char)((r[0][0] + r[0][1] + r[1][0] + r[1][1]) / 4.0);
            gm = (char)((g[0][0] + g[0][1] + g[1][0] + g[1][1]) / 4.0);
            bm = (char)((b[0][0] + b[0][1] + b[1][0] + b[1][1]) / 4.0);

            yuv->u[i][j] = (char)(- 0.1687 * rm - 0.3313 * gm + 0.5000 * bm);
            yuv->v[i][j] = (char)(  0.5000 * rm - 0.4187 * gm - 0.0813 * bm);

        }
    }
#endif

    return yuv;
}

/* created(bruin, 2002.11.24)
 * -------------------------------------------------------------------
 * purpose: free memory of a YUV12 allocated before
 * inputs: 
 *     yuv: pointer to the YUV12 structure
 * outputs:
 * returns:
 * -------------------------------------------------------------------
*/
void free_yuv12(YUV12* yuv){

    if(!yuv)
        return;

    s_free_2d_byte_array(yuv->y, yuv->row);
    s_free_2d_byte_array(yuv->u, yuv->row >> 1);
    s_free_2d_byte_array(yuv->v, yuv->row >> 1);

    free(yuv);
}

/* return: TRUE (ok) or FALSE (fail).
   it guarantees the memory of vector[64] is already allocated by caller */
int fwd_dct(char** array, WORD row_start, WORD col_start, int* vector){

    int          i, j;
	/*
    int          blk[8][8];
    int          fdct[8][8];
	*/
	int          local[64];

    if(!vector)
        return FALSE;
#if (0) /* slower version */
    for(i = 0; i < 8; i ++)
	for(j = 0; j < 8; j ++)
		blk[i][j] = array[row_start + i][col_start + j] /* - 128 */;

    s_do_fdct(blk, fdct);

    for(i = 0; i < 8; i ++)
    for(j = 0; j < 8; j ++)
        vector[s_zigzag[i][j]] = fdct[i][j];
#endif
#if(1) /* fast version copied from open source */
    for(i = 0; i < 8; i ++)
	for(j = 0; j < 8; j ++)
		local[i*8+j] = array[row_start + i][col_start + j] /* - 128 */;

	j_fwd_dct(local);

	for(i = 0; i < 64; i ++){
		vector[s_zigzag[i / 8][i % 8]] = local[i];
	}
#endif
    return TRUE;
}

void quantise(int* vector, BYTE is_lumin){

    int   i;
    BYTE  *qt;
	/*float f;*/

    if(is_lumin)
        qt = s_lumin_qt;
    else
        qt = s_chrom_qt;
        

    for(i = 0; i < 64; i ++){
		/*
		f = (float)vector[i] / qt[i];
		if(f > 0)
			vector[i] = (int)(f + 0.5);
		else
			vector[i] = (int)(f - 0.5);
		*/

        vector[i] = (int)((float)vector[i] / qt[i] + 0.5);
	}
}

/* purpose: compress the quantized 8*8 Data Unit by standard huffman code table
   return:  the nr of bits after compression
            0 means errors.
*/
int encode_du(char   is_lumin,   /* <-- component type, either luminance or chrominance */
              int    pre_dc,     /* <-- the DC value in previous DU */
              int    vector[64], /* <-- quantized zig-zagged 8*8 unit */
              BYTE   du[128]){   /* --> bitstream after compression. 128 should be bigger enough */

    int   i, j, k, size;
    int   delta = vector[0] - pre_dc;
    char  rle1[64];   /* RLE pairs, and nr of pairs */
    short rle2[64], n;
    BYTE  category, *p, offset;

    p = du; 
    offset = 0;
    size = 0;
    /* A: compress DC difference:
       A.1: diff = (category, bit-coded representation)
       A.2: bitstream of diff = (huffman_code(category), bit-coded representation 
    */
    if((category = s_get_category(delta)) > 11) /* out of DC diff range */
        return 0;

    if(delta < 0){
        /* delta = ~(-delta); */
        delta --;
    }

    /* huff_code(category) */
    if(is_lumin)
        size += s_pack_bits(&p, &offset, s_lumin_dc[category].size, s_lumin_dc[category].code);
    else
        size += s_pack_bits(&p, &offset, s_chrom_dc[category].size, s_chrom_dc[category].code);

    /* bit-code */
    size += s_pack_bits(&p, &offset, category, delta);
    

    /* B: compress AC:
       B.1: RLE into pairs
       B.2: huffman encoding pairs (run, value):
            huffman_code((run, category(value))) + bit_pattern(value)
    */

    /* B.1: RLE */
    n = 0;          /* (n + 1) is the nr of pairs in RLE */
    rle1[n] = 0;    /* init the first pair */
    rle2[n] = 0;

    for(i = 1; i < 64; i ++){   /* skip the first value: DC */
        if(vector[i] == 0){
            rle1[n] ++;
            /* if loop finished from here, we need make the last pair to EOB (0,0) */
        }
        else{
            k = rle1[n] / 16;
            rle1[n + k] = rle1[n] % 16;
            rle2[n + k] = vector[i];
            for(j = 0; j < k; j ++, n++){
                rle1[n] = 15;
                rle2[n] = 0;
            }

            /* if loop finished here, do (n --). no EOB in this case */

            /* init the next pair */
            n ++;
            rle1[n] = 0;
            rle2[n] = 0;
        }
    }

    if(rle1[n] == 0 && rle2[n] == 0)
        n --;
    else
        rle1[n] = 0;

    /* B.2: huffman encoding the pairs */
    for(i = 0; i <= n; i ++){
        category = s_get_category(rle2[i]);

        if(is_lumin)
            size += s_pack_bits(&p, &offset, s_lumin_ac[(rle1[i] << 4) + category].size, s_lumin_ac[(rle1[i] << 4) + category].code);
        else
            size += s_pack_bits(&p, &offset, s_chrom_ac[(rle1[i] << 4) + category].size, s_chrom_ac[(rle1[i] << 4) + category].code);

        if(rle2[i] < 0){
            /* rle2[i] = ~(-rle2[i]); */
            rle2[i] --;
        }

        size += s_pack_bits(&p, &offset, category, rle2[i]);
    }


    return size;
}

/* purpose: get standard jpeg segment data by specifing the marker, 
            including SOI, APP0, DQT, DHT, EOI, SOF0, SOS
   return: pointer to the start of segment, and the size of the segment.
           null means error.
*/
BYTE*  get_std_segment(BYTE marker, int *size, WORD p1, WORD p2){
    switch(marker){
        case SOI:
            *size = 2;
            return "\xff\xd8";
        case APP0:
            *size = sizeof(s_std_app0);
            return s_std_app0;
        case COM:
            *size = sizeof(s_std_com);
            return s_std_com;
        case DQT:
            *size = sizeof(s_std_dqt);
            return s_std_dqt;
        case SOF0:
            /* p1 is image height, p2 is image width */
            s_std_sof0[5] = p1 >> 8;
            s_std_sof0[6] = (BYTE)p1;
            s_std_sof0[7] = p2 >> 8;
            s_std_sof0[8] = (BYTE)p2;
            *size = sizeof(s_std_sof0);
            return s_std_sof0;
        case DHT:
            *size = sizeof(s_std_dht);
            return s_std_dht;
        case SOS:
            *size = sizeof(s_std_sos);
            return s_std_sos;
        case EOI:
            *size = 2;
            return "\xff\xd9";
           
        default:
            *size = 0;
            return 0;
    }
}


int cal_dht(BYTE bits[16], BYTE* huffval, HUFF_ENTRY* dht){
        int        i, j, k, ncode;
		unsigned short       code;
		HUFF_ENTRY local[162];

		if(!s_is_huffman_bits_valid(bits))
			return FALSE;

		k = 0;
        for(i = 0; i < 16; i ++)
                for(j = 0; j < bits[i]; j ++){
                        local[k++].size = i + 1;
                }

        ncode = k;

        /* create the codes */
        code = 0x00;
        for(i = 0; i < ncode; i ++){
                if(i == 0 || (local[i].code == local[i - 1].code)){
                        local[i].code = code;
                        code ++;
                }
                else{
                        code <<= (local[i].size - local[i - 1].size);
                        local[i].code = code;
                        code ++;
                }
        }

		
		for(i = 0; i < ncode; i ++){
			dht[huffval[i]].code = local[i].code;
			dht[huffval[i]].size = local[i].size;
		}

		return TRUE;
}

void write_bits_to_file(int size, BYTE* p, FILE* fp, int if_flush){

	static BYTE s_buf = 0;
	static int s_nbits = 0; /* existing bits not flushed */

    int  i, j;
    char xxx[] = "\xff\x00"; /* replace 0xff with 0xff, 0x00 */

    for(i = 0; i < size / 8; i ++){
        if(!s_nbits){
            if(p[i] != 0xff)
                fwrite(p + i, 1, 1, fp);
            else
                fwrite(xxx, 2, 1, fp);
        }
        else{
            s_buf |= p[i] >> s_nbits;
            if(s_buf != 0xff)
                fwrite(&s_buf, 1, 1, fp);
            else
                fwrite(xxx, 2, 1, fp);
            s_buf = 0;
            s_buf = p[i] << (8 - s_nbits);
        }
    }

    j = size % 8;
    if(j){
        if(s_nbits + j >= 8){
            s_buf |= (p[i] >> s_nbits);
            if(s_buf != 0xff)
                fwrite(&s_buf, 1, 1, fp);
            else
                fwrite(xxx, 2, 1, fp);
            s_buf = 0;
            s_buf = p[i];
            s_buf >>= (8 - j);
            s_buf <<= (16 - j - s_nbits);
            s_nbits = (s_nbits + j) % 8;
        }
        else{
            s_buf |= ((p[i] >> (8 - j)) << (8 - j)) >> s_nbits;
            s_nbits += j;
        }
    }

    if(if_flush && s_nbits){
       fwrite(&s_buf, 1, 1, fp);
	   s_buf = 0;
	   s_nbits = 0;
	}
}

int bmp2jpeg(BYTE* pbmp, FILE* fp){
	YUV12* yuv = NULL; 
	int    vector[64];
	int    i, j, size, ypdc, updc, vpdc;
	BYTE   du[128]; /* this size should be safe for holding encoded data, 
                       even without quantization. as tested, 64 is not 
                       enough when using quantization coefficients 1 (i.e.,
                       no quantization). */
	BYTE*  p;

	/* get the yuv12 raw data */
	yuv = bmp_rgb_to_yuv12(pbmp); 
	if(!yuv){
		printf("error when converting RGB to YUV.\n");
		return FALSE;
	}

	/* jpeg file headers */
	p = get_std_segment(SOI, &size, 0, 0);	 fwrite(p, size, 1, fp);
	p = get_std_segment(APP0, &size, 0, 0); fwrite(p, size, 1, fp);
	p = get_std_segment(COM, &size, 0, 0);	 fwrite(p, size, 1, fp);
	p = get_std_segment(DQT, &size, 0, 0);	 fwrite(p, size, 1, fp);
	p = get_std_segment(SOF0, &size, yuv->row0, yuv->col0); fwrite(p, size, 1, fp);
	p = get_std_segment(DHT, &size, 0, 0);  fwrite(p, size, 1, fp);
	p = get_std_segment(SOS, &size, 0, 0);  fwrite(p, size, 1, fp);

	
	/* for each MCU */
    ypdc = 0; /* previous DC */
	updc = 0;
	vpdc = 0;
    for(i = 0; i < yuv->row / 16; i ++){
        for(j = 0; j < yuv->col / 16; j ++){

			/* 4 YDUs */
			/* 2*i, 2*j */		
        	fwd_dct(yuv->y, 8 * (i * 2), 8 * (j * 2), vector);
            quantise(vector, 1);
            size = encode_du(1, ypdc, vector, du);
            ypdc = vector[0];
            write_bits_to_file(size, du, fp, 0);

			/* 2*i, 2*j + 1 */		
        	fwd_dct(yuv->y, 8 * (i * 2), 8 * (j * 2 + 1), vector);
            quantise(vector, 1);
            size = encode_du(1, ypdc, vector, du);
            ypdc = vector[0];
            write_bits_to_file(size, du, fp, 0);

			/* 2*i+1, 2*j */		
        	fwd_dct(yuv->y, 8 * (i * 2 + 1), 8 * (j * 2), vector);
            quantise(vector, 1);
            size = encode_du(1, ypdc, vector, du);
            ypdc = vector[0];
            write_bits_to_file(size, du, fp, 0);

			/* 2*i + 1, 2*j + 1 */		
        	fwd_dct(yuv->y, 8 * (i * 2 + 1), 8 * (j * 2 + 1), vector);
            quantise(vector, 1);
            size = encode_du(1, ypdc, vector, du);
            ypdc = vector[0];
            write_bits_to_file(size, du, fp, 0);

			/* UDU */
        	fwd_dct(yuv->u, 8 * i, 8 * j, vector);
            quantise(vector, 0);
            size = encode_du(0, updc, vector, du);
            updc = vector[0];
            write_bits_to_file(size, du, fp, 0);

			/* VDU */
        	fwd_dct(yuv->v, 8 * i, 8 * j, vector);
            quantise(vector, 0);
            size = encode_du(0, vpdc, vector, du);
            vpdc = vector[0];
            write_bits_to_file(size, du, fp, 0);
		}
    }

	free_yuv12(yuv);

    write_bits_to_file(0, 0, fp, 1);  /* flush */


	p = get_std_segment(EOI, &size, 0, 0);	fwrite(p, size, 1, fp);


	return TRUE;
}





/*--------------------------------------------------------------------+
 |                                                                    |
 | static routines implementations                                    |
 |                                                                    |
 +--------------------------------------------------------------------*/

/*  purpose: get the palette index of a pixel in the image line.
    return: < 0 when error */
static int s_get_palette_index(BYTE* line_data, int bitcount, int col){

    BYTE i, c, offset, mask, index;

    if(bitcount != 1 && bitcount != 2 && bitcount != 4 && bitcount != 8)
        return - 1;

    c = line_data[bitcount * col / 8];

    offset = bitcount * col % 8;

    mask = 0;
    for(i = 1; i <= bitcount; i ++)
        mask |= 1 << (8 - offset - i);

    index = c & mask;
    index = index >> (8 - offset - bitcount);
    return index;
}

/*  purpose: get rgb value of a pixel in the image line.
    return value: 0xeebbggrr. 
        ee: BMP_ERROR_CODE
        bb: blue        
		gg: green
        rr: red
*/
static DWORD s_get_pixel_rgb(unsigned char* pline, int bitcount, unsigned int col){

    int offset;
    unsigned short s;

    offset = bitcount * col / 8;

    switch(bitcount){
        case 16:
            /* A 5-5-5 16-bit image, where the blue mask is 0x001F, 
               the green mask is 0x03E0, and the red mask is 0x7C00 */
            s = *((unsigned short*)(pline + offset));
            return (s & 0x001f) << 16 | (s & 0x03e0) << 3 | (s & 0x7c00) >> 10;
        case 24:
            return pline[offset] << 16 | pline[offset + 1] << 8 | pline[offset + 2];
        case 32:
            return pline[offset + 1] << 16 | pline[offset + 2] << 8 | pline[offset + 3];
        default:
            return BMP_WRONG_BITCOUNT << 24;
    }
}

static char** s_alloc_2d_byte_array(WORD row, WORD col){

    char** x;
    int    i, j;

    if(!(x = (char**)malloc(sizeof(char*) * row)))
        return 0;
    for(i = 0; i < row; i ++){
        if(!(x[i] = (char*)malloc(sizeof(char) * col))){
            for(j = i - 1; j >= 0; j ++)
                free(x[j]);
            free(x);
            return 0;
        }
    }

    return x;
}


static void s_free_2d_byte_array(char** array, WORD row){
    int   i;

    if(!array)
        return;

    for(i = 0; i < row; i ++){
        if(array[i])
            free(array[i]);
    }
    free(array);
}


/* FDCT:
                                  7   7            2*x+1           2*y+1
     F(u,v) = alpha(u)*alpha(v)*sum sum f(x,y)*cos(-----*u*PI)*cos(-----*v*PI)
                                 x=0 y=0            16               16
     u, v = 0, 1, 2, ... , 7

                { 1/sqrt(8)    (u == 0)
     alpha(u) = {
                { 1/2          (u != 0)
*/
/* input:  f[8][8], [-128, 127]
   output: F[8][8]
*/
static void s_do_fdct(int f[8][8], int F[8][8]){

    int    u, v, x, y, z;
    float  pi_16   = 0.1963495;   /* pi / 16      */
    float  sqrt_8i = 0.3535534;   /*  1 / sqrt(8) */
    float  t;
#if (1)  /* a bit faster, but require 4m memory */
    static BYTE  s_first_time = 1;
    /* fixme(bruin, 2002.11.25): optimize the algorithm by reduce the static data size */
    static float s_cc[8][8][8][8][256]; /* [u][v][x][y][f[x][y] + 128], 4MB memory */

    if(s_first_time){
        s_first_time = 0;

        for(u = 0; u < 8; u ++)
        for(v = 0; v < 8; v ++)
        for(x = 0; x < 8; x ++)
        for(y = 0; y < 8; y ++)
        for(z = 0; z < 256; z ++)
            s_cc[u][v][x][y][z] = ((u == 0)? sqrt_8i : .5) * ((v == 0)? sqrt_8i : .5) * cos((2. * x + 1.) * u * pi_16) * cos((2. * y + 1.) * v * pi_16) * (z - 128);
    }

    for(u = 0; u < 8; u ++){
        for(v = 0; v < 8; v ++){
            t = 0.0;
            for(x = 0; x < 8; x ++)
            for(y = 0; y < 8; y ++)
                t += s_cc[u][v][x][y][f[x][y] + 128];
            F[u][v] = (int)t;
        }
    }
#endif
#if (0) /* intuitive but slowest verision */
    for(u = 0; u < 8; u ++){
        for(v = 0; v < 8; v ++){
            t = 0.0;
            for(x = 0; x < 8; x ++)
            for(y = 0; y < 8; y ++)
                t += f[x][y] * cos((2.*x+1)*u*pi_16)*cos((2.*y+1)*v*pi_16);

			if(u == 0)
				t *= sqrt_8i;
			else
				t *= .5;
			if(v == 0)
				t *= sqrt_8i;
			else
				t *= .5;
            F[u][v] = t;
        }
    }
#endif
}

/* purpose: get the nr's category (0..15) according to jpeg standard.
            the category is the number of bits to represent the value

            if the value is positive, the bit pattern is as it is;
            if the value is negative, the bit pattern is as ~(-value) is;
   return: 0 to 15; other values mean error.
*/
static BYTE s_get_category(short value){
        
        int      i;
        unsigned short u = (value < 0) ? - value : value;
        
        for(i = 15; i >= 0; i --)
                if(u & (1 << i))
                        break;
        
        if(i > 0)
                return i + 1;
        if(i == 0)
                return 1;
        else
                return  0;

}

/* purpose: pack "size" nr of LSBs of "code" from byte at (*p),
        start from the offset position(offset of MSB is 0, LSB is 7).
        it's gurantee that there are enough memory space after (*p).

        also updated "p" and "offset" for next operation.
   return: bits packed.
*/
static int s_pack_bits(BYTE** p,       /* <--> */
                       BYTE*  offset,  /* <--> */
                       BYTE   size,
                       short  code){
    int    i;

    if(size > 16)
        return 0;

    for(i = 1; i <= size; i ++){

        if(code & (1 << (size -i)))
            (**p) |= (1 << (7 - (*offset)));   /* set */
        else
            (**p) &= ~(1 << (7 - (*offset)));  /* clear */

        (*offset) ++;

        if((*offset) > 7){
            (*p) ++;
            (*offset) %= 8;
        }
    }

    return size;
}

static int s_is_huffman_bits_valid(BYTE bits[16]){
	int i;
	int c = 0xffff;

	for(i = 0; i < 16; i ++){
		if((c = c - bits[i] * pow(2, (15 - i))) < 0)
			return FALSE;
	}
	return TRUE;
}

void   re_cal_dht(void){

	/* lumin ac */
	cal_dht(s_std_dht + 34, s_std_dht + 50, s_lumin_ac);

	/* chrom ac */
	cal_dht(s_std_dht + 242, s_std_dht + 258, s_chrom_ac);
}
