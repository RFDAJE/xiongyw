    <html>
    <head><title>xml2json</title></head>
    <body>
    <script language='javascript'>


/* xml2json converter based on "http://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html"
 *
 * rewrite(bruin, 2013-11-26)
 * last updated(bruin, 2013-11-28)
 */
var xml2json = (function () {

    /* 
     * convert a xml text string into a normalized, white-removed dom object 
     */
    function _xml2dom(xml) {
        var MIME = "text/xml";
        var dom = null;
        /* recursively remove all pure white TEXT_NODE from the element, in place */
        var remove_white = function (e) {
            var node, next;
            if(!e)
                return;
            e.normalize();
            for(node = e.firstChild; node;) {
                if(node.nodeType == Node.TEXT_NODE) {
                    if(!node.nodeValue.match(/[^ \f\n\r\t\v]/)) {
                        next = node.nextSibling;
                        e.removeChild(node);
                        node = next;
                    } else
                        node = node.nextSibling;
                } else if(node.nodeType == Node.ELEMENT_NODE) {
                    remove_white(node);
                    node = node.nextSibling;
                } else {
                    node = node.nextSibling;
                }
            }
            return e;
        }
        if(!xml) {
            return null;
        }
        if(window.DOMParser) {
            dom = (new DOMParser()).parseFromString(xml, MIME);
        } else if(window.ActiveXObject) {
            dom = new ActiveXObject('Microsoft.XMLDOM');
            dom.async = false;
            if(!dom.loadXML(xml)) {
                window.alert(dom.parseError.reason + dom.parseError.srcText);
                dom = null;
            }
        } else {
            window.alert("Error: your browser does not support parsing XML to DOM!");
        }
        return remove_white(dom);
    }

    /*
     * convert the dom into a simpler js object
     */
    function _dom2obj(dom) {
        var SHARP_TEXT = "#text";
        var SHARP_CDATA = "#cdata";
        var o = {};
        var i, n;

        var escape = function (txt) {
            return txt.replace(/[\\]/g, "\\\\")
                .replace(/[\"]/g, '\\"')
                .replace(/[\n]/g, '\\n')
                .replace(/[\r]/g, '\\r');
        }

        var _as_xml = function (n) {
            var i, c;
            var s = "";
            if(n.nodeType == Node.ELEMENT_NODE) {
                s += "<" + n.nodeName;
                for(i = 0; i < n.attributes.length; i++) {
                    s += " " + n.attributes[i].nodeName + "=\"" + (n.attributes[i].nodeValue || "").toString() + "\"";
                }
                if(n.firstChild) {
                    s += ">";
                    for(c = n.firstChild; c; c = c.nextSibling) {
                        s += _as_xml(c);
                    }
                    s += "</" + n.nodeName + ">";
                } else {
                    s += "/>";
                }
            } else if(n.nodeType == Node.TEXT_NODE) {
                s += n.nodeValue;
            } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
                s += "<![CDATA[" + n.nodeValue + "]]>";
            }
            return s;
        }

        var _inner_xml = function (node) {
            if("innerHTML" in node)
                return node.innerHTML;
            var s = "";
            for(var c = node.firstChild; c; c = c.nextSibling) {
                s += _as_xml(c);
            }
            return s;
        }

        if(!dom)
            return null;
        if(dom.nodeType == Node.DOCUMENT_NODE) {
            var O = {};
            O[dom.documentElement.nodeName] = _dom2obj(dom.documentElement);
            return O;
        }
        if(dom.nodeType == Node.ELEMENT_NODE) {
            if(!dom.attributes.length && !dom.firstChild) {
                /* 
                 * this is why to return null instead of undefined here:
                 * ---------------------------------------------------------
                 *  JSON.stringify(undefined)        => undefined
                 *  JSON.stringify({name:undefined}) => '{}'
                 * ---------------------------------------------------------
                 *  JSON.stringify(null)             => 'null';
                 *  JSON.stringify({name:null})      => '{"name":null}'
                 * ---------------------------------------------------------
                 */
                return null;
            }
            // converts attributes[] into properties
            if(dom.attributes.length) {
                for(i = 0; i < dom.attributes.length; i++) {
                    o["@" + dom.attributes[i].nodeName] = (dom.attributes[i].nodeValue || "").toString();
                }
            }
            if(dom.firstChild) { // element has child nodes ..
                var textChild = 0;
                var cdataChild = 0;
                var hasElementChild = false;
                for(n = dom.firstChild; n; n = n.nextSibling) {
                    if(n.nodeType == Node.ELEMENT_NODE) {
                        hasElementChild = true;
                    } else if(n.nodeType == Node.TEXT_NODE && n.nodeValue.match(/[^ \f\n\r\t\v]/)) {
                        textChild++; // non-whitespace text
                    } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
                        cdataChild++; // cdata section node
                    }
                }
                if(hasElementChild) {
                    if(textChild < 2 && cdataChild < 2) { // structured element with a single text or/and cdata node
                        // remove_white(dom); // why remove white again?
                        for(n = dom.firstChild; n; n = n.nextSibling) {
                            if(n.nodeType == Node.TEXT_NODE) {
                                o[SHARP_TEXT] = escape(n.nodeValue);
                            } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
                                o[SHARP_CDATA] = escape(n.nodeValue);
                            } else if(o[n.nodeName]) { // multiple occurence of element ..
                                if(o[n.nodeName] instanceof Array) {
                                    o[n.nodeName][o[n.nodeName].length] = _dom2obj(n);
                                } else {
                                    o[n.nodeName] = [o[n.nodeName], _dom2obj(n)];
                                }
                            } else { // first occurence of element..
                                o[n.nodeName] = _dom2obj(n);
                            }
                        }
                    } else { // mixed content
                        if(!dom.attributes.length)
                            o = escape(_inner_xml(dom));
                        else
                            o[SHARP_TEXT] = escape(_inner_xml(dom));
                    }
                } /* hasElementChild */
                else if(textChild) { // pure text
                    if(!dom.attributes.length)
                        o = escape(_inner_xml(dom));
                    else
                        o[SHARP_TEXT] = escape(_inner_xml(dom));
                } else if(cdataChild) { // cdata
                    if(cdataChild > 1)
                        o = escape(_inner_xml(dom));
                    else {
                        for(n = dom.firstChild; n; n = n.nextSibling)
                            o[SHARP_CDATA] = escape(n.nodeValue);
                    }
                }
            }
        } else {
            alert("unhandled node type: " + dom.nodeType);
        }
        return o;
    }
    return function (xml) {
        var dom = _xml2dom(xml);
        var obj = _dom2obj(dom);
        return JSON.stringify(obj);
    }
}());

/* sanity tests */
(function () {
    var xmls = [undefined,
        null,
        "<e/>",
        "<e>text</e>",
        "<e name='value'/>",
        "<e name='value'>text</e>",
        "<e><a>text</a><b>text2</b></e>",
        "<e><a>text</a><a>text2</a></e>",
        "<e>text<a>text2</a></e>",
        "<?xml version='1.0'?><e><!--comments-->text</e>"
    ];
    xmls.map(function (xml) {
        console.log(xml);
        console.log(xml2json(xml));
        console.log('--------------');
    }).join("");
}());


</script>
    </body>
    </html>
