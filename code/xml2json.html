    <html><head><title>xml2tree</title><style>
    BODY {background-color: white}
TD   {font-size: 9pt; 
      text-decoration: none;
      white-space:nowrap;
     }
</style></head><body><script language='javascript'>


/* xml2json converter based on "http://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html"
 *
 * rewrite(bruin, 2013-11-26)
 * last updated(bruin, 2013-11-28)
 */

/* 
 * utilities 
 */

/* save typing */
function $(id){
    return window.document.getElementById(id);
}

/* is o an array? */
function arrayp(o){
    return typeof o === 'object' && Object.prototype.toString.call(o) === '[object Array]';
}

/* get unique id, also has a method for reset: uid(), uid.reset() */
var uid = (function(){
    var _id = 0;
    var fn = function(){
        return _id ++;
    }
    fn.reset = function(){ _id = 0};
    return fn;
}());

/* some constants */
var NON_SPACE = /[^ \f\n\r\t\v]/;
var SHARP_TEXT = "#text";
var SHARP_CDATA = "#cdata";

/* 
 * convert a xml text string into a normalized, white-removed dom object 
 */
function xml2dom(xml) {
    var MIME = "text/xml";
    var dom = null;
    /* recursively remove all pure white TEXT_NODE from the element, in place */
    var remove_white = function (e) {
        var node, next;
        if(!e)
            return;
        e.normalize();
        for(node = e.firstChild; node;) {
            if(node.nodeType == Node.TEXT_NODE) {
                if(!node.nodeValue.match(NON_SPACE)) {
                    next = node.nextSibling;
                    e.removeChild(node);
                    node = next;
                } else
                    node = node.nextSibling;
            } else if(node.nodeType == Node.ELEMENT_NODE) {
                remove_white(node);
                node = node.nextSibling;
            } else {
                node = node.nextSibling;
            }
        }
        return e;
    }

    if(!xml) {
        return null;
    }
    if(window.DOMParser) {
        dom = (new DOMParser()).parseFromString(xml, MIME);
    } else if(window.ActiveXObject) {
        dom = new ActiveXObject('Microsoft.XMLDOM');
        dom.async = false;
        if(!dom.loadXML(xml)) {
            window.alert(dom.parseError.reason + dom.parseError.srcText);
            dom = null;
        }
    } else {
        window.alert("Error: your browser does not support parsing XML to DOM!");
    }
    return remove_white(dom);
}


/*
 * convert the dom into a simpler js object
 */
function dom2obj(dom) {
    var o = {};
    var i, n;

    var escape = function (txt) {
        return txt.replace(/[\\]/g, "\\\\")
            .replace(/[\"]/g, '\\"')
            .replace(/[\n]/g, '\\n')
            .replace(/[\r]/g, '\\r');
    }

    var _as_xml = function (n) {
        var i, c;
        var s = "";
        if(n.nodeType == Node.ELEMENT_NODE) {
            s += "<" + n.nodeName;
            for(i = 0; i < n.attributes.length; i++) {
                s += " " + n.attributes[i].nodeName + "=\"" + (n.attributes[i].nodeValue || "").toString() + "\"";
            }
            if(n.firstChild) {
                s += ">";
                for(c = n.firstChild; c; c = c.nextSibling) {
                    s += _as_xml(c);
                }
                s += "</" + n.nodeName + ">";
            } else {
                s += "/>";
            }
        } else if(n.nodeType == Node.TEXT_NODE) {
            s += n.nodeValue;
        } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
            s += "<![CDATA[" + n.nodeValue + "]]>";
        }
        return s;
    }

    var _inner_xml = function (node) {
        if("innerHTML" in node)
            return node.innerHTML;
        var s = "";
        for(var c = node.firstChild; c; c = c.nextSibling) {
            s += _as_xml(c);
        }
        return s;
    }

    if(!dom)
        return null;
    if(dom.nodeType == Node.DOCUMENT_NODE) {
        var O = {};
        O[dom.documentElement.nodeName] = dom2obj(dom.documentElement);
        return O;
    }
    if(dom.nodeType == Node.ELEMENT_NODE) {
        if(!dom.attributes.length && !dom.firstChild) {
            return null;
        }
        // converts attributes[] into properties
        if(dom.attributes.length) {
            for(i = 0; i < dom.attributes.length; i++) {
                o["@" + dom.attributes[i].nodeName] = (dom.attributes[i].nodeValue || "").toString();
            }
        }
        if(dom.firstChild) { // element has child nodes ..
            var textChild = 0;
            var cdataChild = 0;
            var hasElementChild = false;
            for(n = dom.firstChild; n; n = n.nextSibling) {
                if(n.nodeType == Node.ELEMENT_NODE) {
                    hasElementChild = true;
                } else if(n.nodeType == Node.TEXT_NODE && n.nodeValue.match(NON_SPACE)) {
                    textChild++; // non-whitespace text
                } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
                    cdataChild++; // cdata section node
                }
            }
            if(hasElementChild) {
                if(textChild < 2 && cdataChild < 2) { // structured element with a single text or/and cdata node
                    // remove_white(dom); // why remove white again?
                    for(n = dom.firstChild; n; n = n.nextSibling) {
                        if(n.nodeType == Node.TEXT_NODE) {
                            o[SHARP_TEXT] = escape(n.nodeValue);
                        } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
                            o[SHARP_CDATA] = escape(n.nodeValue);
                        } else if(o[n.nodeName]) { // multiple occurence of element ..
                            if(o[n.nodeName] instanceof Array) {
                                o[n.nodeName][o[n.nodeName].length] = dom2obj(n);
                            } else {
                                o[n.nodeName] = [o[n.nodeName], dom2obj(n)];
                            }
                        } else { // first occurence of element..
                            o[n.nodeName] = dom2obj(n);
                        }
                    }
                } else { // mixed content
                    if(!dom.attributes.length)
                        o = escape(_inner_xml(dom));
                    else
                        o[SHARP_TEXT] = escape(_inner_xml(dom));
                }
            } /* hasElementChild */
            else if(textChild) { // pure text
                if(!dom.attributes.length)
                    o = escape(_inner_xml(dom));
                else
                    o[SHARP_TEXT] = escape(_inner_xml(dom));
            } else if(cdataChild) { // cdata
                if(cdataChild > 1)
                    o = escape(_inner_xml(dom));
                else {
                    for(n = dom.firstChild; n; n = n.nextSibling)
                        o[SHARP_CDATA] = escape(n.nodeValue);
                }
            }
        }
    } else {
        window.alert("unhandled node type: " + dom.nodeType);
    }
    return o;
}

/* xml to obj */
function xml2obj(xml){
    var dom = xml2dom(xml);
    return dom2obj(dom);
}

/* xml to json string */
function xml2json(xml){
    var obj = xml2obj(xml);
    return JSON.stringify(obj, null, 4);
}


/* sanity tests */
(function () {
    var xmls = [undefined,
                null,
                "<e/>",
                "<e>text</e>",
                "<e name='value'/>",
                "<e name='value'>text</e>",
                "<e><a>text</a><b>text2</b></e>",
                "<e><a>text</a><a>text2</a></e>",
                "<e>text<a>text2</a></e>",
                "<?xml version='1.0'?><e><!--comments-->text</e>"
               ];
    xmls.map(function (xml) {
        console.log(xml);
        console.log(xml2json(xml));
        console.log('--------------');
    }).join("");
}());


/**
 * created(bruin, 2003-02-01): first creation, support MSIE only
 * updated(bruin, 2004-07-08): support mozilla, cleanup code, and add code comments
 * updated(bruin, 2013-11-29): some cosmetic changes 
 *
 * notes:
 *
 Names for other types of objects depend on the id, in the following rule:

 "N" + id: the node object (eg, N128 is the node object whose id is "128"
 "D" + id: the DIV object of the node (yes, each node has a corresponding DIV)
 "J" + id: the node's joint icon image object in html document. 
 the joint icon is to represent the status of the 
 node in browser. there are 6 possible status for a node: 
 
 |          |         |         |         |        |
 +---+      +---+       |       +---+     +---+      |
 | + |--    | - |--     +----   | + |--   | - |--    +----
 +---+      +---+       |       +---+     +---+
 |          |         |         
 
 (a)        (b)       (c)       (d)       (e)       (f)
 
 (a) a closed node having kid(s)  
 (b) an opened/collapsed node having kid(s)
 (c) a leaf node having no kids
 (d) a last closed node having kid(s)
 (e) a last opened/collapsed node having kid(s)
 (f) a last leaf node having no kids
 
 Clicking on nodes cause the node to open/close, so the joint icon should also change accordingly.
*/   


/* 
 * constructor of node object: MyNode(id, desc, type, href)
 *
 * @param {string) id: an unique id of the node object to be created. 
 * @param {string} desc: text description of the node
 * @param {int} type: node type, optional
 * @param {string} href: link page, optional
 */
function MyNode(id, desc, type, href){

    /* get node name */ 
    function _node_name(){
        return "N" + this.id;
    }

    /* get the id of the corresponding DIV */
    function _div_id(){
        return "D" + this.id;
    }

    /* get the id of the corresponding img for joint */
    function _joint_id(){
        return "J" + this.id;
    }

    function _add_kid(kid){
        this.kids[this.kids.length] = kid;
        kid.dad = this;
        return kid;
    }

    /**
     * recursively set "left_code" and "lastp" properties
     * of each node in the tree. called by the root of the tree
     * after the tree structure been built
     *
     * @param {boolean} lastp: "false" if it's not the last child of its parent; otherwise "true";
     * @param {array} left_code: an array of 0/1 representing the left side icons
     * @return: nothing
     */
    function _set_left_n_last(lastp, left_code){
        var i;
        
        this.lastp = lastp;
        this.left_code = left_code.slice(0); // copy the array
        
        if(lastp){
            left_code.push(0);   
        }
        else{
            left_code.push(1);   
        }
        
        for(i = 0; i < this.kids.length; i ++){
    	    if(i == this.kids.length - 1){
                this.kids[i].set_left_n_last(true, left_code.slice(0));
            }
            else{
                this.kids[i].set_left_n_last(false, left_code.slice(0));
            }
        }
    }

    /* Generate html elements of the node. for each node, its corresponding html elements 
       could be divided into 2 parts: a one row TABLE, followed by a DIV:

       Node in html => TABLE + DIV

       The TABLE contains the following variable number of TDs (columns):
       1. left side icons: a series of blank and/or vertline icons each is a TD; none for root nodes;
       2. joint icon: one of 6 icons as described above. one TD for each node;
       3. type icon: icon representing the type of the node. one TD for each node;
       4. description text: plain text or anchored text. one TD for each node;

       The DIV element is the container of child nodes' html elements, which in turn contains a 
       list of TABLE+DIV bundle, one for each child node. DIVs can be controlled to show or hide. 
       Showing a node's DIV opens/collapses the node, while hiding the node's DIV closes the node.
    */
    function _render(){ 

        /* fixme: move the inline table styles into CSS */

        var docW = "";

        docW += "<table border=0 cellspacing=0 cellpadding=0><tr>";

        // 1. left side icons
        docW += this.get_left_icons();

        // 2. joint icon 
        if(this.dad){    // do not show joint icon for top level node(s)
            if(this.kids.length > 0)
                docW += "<td nowrap><a href='javascript: N" + this.id + ".onclick()'><img name='J" + this.id + "' src='" + this.get_jicon_src() + "' align=absbottom width=16 height=16 border=0></a></td>";
            else
                docW += "<td nowrap><img name='J" + this.id + "' src='" + this.get_jicon_src() + "' align=absbottom width=16 height=16 border=0></td>";
        }

        // 3. type icon
        docW += this.get_type_icon();

        // 4. desc text
        docW += "<td valign=middle nowrap width=100%>&nbsp;";
        if(this.type == 5) // section 
            docW += "<a href='./sections/S" + this.id + ".html' target='hex_frame'>";
        if(this.type == 13) // packet
            docW += "<a href='./packets/P" + this.id + ".html' target='hex_frame'>";
        docW += this.desc; 
        if(this.type == 5 || this.type == 13)
            docW += "</a>";
        docW += "</td></tr></table>";

	// 5. div object
        docW += "<div id='D" + this.id + "' style='display: none'></div>";
        
        return docW;
    } 

    /* toggle betw. open & close of the node
     */
    function _onclick(){
        var div = $(this.div_id());
        if(!div)  return;
        if(!div.innerHTML){
    	    var kids = [];
    	    for(var i = 0; i < this.kids.length; i ++){
    		kids[i] = this.kids[i].render();
	    }
	    div.innerHTML = kids.join('');
        }

        // toggle visibility of its kids
        if(this.openp == false){
    	    div.style.display = "block";
    	    this.openp = true;
        }
        else{
            div.style.display = "none";
            this.openp = false;
        }
        
        // toggle the joint icon
        // note: $() does not work on mozilla, while document.images[] works
        //       on both mozilla and ie.
        //var jicon = $("J" + this.id);
        var jicon = document.images[this.joint_id()];
        if(jicon){
            jicon.src = this.get_jicon_src();    
        }
    }

    /* get left side icons of a node (componsed by blank and/or vertline) */ 
    function _get_left_icons(){
        var left_array = [];
        /* fixme: use map/join instead */
        for(var i = 1; i < this.left_code.length; i ++){
            if(this.left_code[i] == 1)
                left_array[i] = "<td nowrap><img src='./images/vertline.gif' align=absbottom width=16 height=16 border=0></td>";
            else
                left_array[i] = "<td nowrap><img src='./images/blank.gif' align=absbottom width=16 height=16 border=0></td>";
        }
        return left_array.join('');
    }

    /* get joint icon src */
    function _get_jicon_src(){
	
        if(this.dad == null){
            return "./images/blank.gif";
        }
        else{
            if(this.lastp){
                if(this.kids.length > 0){
                    if(this.openp)
                        return "./images/mlastnode.gif";
                    else
                        return "./images/plastnode.gif";
                }
                else{
                    return "./images/lastnode.gif";
                }
            }
            else{ // not last node 
                if(this.kids.length > 0){
                    if(this.openp)
                        return "./images/mnode.gif";
                    else
                        return "./images/pnode.gif";
                }
                else{
                    return "./images/node.gif";
                }
            }
        }
    }

    /* get the type icon of the node, according to its type */
    function _get_type_icon(){

        var img = "<td nowrap><img src='"; 
        
        switch(this.type){
        case  1:    img += "./images/01.gif"; break;
        case  2:    img += "./images/02.gif"; break;
        case  3:    img += "./images/03.gif"; break;
        case  4:    img += "./images/04.gif"; break;
        case  5:    img += "./images/05.gif"; break;
        case  6:    img += "./images/06.gif"; break;
        case  7:    img += "./images/07.gif"; break;
        case  8:    img += "./images/08.gif"; break;
        case  9:    img += "./images/09.gif"; break;
        case 10:    img += "./images/10.gif"; break;
        case 11:    img += "./images/11.gif"; break;
        case 12:    img += "./images/12.gif"; break;
        case 13:    img += "./images/13.gif"; break;
        default:    img += "./images/00.gif"; break;
        }
        img += "' align=absbottom width=16 height=16 border=0></td>";
        return img;
    }

    // tree's data structure
    this.dad = null;
    this.kids = [];

    // static properties assigned
    this.id = id;
    this.desc = desc;
    this.type = type;
    this.href = href;

    // properties determined during tree_init()
    this.left_code = [];   // array element: 0 means space, 1 means vertical bar
    this.lastp = false;    // is the last kid of its parent?
    
    // dynamic properties
    this.openp = false;  // is collapsed or not? 
    
    // methods
    this.add_kid         = _add_kid;
    this.set_left_n_last = _set_left_n_last;
    this.node_name       = _node_name;
    this.div_id          = _div_id;
    this.joint_id        = _joint_id;

    this.get_left_icons  = _get_left_icons;  
    this.get_jicon_src   = _get_jicon_src;   
    this.get_type_icon   = _get_type_icon;   

    this.render          = _render;          
    this.onclick         = _onclick;
}


/**
 * build a tree from the object: 
 * - creating(new) all nodes in global space
 * - attaching nodes to form a tree
 * - initialize misc info in all nodes
 *
 * @param {object} o: the object converted from a xml
 * @return {object}: the root node
 */
function build_tree(o){

    var root = null;

    /*
     * @param {string} name: property name
     * @parm {object or string} val: property value
     * @return: the tree of nodes
     */
    var _build_tree = function(name, val){

        var desc, node;

        if(typeof val === 'string'){
            desc = name + ": " + val;
        }
        else if(arrayp(val)){
            desc = name + ": " + val.join(",");
        }
        else{
            desc = name;
        }

        node = new MyNode(uid(), desc, "", "");
        window[node.node_name()] = node;
        
        if(typeof val === 'object' && !arrayp(val)){ // it has kids
            for(var p in val){
                kid = _build_tree(p, val[p]);
                node.add_kid(kid);
            }
        }
        return node;
    }

    if(o && typeof o === 'object' && !arrayp(o)){
        for(var p in o){
            root = _build_tree(p, o[p]);
            /* we assume the tree has only 1 property at top level */
            break; 
        }
    }

    root.set_left_n_last(true, []);
    return root;
}

function tree_init(root){
    root.set_left_n_last(true, "");
    
    document.write(root.render());
    root.onclick();    
}

var test_tree = "<network><siconfig><regionID>100</regionID><networkClass>mynetwork</networkClass></siconfig><schemas>this is about table schemas</schemas></network>";
console.log(xml2json(test_tree));

var root = build_tree(xml2obj(test_tree));
document.write(root.render());
root.onclick();

</script></body></html>
