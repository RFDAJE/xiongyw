    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <style type="text/css">
    body {
        margin: 0px;
        padding: 0px;
    }
</style>
    <script type="text/javascript" src="jsonpath.js"></script>
    <script type="text/javascript" src="jh1986.js"></script>
    <script type="text/javascript" src="jp2canvas.js"></script>
    <script type="text/javascript">


/* 
 * todos:
 * 
 * + support cyclic guide
 * + output coordinates in normal y direction (up): canvas y is down, asy y is up;
 * - add button to load picture from file system or url
 * - add button/check_box to display/hide the picture, if loaded
 * - add selection of the current point/path connection types
 * - make it possible to make comments for a path
 * - make it possible to specify draw/fill color for a path
 * + hilights nodes on the paths
 * - snap to nodes on the paths
 * - make it possible to manually adjust point position, at any time (by selecting the path first)
 * + make it possible to draw cubic curves in canvas to reflect what's going to be drawn in asy
 * - make it possible to export SVG format data
 * + detect when mouse move out of canvas (and update the draw accordingly)
 * + add keyboard event (up/down/left/right) support: http://dbp-consulting.com/tutorials/canvas/CanvasKeyEvents.html
 * + add connector support: "--", "&&"
 * - read: http://www.williammalone.com/articles/create-html5-canvas-javascript-drawing-app/
 */


// constants
var CANVAS_WIDTH = 1000;
var CANVAS_HEIGHT = 1000;
var GRID_SIZE = 8;

var LEFT_KEY = 37;
var UP_KEY = 38;
var RIGHT_KEY = 39;
var DOWN_KEY = 40;
var ENTER_KEY = 13; 
var SHIFT_KEY = 16;

var GRID_LINE_WIDTH = 0.2;
var GRID_STROKE_STYLE = "grey";

var g_paths = []; // an array of path
var g_cur_path = jp.newPath();  // the current path
var g_cur_conn = jp.FREE_CONN; // the current conn type
var g_cur_path_started = false;

var img = new Image();
var c, ctx; // canvas and its context
var start_btn, stop_btn, cycle_btn, undo_btn; // buttons

//img.src = "http://upload.wikimedia.org/wikipedia/en/9/9f/Open_tv.png";
//img.src = "test.png";


// get the current mouse position from the Canvas
// and return a node representing it
//
// input: ctx: canvas context
//        e: mouse event
//        conn: connection type
// output: a node object
function getNodeFromCanvas(ctx, e, conn) {
    var c = ctx.canvas; 
    var n = jp.newNode();

    var bb = c.getBoundingClientRect(); 

    // Translate and scale mouse event coordinates to canvas coordinates
    n.x = (e.clientX-bb.left)*(c.width/bb.width);
    n.y = - (e.clientY-bb.top)*(c.height/bb.height); // convert to normal coordinates
    n.conn = conn;

    return n;
}

// canvas hooks
function onClick(e) {
    if (g_cur_path_started === true) {
        var node = getNodeFromCanvas(ctx, e, g_cur_conn);
        //console.log(cur);
        // preventing the two _adjacent_ nodes having the same position
        var n = g_cur_path.nodes.length;
        if (n > 1 && 
            g_cur_path.nodes[n-1].x === node.x &&
            g_cur_path.nodes[n-1].y === node.y) {
            console.log("you click too quick!");
            return;
        }
        g_cur_path.nodes.push(node);
        //displayCurrentPath();
    }
}

function onDoubleClick(e) {
    console.log("onDoubleClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onRightClick(e) {
    console.log("onRightClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

//
// the fact: canvas fires onmousemove events even the mouse position is not moved.
// the impact: when click event happens, the current position is added into the path, but
//   a mouse move event with the same position will be emitted. if we want to draw the
//   current path, the last two points are identical...then the Bezier curve will not be draw,
//   probably because the linear equations are not properly formed...
// the remedy: omit mouse move event when the position is not changed. use closure the keep the 
//   previous positions;
var onMouseMove = (function() {
    // previous e.clientX and e.clientY
    var pre_x = -1;
    var pre_y = -1;
    return function(e){
        if(pre_x === e.clientX && pre_y === e.clientY) {
            // console.log("move without position change!");
            return;
        }
        pre_x = e.clientX;
        pre_y = e.clientY;
        //console.log("onMouseMove: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);

        if (g_cur_path_started != true) {
            return;
        }

        g_cur_path.nodes.push(getNodeFromCanvas(ctx, e, null));
        redrawCanvas();
        g_cur_path.nodes.pop(); // remove it immediately, as the node is a temp one
    }
}());

function onMouseWheel(e) {
    console.log("onMouseWheel: dx=" + e.deltaX + ", dy=" + e.deltaY);
}

function onMouseLeave(e) {
    //console.log("onMouseLeave: e=" + e);
    redrawCanvas();
}

// button hooks
function startCurrentPath() {
    console.log("startCurrentPath: ");
    var n = g_cur_path.nodes.length;
    if (n > 0) {
        // assumes that the current path ends, so we save it
        // before doing so, making sure the path is open.
        // note that a closed path is always triggered by button click.
        g_cur_path.nodes[n-1].conn = jp.OPEN_CONN;
        g_paths.push(g_cur_path);
    }
 
    // re-init the guide
    g_cur_path = jp.newPath();
//    displayCurrentPath();
    g_cur_path_started = true;
}

function endCurrentPathAsOpened() {
    var n = g_cur_path.nodes.length;
    if (n > 0) {
        g_cur_path.nodes[n-1].conn = jp.OPEN_CONN;
        g_paths.push(g_cur_path);
    }

    g_cur_path = jp.newPath();
    g_cur_path_started = false;

    outputResult();
    redrawCanvas();
}

//
// there are two ways to close a path
// - freeClosed: change the last node conn is ".."
// - lineClosed: append the 1st node (with conn "--") into the path

function endCurrentPathAsFreeClosed() {
    var n = g_cur_path.nodes.length;
    if (n <= 1) {
        console.log("too few nodes");
        return;
    }

    g_cur_path.nodes[n-1].conn = jp.FREE_CONN;
    g_paths.push(g_cur_path);

    g_cur_path = jp.newPath();
    g_cur_path_started = false;

    outputResult();
    redrawCanvas();
}

function endCurrentPathAsLineClosed() {
    var n = g_cur_path.nodes.length;
    if (n <= 1) {
        console.log("too few nodes");
        return;
    }

    var z0 = jp.jsonClone(g_cur_path.nodes[0]);
    z0.conn = jp.LINE_CONN;
    g_cur_path.nodes.push(z0);
    g_paths.push(g_cur_path);

    g_cur_path = jp.newPath();
    g_cur_path_started = false;

    outputResult();
    redrawCanvas();
}

/*
 * discard the last point of the current guide
 */
function undoPoint() {
    if (g_cur_path.nodes.length > 0) {
        g_cur_path.nodes.pop();
    }

    //displayCurrentPath();
    redrawCanvas();
}

// append the last node again
function addDegradedSegment() {
    var n = g_cur_path.nodes.length;
    if (g_cur_path_started && n > 0) {
        var last = g_cur_path.nodes[n-1];
        var dup = jp.jsonClone(last);
        last.conn = jp.LINE_CONN;
        g_cur_path.nodes.push(dup);
    }
}

function onStraightConn () {
    g_cur_conn = jp.LINE_CONN;
    if (g_cur_path_started && g_cur_path.nodes.length > 0) {
        g_cur_path.nodes[g_cur_path.nodes.length-1].conn = g_cur_conn;
    }

    document.body.style.cursor = "crosshair";
}

function onFreeConn () {
    g_cur_conn = jp.FREE_CONN;
    if (g_cur_path_started && g_cur_path.nodes.length > 0) {
        g_cur_path.nodes[g_cur_path.nodes.length-1].conn = g_cur_conn;
    }
    document.body.style.cursor = "auto";
}

function toggleCurrentConn () {
    if (g_cur_conn === jp.LINE_CONN) {
        onFreeConn();
    } else {
        onStraightConn();
    }
}


function outputResult() {
    
    var asy = "guide[] gg = {" + g_paths.map(function(x){return jp.toAsy(x);}).join(",\r") + "};";
    var ta = document.getElementById("g_paths"); // textarea
    ta.value = asy;
    console.log(asy+"draw(gg);");
}


function drawImageAndGrid() {
    /*
     * draw the image, scale within the canvas size, as much as possible, but also keep the aspect ratio
     */
    var img_ar = img.width / img.height;  // image aspect ratio
    var can_ar = CANVAS_WIDTH / CANVAS_HEIGHT; // canvas aspect ratio

    if(can_ar >= img_ar) {
        ctx.drawImage(img, 0, 0, c.height * img_ar, c.height);
    } else {
        ctx.drawImage(img, 0, 0, c.width, c.width / img_ar);
    }
    

    // draw the grid
    ctx.lineWidth = GRID_LINE_WIDTH;
    ctx.strokeStyle = GRID_STROKE_STYLE;

    // horizontal lines
    for (var i = 0;i <= c.width / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(0, i * GRID_SIZE);
	ctx.lineTo(c.width, i * GRID_SIZE);
	ctx.stroke();
    }
    
    // vertical lines
    for (var i = 0; i <= c.height / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(i * GRID_SIZE, 0);
	ctx.lineTo(i * GRID_SIZE, c.height);
	ctx.stroke();
    }
}


function redrawCanvas (){
//    console.log("redrawCanvas...");

    ctx.clearRect(0, 0, c.width, c.height);
    drawImageAndGrid();
    
    // draw the paths
    g_paths.map(function(x){return j2c.drawOnePath(x);});
    j2c.drawOnePath(g_cur_path);

    // dot the paths
    g_paths.map(function(x){return j2c.dotOnePath(x);});
    j2c.dotOnePath(g_cur_path);
}

function handleFocus(e) {
    if(e.type == 'mouseover'){
        //console.log("mouseover");
        c.focus();
        return false;
    }else if(e.type == 'mouseout'){
        c.blur();
        return false;
    }
    return true;
};

function handleKeyDown(e) {
    console.log("key down:" + e.keyCode);

    if (!g_cur_path_started) {
        return true;
    }

    var key_id = e.keyCode || e.which;

    // todo: simulate mouse move event, pixel by pixel
    if (key_id === LEFT_KEY) {
    } else if (key_id === RIGHT_KEY) {
    } else if (key_id === UP_KEY) {
    } else if (key_id === DOWN_KEY) {
    } else if (key_id === ENTER_KEY) {
        // todo: simulate the click event
    } else if (key_id === SHIFT_KEY) { 
        toggleCurrentConn();
    } else {
        return true;
    }

    return false;
};


function onLoad() {

    c = document.getElementById("myCanvas");

    c.width = CANVAS_WIDTH;
    c.height = CANVAS_HEIGHT;

    // event hooks
    c.onclick = onClick;
    c.ondblclick = onDoubleClick;
    c.oncontextmenu = onRightClick;
    c.onmousemove = onMouseMove;  // note that this is a closure
    c.onmousewheel = onMouseWheel;
    c.onmouseleave = onMouseLeave;
    c.addEventListener('mouseover',handleFocus,false);
    c.addEventListener('mouseout',handleFocus,false);
    c.addEventListener('keydown',handleKeyDown,false);



    ctx = c.getContext('2d');
    j2c.setContext(ctx);

    drawImageAndGrid();

    // set button callbacks
    start_btn = document.getElementById("startCurrentPath");
    stop_btn = document.getElementById("endCurrentPathAsOpened");
    undo_btn = document.getElementById("undoPoint");
    degraded_btn = document.getElementById("addDegradedSegment");
    cycle_btn = document.getElementById("endCurrentPathAsFreeClosed");
    buildcycle_btn = document.getElementById("endCurrentPathAsLineClosed");

    freeconn_btn = document.getElementById("connFree");
    straight_btn = document.getElementById("connStraight");

    start_btn.onclick = startCurrentPath;
    stop_btn.onclick = endCurrentPathAsOpened;
    undo_btn.onclick = undoPoint;
    degraded_btn.onclick = addDegradedSegment;
    cycle_btn.onclick = endCurrentPathAsFreeClosed;
    buildcycle_btn.onclick = endCurrentPathAsLineClosed;

//    free_btn.onclick = onFreeConn;
    freeconn_btn.onclick = onFreeConn;
    straight_btn.onclick = onStraightConn;
}


window.onload = onLoad;
</script>
    </head>
    <body>
    <div id="div1" style="float:left;">
    <canvas id="myCanvas" width="100" height="512" tabindex="0" style="border:2px solid green;"></canvas>
    </div>

    <div id="div2" style="float:left;">
    <form>
    <input id="startCurrentPath" type="button" value="Start Path"/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <input id="undoPoint" type="button" value="Undo Point"/>
    <input id="addDegradedSegment" type="button" value="z--z"/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Select connector:
    <input id="connFree" type="button" value=".."/>
    <input id="connStraight" type="button" value="--"/> (tip: SHIFT key to toggle)
    <br>
    <input id="endCurrentPathAsOpened" type="button" value="End Path (open)"/>
    <br>
    <input id="endCurrentPathAsFreeClosed" type="button" value="End Path (free closed)"/>
    <br>
    <input id="endCurrentPathAsLineClosed" type="button" value="End Path (line closed)"/>
    </form>
    <br>
    <!--textarea id="g_cur_path" rows="50" cols="50"></textarea>-->
    <textarea id="g_paths" rows="40" cols="100"></textarea>
    </div>
    </body>
    </html>
