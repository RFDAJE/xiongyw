    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <style type="text/css">
    body {
        margin: 0px;
        padding: 0px;
    }
    #statusbar {
	    position: fixed; 
	    bottom: 0px; 
	    left: 0px;
	    background: lightgray;
	    width: 2000px;
	    height: 22px;
    }
    input[type=text] {
    	border: inset;
    	background: lightgray;
    }
</style>
	<script src="jquery-2.1.1.js"></script>
    <script type="text/javascript" src="jsonpath.js"></script>
    <script type="text/javascript" src="jh1986.js"></script>
    <script type="text/javascript" src="jp2canvas.js"></script>
    <script type="text/javascript">


/* 
 * todos:
 * 
 * + support cyclic guide
 * + output coordinates in normal y direction (up): canvas y is down, asy y is up;
 * - add button to load picture from file system or url
 * - add button/check_box to display/hide the picture, if loaded
 * - add selection of the current point/path connection types
 * - make it possible to make comments for a path
 * - make it possible to specify draw/fill color for a path
 * + hilights nodes on the paths
 * - snap to nodes on the paths
 * - make it possible to manually adjust point position, at any time (by selecting the path first)
 * + make it possible to draw cubic curves in canvas to reflect what's going to be drawn in asy
 * - make it possible to export SVG format data
 * + detect when mouse move out of canvas (and update the draw accordingly)
 * + add keyboard event (up/down/left/right) support: http://dbp-consulting.com/tutorials/canvas/CanvasKeyEvents.html
 * + add connector support: "--", "&&"
 * - read: http://www.williammalone.com/articles/create-html5-canvas-javascript-drawing-app/
 */


// constants
var CANVAS_WIDTH = 640;
var CANVAS_HEIGHT = 640;
var GRID_SIZE = 8;

var PRECISION = 3;  // default number precision

var LEFT_KEY = 37;
var UP_KEY = 38;
var RIGHT_KEY = 39;
var DOWN_KEY = 40;
var ENTER_KEY = 13; 

var SHIFT_KEY = 16; // toggle between .. and --
var S_KEY = 83; // start path
var U_KEY = 85; // undo
var Z_KEY = 90; // add z--z
var PLUS_KEY = 187; // scale up canvas
var MINUS_KEY = 189; // scale down canvas
var D_KEY = 68;  // dot nodes, or not
var G_KEY = 71; // draw grid, or not
var L_KEY = 76; // draw line, or not

var P_KEY = 80;
var KEY_0 = 48;
var KEY_1 = 49;
var KEY_2 = 50;
var KEY_3 = 51;
var KEY_4 = 52;

var GRID_LINE_WIDTH = 0.2;
var GRID_STROKE_STYLE = "grey";

var g_paths = []; // an array of path
var g_cur_path = jp.newPath();  // the current path
var g_cur_conn = jp.FREE_CONN; // the current conn type
var g_cur_path_started = false;
var g_canvas_scale_factor = 1;

var img = new Image();
var c, ctx; // canvas and its context

//img.src = "http://shufa.supfree.net/k/126796.gif";
//img.src = "test.png";
var g_is_draw_grid = true; // draw grid or not
var g_is_show_image = true;  // show the image background or not
var g_is_dot_on_path = true; // do the nodes on path, or not
var g_is_line_path = true; // draw lines connecting nodes on path

// get the current mouse position from the Canvas
// and return a node representing it
//
// input: ctx: canvas context
//        e: mouse event
//        conn: connection type
// output: a node object
function getNodeFromCanvas(ctx, e, conn) {
    var c = ctx.canvas; 
    var n = jp.newNode();

    var bb = c.getBoundingClientRect(); 

    // Translate and scale mouse event coordinates to canvas coordinates,
    // and also convert y into normal coordinates
    n.x = (e.clientX-bb.left)*(c.width/bb.width) / g_canvas_scale_factor;
    n.y = - (e.clientY-bb.top)*(c.height/bb.height) / g_canvas_scale_factor + CANVAS_HEIGHT; // convert to normal coordinates
    n.conn = conn;

    $("#x").val(n.x.toFixed(PRECISION));
    $("#y").val(n.y.toFixed(PRECISION));
    
    return n;
}

// convert a path back to current canvas size/coordinates, prepared for draw on the current canvas
function convertPath2Canvas(p) {

    // convert Y into canvas coordinate
    function cy(y) {
        return -(y - CANVAS_HEIGHT) * g_canvas_scale_factor;
    }

    function cx(x) {
        return x * g_canvas_scale_factor;
    }
    
    var P = jp.jsonClone(p);
    var i;
    for (i = 0; i < P.nodes.length; i ++) {
        P.nodes[i].x = cx(P.nodes[i].x);
        P.nodes[i].y = cy(P.nodes[i].y);
    }
    return P;
}


// canvas hooks
function onClick(e) {
    if (g_cur_path_started === true) {
        var node = getNodeFromCanvas(ctx, e, g_cur_conn);
        //console.log(JSON.stringify(node));
        // preventing the two _adjacent_ nodes having the same position
        var n = g_cur_path.nodes.length;
        if (n > 1 && 
            g_cur_path.nodes[n-1].x === node.x &&
            g_cur_path.nodes[n-1].y === node.y) {
            console.log("you click too quick!");
            return;
        }
        g_cur_path.nodes.push(node);
        //displayCurrentPath();
    }
}

function onDoubleClick(e) {
    console.log("onDoubleClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onRightClick(e) {
    console.log("onRightClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

//
// the fact: canvas fires onmousemove events even the mouse position is not moved.
// the impact: when click event happens, the current position is added into the path, but
//   a mouse move event with the same position will be emitted. if we want to draw the
//   current path, the last two points are identical...then the Bezier curve will not be draw,
//   probably because the linear equations are not properly formed...
// the remedy: omit mouse move event when the position is not changed. use closure the keep the 
//   previous positions;
var onMouseMove = (function() {
    // previous e.clientX and e.clientY
    var pre_x = -1;
    var pre_y = -1;
    return function(e){
        if(pre_x === e.clientX && pre_y === e.clientY) {
            // console.log("move without position change!");
            return;
        }
        pre_x = e.clientX;
        pre_y = e.clientY;
        //console.log("onMouseMove: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);

        if (g_cur_path_started != true) {
            return;
        }

        g_cur_path.nodes.push(getNodeFromCanvas(ctx, e, null));
        redrawCanvas();
        g_cur_path.nodes.pop(); // remove it immediately, as the node is a temp one
    }
}());

function onMouseWheel(e) {
    console.log("onMouseWheel: dx=" + e.deltaX + ", dy=" + e.deltaY);
}

function onMouseLeave(e) {
    console.log("onMouseLeave: e=" + e);
    redrawCanvas();
}

function onMouseEnter(e) {
    console.log("onMouseEnter: e=" + e);
}

// button hooks
function startPath() {
    console.log("startPath: ");
    var n = g_cur_path.nodes.length;
    if (n > 0) {
        // assumes that the current path ends, so we save it
        // before doing so, making sure the path is open.
        // note that a closed path is always triggered by button click.
        g_cur_path.nodes[n-1].conn = jp.OPEN_CONN;
        g_paths.push(g_cur_path);
    }
 
    // re-init the guide
    g_cur_path = jp.newPath();
//    displayCurrentPath();
    g_cur_path_started = true;
}

function endPathKeepOpen() {
    var n = g_cur_path.nodes.length;
    if (n > 0) {
        g_cur_path.nodes[n-1].conn = jp.OPEN_CONN;
        g_paths.push(g_cur_path);
    }

    g_cur_path = jp.newPath();
    g_cur_path_started = false;

    outputResult();
    redrawCanvas();
}

function showEndPathKeepOpen() {
    var n = g_cur_path.nodes.length;
    if (n > 0) {
        var orig_conn = g_cur_path.nodes[n-1].conn;
        g_cur_path.nodes[n-1].conn = jp.OPEN_CONN;
        redrawCanvas();
        g_cur_path.nodes[n-1].conn = orig_conn;
    }
}

function endPathCloseWithDotDot() {
    var n = g_cur_path.nodes.length;
    if (n <= 1) {
        console.log("too few nodes");
        return;
    }

    g_cur_path.nodes[n-1].conn = jp.FREE_CONN;
    g_paths.push(g_cur_path);

    g_cur_path = jp.newPath();
    g_cur_path_started = false;

    outputResult();
    redrawCanvas();
}

function showEndPathCloseWithDotDot() {
    var n = g_cur_path.nodes.length;
    if (n > 1) {
        var orig_conn = g_cur_path.nodes[n-1].conn;
        g_cur_path.nodes[n-1].conn = jp.FREE_CONN;
        redrawCanvas();
        g_cur_path.nodes[n-1].conn = orig_conn;
    }
}

function endPathCloseWithDotDot2() {
    var n = g_cur_path.nodes.length;
    if (n <= 1) {
        console.log("too few nodes");
        return;
    }

    g_cur_path.nodes[n-1].conn = jp.FREE_CONN;

    // append z0--z0
    var z0 = jp.jsonClone(g_cur_path.nodes[0]);
    z0.conn = jp.LINE_CONN;
    g_cur_path.nodes.push(z0);

    g_paths.push(g_cur_path);

    
    g_cur_path = jp.newPath();
    g_cur_path_started = false;

    outputResult();
    redrawCanvas();
}

function showEndPathCloseWithDotDot2() {
    var n = g_cur_path.nodes.length;
    if (n > 1) {
        var orig_conn = g_cur_path.nodes[n-1].conn;
        g_cur_path.nodes[n-1].conn = jp.FREE_CONN;
        var z0 = jp.jsonClone(g_cur_path.nodes[0]);
        z0.conn = jp.LINE_CONN;
        g_cur_path.nodes.push(z0);
        redrawCanvas();
        g_cur_path.nodes.pop();
        g_cur_path.nodes[n-1].conn = orig_conn;
    }
}


function endPathWithDashDash() {
    var n = g_cur_path.nodes.length;
    if (n <= 1) {
        console.log("too few nodes");
        return;
    }

    g_cur_path.nodes[n-1].conn = jp.LINE_CONN;
    g_paths.push(g_cur_path);

    g_cur_path = jp.newPath();
    g_cur_path_started = false;

    outputResult();
    redrawCanvas();
}

function showEndPathCloseWithDashDash() {
    console.log("close with --");
    var n = g_cur_path.nodes.length;
    if (n > 1) {
        var orig_conn = g_cur_path.nodes[n-1].conn;
        g_cur_path.nodes[n-1].conn = jp.LINE_CONN;
        redrawCanvas();
        g_cur_path.nodes[n-1].conn = orig_conn;
    }
}

function endPathWithDashDash2() {
    var n = g_cur_path.nodes.length;
    if (n <= 1) {
        console.log("too few nodes");
        return;
    }

    g_cur_path.nodes[n-1].conn = jp.LINE_CONN;
    
    // append z0--z0
    var z0 = jp.jsonClone(g_cur_path.nodes[0]);
    z0.conn = jp.LINE_CONN;
    g_cur_path.nodes.push(z0);
    g_paths.push(g_cur_path);

    g_cur_path = jp.newPath();
    g_cur_path_started = false;

    outputResult();
    redrawCanvas();
}

function showEndPathCloseWithDashDash2() {
    var n = g_cur_path.nodes.length;
    if (n > 1) {
        var orig_conn = g_cur_path.nodes[n-1].conn;
        g_cur_path.nodes[n-1].conn = jp.LINE_CONN;
        var z0 = jp.jsonClone(g_cur_path.nodes[0]);
        z0.conn = jp.LINE_CONN;
        g_cur_path.nodes.push(z0);
        redrawCanvas();
        g_cur_path.nodes.pop();
        g_cur_path.nodes[n-1].conn = orig_conn;
    }
}

/*
 * discard the last point of the current guide
 */
function undoPoint() {
    if (g_cur_path.nodes.length > 0) {
        g_cur_path.nodes.pop();
    }

    //displayCurrentPath();
    redrawCanvas();
}

// append the last node again
function addDegradedSegment() {
    var n = g_cur_path.nodes.length;
    if (g_cur_path_started && n > 0) {
        var last = g_cur_path.nodes[n-1];
        var dup = jp.jsonClone(last);
        last.conn = jp.LINE_CONN;
        g_cur_path.nodes.push(dup);
    }
}

function onStraightConn () {
    g_cur_conn = jp.LINE_CONN;
    if (g_cur_path_started && g_cur_path.nodes.length > 0) {
        g_cur_path.nodes[g_cur_path.nodes.length-1].conn = g_cur_conn;
    }

    document.body.style.cursor = "crosshair";
}

function onFreeConn () {
    g_cur_conn = jp.FREE_CONN;
    if (g_cur_path_started && g_cur_path.nodes.length > 0) {
        g_cur_path.nodes[g_cur_path.nodes.length-1].conn = g_cur_conn;
    }
    document.body.style.cursor = "auto";
}

function toggleCurrentConn () {
    if (g_cur_conn === jp.LINE_CONN) {
        onFreeConn();
    } else {
        onStraightConn();
    }
}


function outputResult() {
    
    var asy = "guide[] gg = {" + g_paths.map(function(x){return jp.toAsy(x);}).join(",\r") + "};";
    var ta = document.getElementById("g_paths"); // textarea
    ta.value = asy;
    console.log(asy+"draw(gg);");
}


function drawImageAndGrid() {
    /*
     * draw the image, scale within the canvas size, as much as possible, but also keep the aspect ratio
     */
    if (g_is_show_image) {
        var img_ar = img.width / img.height;  // image aspect ratio
        var can_ar = CANVAS_WIDTH / CANVAS_HEIGHT; // canvas aspect ratio

        if(can_ar >= img_ar) {
            ctx.drawImage(img, 0, 0, c.height * img_ar, c.height);
        } else {
            ctx.drawImage(img, 0, 0, c.width, c.width / img_ar);
        }
    }
    

    // draw the grid
    if (g_is_draw_grid) {
        ctx.lineWidth = GRID_LINE_WIDTH;
        ctx.strokeStyle = GRID_STROKE_STYLE;

        // horizontal lines
        for (var i = 0;i <= c.width / GRID_SIZE; i ++){
	    ctx.beginPath();
	    ctx.moveTo(0, i * GRID_SIZE);
	    ctx.lineTo(c.width, i * GRID_SIZE);
	    ctx.stroke();
        }
        
        // vertical lines
        for (var i = 0; i <= c.height / GRID_SIZE; i ++){
	    ctx.beginPath();
	    ctx.moveTo(i * GRID_SIZE, 0);
	    ctx.lineTo(i * GRID_SIZE, c.height);
	    ctx.stroke();
        }
    }
}

function redrawCanvas (){
//    console.log("redrawCanvas...");

    ctx.clearRect(0, 0, c.width, c.height);
    drawImageAndGrid();
    
    // draw the paths
    g_paths.map(function(x){return j2c.drawOnePath(convertPath2Canvas(x), g_is_line_path);});
    j2c.drawOnePath(convertPath2Canvas(g_cur_path), g_is_line_path);

    // dot the paths
    if (g_is_dot_on_path) {
        g_paths.map(function(x){return j2c.dotOnePath(convertPath2Canvas(x));});
        j2c.dotOnePath(convertPath2Canvas(g_cur_path));
    }
}

function handleFocus(e) {
    if(e.type == 'mouseover'){
        //console.log("mouseover");
        c.focus();
        return false;
    }else if(e.type == 'mouseout'){
        c.blur();
        return false;
    }
    return true;
};

function handleKeyDown(e) {
    console.log("key down:" + e.keyCode);

    var key_id = e.keyCode || e.which;

    if (key_id === PLUS_KEY) {  // scale up canvas
        g_canvas_scale_factor *= 1.2;
        setCanvasSize(c);
    } else if (key_id === MINUS_KEY) {  // scale down canvas
        g_canvas_scale_factor /= 1.2;
        setCanvasSize(c);
    } else if (key_id === P_KEY) {  // image
        g_is_show_image = !g_is_show_image;
        redrawCanvas();
    } else if (key_id === G_KEY) {  // grid
        g_is_draw_grid = !g_is_draw_grid;
        redrawCanvas();
    } else if (key_id === D_KEY) {  // dot
        g_is_dot_on_path = !g_is_dot_on_path;
        redrawCanvas();
    } else if (key_id === L_KEY) {  // line
        g_is_line_path = !g_is_line_path;
        redrawCanvas();
    }

    if (!g_cur_path_started) {
        if (key_id === S_KEY) {
            startPath();
        } else {
            return true;
        }
    }


    // todo: simulate mouse move event, pixel by pixel
    if (key_id === LEFT_KEY) {
    } else if (key_id === RIGHT_KEY) {
    } else if (key_id === UP_KEY) {
    } else if (key_id === DOWN_KEY) {
    } else if (key_id === ENTER_KEY) {
        // todo: simulate the click event
    } else if (key_id === SHIFT_KEY) { 
        toggleCurrentConn();
    } else if (key_id === U_KEY) {  // undo point
        undoPoint();
    } else if (key_id === Z_KEY) {  // z--z
        addDegradedSegment();
    } else if (key_id === KEY_0) {  // end path keep open
        showEndPathKeepOpen();
    } else if (key_id === KEY_1) {  // end path, cycle with ..
        showEndPathCloseWithDotDot();
    } else if (key_id === KEY_2) {  // end path, cycle with ..z0--
        showEndPathCloseWithDotDot2();
    } else if (key_id === KEY_3) {  // end path, cycle with --
        showEndPathCloseWithDashDash();
    } else if (key_id === KEY_4) {  // end path, cycle with --z0--
        showEndPathCloseWithDashDash2();
    } else {
        return true;
    }

    return false;
};

function setCanvasSize(c) {
    c.width = CANVAS_WIDTH * g_canvas_scale_factor;
    c.height = CANVAS_HEIGHT * g_canvas_scale_factor;

    redrawCanvas();
}

function onLoad() {

    c = document.getElementById("myCanvas");

    ctx = c.getContext('2d');
    j2c.setContext(ctx);
    setCanvasSize(c);

    // event hooks
    c.onclick = onClick;
    c.ondblclick = onDoubleClick;
    c.oncontextmenu = onRightClick;
    c.onmousemove = onMouseMove;  // note that this is a closure
    c.onmousewheel = onMouseWheel;
    c.onmouseleave = onMouseLeave;
    c.onmouseenter = onMouseEnter;
    c.addEventListener('mouseover',handleFocus,false);
    c.addEventListener('mouseout',handleFocus,false);
    c.addEventListener('keydown',handleKeyDown,false);




    // set button callbacks
    btnStartPath = document.getElementById("startPath");
    btnUndoNode = document.getElementById("undoPoint");
    btnAddZDashDashZ = document.getElementById("addDegradedSegment");

    btnEndPathKeepOpen = document.getElementById("endPathKeepOpen");
    btnEndPathClosedWithDotDot = document.getElementById("endPathCloseWithDotDot");
    btnEndPathClosedWithDotDot2 = document.getElementById("endPathCloseWithDotDot2");
    btnEndPathClosedWithDashDash = document.getElementById("endPathWithDashDash");
    btnEndPathClosedWithDashDash2 = document.getElementById("endPathWithDashDash2");

    btnSelectFreeConn = document.getElementById("selectFreeConn");
    btnSelectLineConn = document.getElementById("selectLineConn");

    btnStartPath.onclick = startPath;
    btnEndPathKeepOpen.onclick = endPathKeepOpen;
    btnEndPathKeepOpen.onmouseover = showEndPathKeepOpen;
    btnEndPathClosedWithDotDot.onclick = endPathCloseWithDotDot;
    btnEndPathClosedWithDotDot.onmouseover = showEndPathCloseWithDotDot;
    btnEndPathClosedWithDotDot2.onclick = endPathCloseWithDotDot2;
    btnEndPathClosedWithDotDot2.onmouseover = showEndPathCloseWithDotDot2;
    btnEndPathClosedWithDashDash.onclick = endPathWithDashDash;
    btnEndPathClosedWithDashDash.onmouseover = showEndPathCloseWithDashDash;
    btnEndPathClosedWithDashDash2.onclick = endPathWithDashDash2;
    btnEndPathClosedWithDashDash2.onmouseover = showEndPathCloseWithDashDash2;

    btnUndoNode.onclick = undoPoint;
    btnAddZDashDashZ.onclick = addDegradedSegment;

    btnSelectFreeConn.onclick = onFreeConn;
    btnSelectLineConn.onclick = onStraightConn;


    //
    // drag and drop: 
    // - http://www.thebuzzmedia.com/html5-drag-and-drop-and-file-api-tutorial/
    // - http://stackoverflow.com/questions/3694631/html5-drag-and-drop-between-windows
    //
    var dropbox = document.getElementById("div1")

    // init event handlers
    dropbox.addEventListener("dragenter", dragEnter, false);
    dropbox.addEventListener("dragexit", dragExit, false);
    dropbox.addEventListener("dragover", dragOver, false);
    dropbox.addEventListener("drop", dragDrop, false);
}

function noopHandler(evt) {
    evt.stopPropagation();
    evt.preventDefault();
}    

function dragEnter(e) {
    console.log("dragEnter");
    noopHandler(e);
}

function dragExit(e) {
    console.log("dragExit");
    noopHandler(e);
}

function dragOver(e) {
    console.log("dragOver");
    noopHandler(e);
}

function dragDrop(evt) {
    console.log("dragDrop");
    noopHandler(evt);
    var url = evt.dataTransfer.getData("Text");

    if (url) {
        console.log(url);
        img.src = url;
        redrawCanvas();
    } else {

        console.log("local file?");
        var files = evt.dataTransfer.files;
        var file, reader;
        var count = files.length;

        console.log("count:", count);

        // Only call the handler if 1 or more files was dropped.
        if (count > 0) {
            file = files[0];
            
            console.log(file.name);
            
            reader = new FileReader();
            
            // init the reader event handlers
            reader.onloadend = handleReaderLoadEnd;
            
            // begin the read operation
            reader.readAsDataURL(file);
        }
    }
}

function handleReaderLoadEnd(evt) {
    console.log("handleReaderLoadEnd()...", evt.target.result);
    img.src = evt.target.result;
    redrawCanvas();
}

//
// buttons
//
var btnStartPath;
var btnEndPathKeepOpen;
var btnEndPathClosedWithDotDot;
var btnEndPathClosedWithDotDot2;
var btnEndPathClosedWithDashDash;
var btnEndPathClosedWithDashDash2;
var btnUndoNode; 
var btnAddZDashDashZ;
var btnSelectFreeConn;
var btnSelectLineConn;


window.onload = onLoad;
</script>
    </head>
    <body>
    Welcome!<br>
    <div id="div1">
    <canvas id="myCanvas" width="100" height="512" tabindex="0" style="border:2px solid green;"></canvas>
    </div>
    <div>
Fast keys:
<ul>
<li>p: toggle background image
<li>g: toggle grid
<li>d: toggle dots on path
<li>l: toogle line betw nodes
<li>+: scale up canvas
<li>-: scale down canvas
<li>s: start path
<li>u: undo point
<li>z: add z--z
<li>0: end path keep open
<li>1: cycle end path with ..
<li>2: cycle end path with ..z0--
<li>3: cycle end path with --
<li>4: cycle end path with --z0--
</ul>
</div>
    <div id="div2">
    <form>
    <input id="startPath" type="button" value="Start Path"/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <input id="undoPoint" type="button" value="Undo Point (u)"/>
    <input id="addDegradedSegment" type="button" value="z--z (z)"/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Select connector:
    <input id="selectFreeConn" type="button" value=".."/>
    <input id="selectLineConn" type="button" value="--"/> (tip: SHIFT key to toggle)
    <br>
    <input id="endPathKeepOpen" type="button" value="End Path (keep open)"/>
    <br>
    <input id="endPathCloseWithDotDot" type="button" value="End Path: close with .."/>
    <br>
    <input id="endPathCloseWithDotDot2" type="button" value="End Path: close with ..z0--"/>
    <br>
    <input id="endPathWithDashDash" type="button" value="End Path: close with --"/>
    <br>
    <input id="endPathWithDashDash2" type="button" value="End Path: close with --z0--"/>
    </form>
    <br>
    <textarea id="g_paths" rows="40" cols="100"></textarea>
    </div>
    <div id="menubar">
    </div>
    <div id="statusbar">
    <form>
    <label>x:</label><input id="x" type="text" size="4" class="coord"></input>
    <label>y:</label><input id="y" type="text" size="4"></input>
    </form>
    </div>
    </body>
    </html>
