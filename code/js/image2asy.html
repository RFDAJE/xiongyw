    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <style type="text/css">
    body {
        margin: 0px;
        padding: 0px;
    }
</style>
    <script type="text/javascript">


/* 
 * todos:
 * 
 * + support cyclic guide
 * - output coordinates in normal y direction (up): canvas y is down, asy y is up;
 * - add button to load picture from file system or url
 * - add button/check_box to display/hide the picture, if loaded
 * - add selection of the current point/path connection types
 * - add logic to produce mutliple paths (path[])
 * - make it possible to make comments for a path
 * - make it possible to specify draw/fill color for a path
 * - make it possible to manually adjust point position, at any time (by selecting the path first)
 * - make it possible to draw cubic curves in canvas to reflect what's going to be drawn in asy
 * - make it possible to export SVG format data
 */

// constants
var CANVAS_WIDTH = 1020;
var CANVAS_HEIGHT = 1024;
var GRID_SIZE = 8;

/* note: 
 *  A node/knot of a guide/path is represented by a point on the plane (z), which is 
 *  represented here by an array of two numbers: [x,y]; 
 *  A node, i.e., this array (also an object), can also contain "metapost properties":
 *   - d_post: |z[k+1]-z[k]|
 *   - d_ant: |z[k]-z[k-1]|
 *   - xi: turning angle (at the node on the polygon of the guide)
 *   - alpha: 
 *   - beta:
 *   - theta: departure angle
 *   - phi: arraival angle
 *   - ...
 *
 * A path/guide is represented by an array of points. The path/guide can contain 
 * the following "metapost" properties:
 *   - cyclic: 
 *   - curl_begin:
 *   - curl_end:
 */

var g_result = []; // an array of array of points, representing the guides
var g_current_guide = [];  // an array of points, representing the current g_current_guide
var g_last_point = []; // the last point in the current g_current_guide
var g_current_guide_started = false;

var img = new Image();
var c, ctx; // canvas and its context
var start_btn, stop_btn, cycle_btn, undo_btn; // buttons

//img.src = "http://10.12.2.225:8080/test.png";
//img.src = "test.png";


// return the complex sum
function c_sum(z0, z1) {
    return [z0[0]+z1[0], z0[1]+z1[1]];
}

// return the complex sub
function c_sub(z0, z1) {
    return [z0[0]-z1[0], z0[1]-z1[1]];
}

// return the complex production
function c_prod(z0, z1) {
    return [z0[0]*z1[0]-z0[1]*z1[1], z0[0]*z1[1]+z0[1]*z1[0]];
}

// return the length of the vector
function c_mod(z) {
    return Math.sqrt(z[0]*z[0] + z[1]*z[1]);
}

// return the angle (in rad) of a vector
function c_arg(z) {
    if (z[0] == 0) {
        if (z[1] > 0) {
            return Math.PI/2;
        } else if (z[1] < 0) {
            return -Math.PI/2;
        } else {
            return 0; // ?
        }
    } else {
        return Math.atan(z[1]/z[0]);
    }
}

/*
 * velocity function f(theta, phi) from "John Hobby 1986", for metafont/metapost
 *
 * theta: departure angle (in rad) at the first point z0, relative to z1-z0
 * phi: arrival angle (in rad) at the second point z1, relative to z1-z0
 */
function mp_f(theta, phi) {
    var n = 2+Math.sqrt(2)*(Math.sin(theta)-Math.sin(phi)/16)*(Math.sin(phi)-Math.sin(theta)/16)*(Math.cos(theta)-Math.cos(phi));
    var m = 3*(1 + 0.5*(Math.sqrt(5)-1)*Math.cos(theta) + 0.5*(3-Math.sqrt(5))*Math.cos(phi));
    return n/m;
}

/*
 * return u and v in an array: [[ux,uy], [vx,vy]]
 */
function mp_uv(z0, z1, theta, phi, alpha, beta) {
    // the formula using complex numbers:
    // u = z0+exp(i*theta)*(z1-z0)*f(theta,-phi)/alpha
    // v = z1-exp(i*phi)*(z1-z0)*f(-phi,theta)/beta

    var l = [z1[0]-z0[0], z1[1]-z0[1]];  // l = z1-z0
    var t = [Math.cos(theta), Math.sin(theta)];  // exp(i*theta)
    var p = [Math.cos(phi), Math.sin(phi)];    // exp(i*phi)

    var u = c_sum(z0, c_prod(t,c_prod(l,[mp_f(theta,-phi)/alpha,0])));
    var v = c_sub(z1, c_prod(p,c_prod(l,[mp_f(-phi,theta)/beta,0])));

    return [u,v];
}

/*
 * http://en.wikipedia.org/wiki/Gaussian_elimination
 *
 * A: matrix (an array of array, mxn, i.e. m rows and n columns)
 * b: vector (mx1)
 * m,n: size of the matrix
 * return: x, a vector (array of m elements)
 *
 * sample usage:
 *
 * var A=[[2,1,-1],[-3,-1,2],[-2,1,2]];
 * var b=[8,-11,-3];
 * var x=mp_solve_matrix(A,b,3,3);
 *
 * then: x=[2, 3, -0.9999999999999999];
 */
function mp_solve_matrix(A, b, m, n) {
    var i, j, k, u, maxi, tmp, pivot, sum;
    var M = [], x = [];

    // deep copy A and b into M as combined
    for (i = 0; i < m; i ++) {
        var row = [];
        for (j = 0; j < n; j ++) {
            row.push(A[i][j]);
        }
        row.push(b[i]);
        M.push(row);
    }

    /*
     * elimination 
     */
    i = 0;  // row 
    j = 0;  // col
    while (i < m && j < n) {
        // find pivot (i.e. its row index) in col j, starting from row i
        maxi = i;  // idx of the row whose column j is the max
        for (k = i+1; k < m; k ++) {
            if (Math.abs(M[k][j]) > Math.abs(M[maxi][j])) {
                maxi = k;
            }
        }

        if (M[maxi][j] != 0) {
            // swap row maxi and i
            if (maxi != i) { 
                tmp = M[maxi];
                M[maxi] = M[i];
                M[i] = tmp;
            }
            pivot = M[i][j];

            // divide i row by the pivot
            for (k = 0; k < n + 1; k ++) {
                M[i][k] = M[i][k] / pivot;
            }
            // now the pivot M[i][j] = 1

            // substract M[u][j] * row i from row u 
            for (u = i+1; u < m; u ++) {
                pivot = M[u][j];
                for (k = 0; k < n + 1; k ++) {
                    M[u][k] = M[u][k] - M[i][k] * pivot;
                }
            }
            i = i + 1;
        }
        j = j +1;
    }

    /* 
     * get the results
     */
    if (m == n) {
        x[m-1] = M[m-1][m];
        for (i = m-2; i >=0; i --) {
            sum = 0;
            for (j = i+1; j < m; j ++) {
                sum = sum + M[i][j] * x[j];
            }
            x[i] = M[i][m] - sum;
        }
    }

    return x;
}

/*
 * the following routines are "cloned" from the original python code:
 * http://tex.stackexchange.com/questions/54771/curve-through-a-sequence-of-points-with-metapost-and-tikz
 */
var MP_DEFAULT_ALPHA = 1;
var MP_DEFAULT_BETA = 1;
var MP_DEFAULT_CURL_BEGIN = 1;
var MP_DEFAULT_CURL_END = 1;
/* 
 * traverses the guide and computes the distance between adjacent points, and the 
 * turning angles of the polyline which joins them
 *
 * g: an array of points (which forms an asymptote guide)
 * output: none. but following properties of each point g[k] (treated as a complex number here) is added or updated:
 *  "d_ant": |g[k]-g[k-1]|
 *  "d_post": |g[k+1]-g[k]|
 *  "xi": turning angle at g[k], in rad: arg((g[k+1]-g[k])/(g[k]-g[k-1]))
 *
 * sample test cases:
 * 1. non-cyclic:
 *   var g=[[0,0],[100,0],[100,100]];
 *   mp_compute_distances_and_angles(g);
 * then:
 *   g[0]: [0, 0, d_ant: 0, d_post: 100, xi: 0]
 *   g[1]: [100, 0, d_post: 100, d_ant: 100, xi: 1.5707963267948966]
 *   g[2]: [100, 100, d_ant: 100, d_post: 0, xi: 0]
 *
 * 2. cyclic:
 *   var g=[[0,0],[100,0],[100,100]];
 *   g.cyclic = true;
 *   mp_compute_distances_and_angles(g);
 * then:
 *   g[0]: [0, 0, d_post: 100, d_ant: 141.4213562373095, xi: -0.7853981633974483]
 *   g[1]: [100, 0, d_post: 100, d_ant: 100, xi: 1.5707963267948966]
 *   g[2]: [100, 100, d_post: 141.4213562373095, d_ant: 100, xi: -0.7853981633974483]
 */
function mp_compute_distances_and_angles(g) {

    var i; 
    
    if (g.length < 2) {
        return;
    }

    /*
     * input: _k : g[k-1] : read-only
     *         k : g[k]   : in and out. the d_post/d_ant/xi properties of this node will be updated
     *         k_: g[k+1] : read-only
     */
    function _for_each_node (_k, k, k_) {
        var l_post = c_sub(k_, k);
        var l_ant = c_sub(k, _k);
        var arg_post = c_arg(l_post);
        var arg_ant = c_arg(l_ant);

        k.d_post = c_mod(l_post);
        k.d_ant = c_mod(l_ant);
        k.xi = arg_post - arg_ant;
    }

    // first node
    if (!g.cyclic) {
        g[0].d_ant = 0;
        g[0].d_post = c_mod(c_sub(g[1], g[0]));
        g[0].xi = 0;
    } else {
        _for_each_node(g[g.length-1], g[0], g[1]); 
    }

    // middle nodes
    for (i = 1; i < g.length-1; i ++) {
        _for_each_node(g[i-1], g[i], g[i+1]);
    }

    // last node
    if (!g.cyclic) {
        g[g.length-1].d_ant = c_mod(c_sub(g[g.length-1], g[g.length-2]));
        g[g.length-1].d_post = 0;
        g[g.length-1].xi = 0;
    } else {
        _for_each_node(g[g.length-2], g[g.length-1], g[0]);
    }
}

/*
 * This function creates five vectors which are coefficients of a
 * linear system which allows finding the right values of "theta" at
 * each point of the path (being "theta" the angle of departure of the
 * path at each point). The theory is from METAFONT book."""
 */
/*
function build_coefficients(g) {
    var A=[], B=[], C=[], D=[], R=[];
    //var cyclic = g[g.length-1].circle || false;
    var i, n = g.length - (cyclic? 1: 0); // number of nodes

    mp_compute_distances_and_angles(g);

    // making sure the following exist in g and each node of g:
    g.curl_begin = g.curl_begin || MP_DEFAULT_CURL_BEGIN;
    g.curl_end = g.curl_end || MP_DEFAULT_CURL_END;
    for (i = 0; i < n; i ++) {
        g[i].alpha = g[i].alpha || MP_DEFAULT_ALPHA;
        g[i].beta = g[i].beta || MP_DEFAULT_BETA;
    }

    // input: _n : g[n-1]
    //         n : g[n]  
    //         n_: g[n+1]
    //        idx: the idx for node "n"
    // output: A/B/C/D/R is updated accordingly
    function _for_each_node (_n, n, n_, idx) {
        // making sure alpha/beta exists
        _n.alpha = _n.alpha || MP_DEFAULT_ALPHA;
        n.alpha  = n.alpha  || MP_DEFAULT_ALPHA;
        n_.alpha = n_.alpha || MP_DEFAULT_ALPHA;

        _n.beta  = _n.beta  || MP_DEFAULT_BETA;
        n.beta   = n.beta   || MP_DEFAULT_BETA;
        n_.beta  = n_.beta  || MP_DEFAULT_BETA;

        A.push(   _n.alpha  / (Math.pow(n.beta,2)  * n.d_ant))
        B.push((3-_n.alpha) / (Math.pow(n.beta,2)  * n.d_ant))
        C.push((3-n_.beta)  / (Math.pow(n.alpha,2) * n.d_post))
        D.push(   n_.beta   / (Math.pow(n.alpha,2) * n.d_post))
        R.push(-B[idx] * n.xi  - D[idx] * n_.xi)
    }

    if (g.cyclic) {
        // In this case, first equation doesnt follow the general rule
        A.push(0);
        B.push(0);
        var curl = g.curl_begin;
        var alpha_0 = g[0].alpha;
        var beta_1 = g[1].beta;
        var xi_0 = Math.pow(alpha_0,2) * curl / Math.pow(beta_1,2);
        var xi_1 = g[1].xi;
        C.push(xi_0*alpha_0 + 3 - beta_1)
        D.push((3 - alpha_0)*xi_0 + beta_1)
        R.push(-D[0]*xi_1)
    } else {
        _for_each_node(g[n-1], g[0], g[1], 0);
    }


    // Equations 1 to n-1 (or 0 to n for cyclic paths)
    for k in path.range():
        A.push(   path[k-1].alpha  / ((path[k].beta**2)  * path[k].d_ant))
        B.push((3-path[k-1].alpha) / ((path[k].beta**2)  * path[k].d_ant))
        C.push((3-path[k+1].beta)  / ((path[k].alpha**2) * path[k].d_post))
        D.push(   path[k+1].beta   / ((path[k].alpha**2) * path[k].d_post))
        R.push(-B[k] * path[k].xi  - D[k] * path[k+1].xi)

    if not path.cyclic:
        # The last equation doesnt follow the general form
        n = len(R)     # index to generate
        C.push(0)
        D.push(0)
        curl = path.curl_end
        beta_n = path[n].beta
        alpha_n_1 = path[n-1].alpha
        xi_n = (beta_n**2) * curl / (alpha_n_1**2)
        A.push((3-beta_n)*xi_n + alpha_n_1)
        B.push(beta_n*xi_n + 3 - alpha_n_1)
        R.push(0)
    return (A, B, C, D, R)
}


function mp_solve_for_thetas(A, B, C, D, R) {
    """This function receives the five vectors created by
    build_coefficients() and uses them to build a linear system with N
    unknonws (being N the number of points in the path). Solving the system
    finds the value for theta (departure angle) at each point"""
    L=len(R)
    a = np.zeros((L, L))
    for k in range(L):
       prev = (k-1)%L
       post = (k+1)%L
       a[k][prev] = A[k]
       a[k][k]    = B[k]+C[k]
       a[k][post] = D[k]
    b = np.array(R)
    return np.linalg.solve(a,b)
}

function mp_solve_angles(g) {
    """This function receives a path in which each point is "open", i.e. it
    does not specify any direction of departure or arrival at each node,
    and finds these directions in such a way which minimizes "mock
    curvature". The theory is from METAFONT book."""

    # Basically it solves
    # a linear system which finds all departure angles (theta), and from
    # these and the turning angles at each point, the arrival angles (phi)
    # can be obtained, since theta + phi + xi = 0  at each knot"""
    x = solve_for_thetas(*build_coefficients(path))
    L = len(path)
    for k in range(L):
        path[k].theta = x[k]
    for k in range(L):
        path[k].phi = - path[k].theta - path[k].xi
}

function mp_find_controls(g) {
    """This function receives a path in which, for each point, the values
    of theta and phi (leave and enter directions) are known, either because
    they were previously stored in the structure, or because it was
    computed by function solve_angles(). From this path description
    this function computes the control points for each knot and stores
    it in the path. After this, it is possible to print path to get
    a string suitable to be feed to tikz."""
    r = []
    for k in range(len(path)):
        z0 = path[k].z
        z1 = path[k+1].z
        theta = path[k].theta
        phi = path[k+1].phi
        alpha = path[k].alpha
        beta = path[k+1].beta
        u,v=control_points(z0, z1, theta, phi, alpha, beta)
        path[k].u_right = u
        path[k+1].v_left = v
}
*/

function getCanvasPos(ctx, e) {
    var c = ctx.canvas; 

    var bb = c.getBoundingClientRect(); 

    // Translate and scale mouse event coordinates to canvas coordinates
    var x = (e.clientX-bb.left)*(c.width/bb.width);
    var y = (e.clientY-bb.top)*(c.height/bb.height);

    return [x, y];
}

// canvas hooks
function onClick(e) {
    //console.log("onClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    console.log(g_result);
    if (g_current_guide_started === true) {
        //g_last_point = [e.clientX, e.clientY]; 
        g_last_point = getCanvasPos(ctx, e);
        g_current_guide.push(g_last_point);
    }
    displayCurrentGuide();

}

function onDoubleClick(e) {
    //console.log("onDoubleClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onRightClick(e) {
    console.log("onRightClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onMouseMove(e) {
    //console.log("onMouseMove: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    var cur = getCanvasPos(ctx, e); // current position
    drawResult();
    if(g_last_point.length > 0) {
            ctx.beginPath();
            ctx.moveTo(g_last_point[0], g_last_point[1]);
            ctx.lineTo(cur[0], cur[1]);
            ctx.stroke();
    }
}

function onMouseWheel(e) {
    console.log("onMouseWhell: dx=" + e.deltaX + ", dy=" + e.deltaY);
}

// button hooks
function startPath() {
    console.log("startPath: ");
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }
    g_current_guide = [];
    g_last_point = [];
    displayCurrentGuide();
    g_current_guide_started = true;
}

function stopPath() {
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_last_point = [];
    g_current_guide_started = false;

    outputResult();
    drawResult();
}

// this also end the current path
function cyclePath() {
    if (g_current_guide.length > 0) {  // should be > 1?
        g_current_guide.cyclic =true;
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_last_point = [];
    g_current_guide_started = false;

    outputResult();
    drawResult();
}

/*
 * discard the last point of the current guide
 */
function undoPath() {
    if (g_current_guide.length > 0) {
        g_current_guide.pop();
    }
    if (g_current_guide.length > 0) {
        g_last_point = g_current_guide[g_current_guide.length - 1];
    } else {
        g_last_point = [];
    }
    displayCurrentGuide();
}

function pointArrayToAsyGuide(g) {
    // note: change the y direction from canvas to normal: inverse the sign
    var txt = "" + g.map(function(x) { return "(" + x[0].toFixed(3) + "," + -x[1].toFixed(3) + ")"; }).join("..");
    if (g.cyclic) {
        txt = txt + "..cycle";
    }
    return txt;
}


function displayCurrentGuide() {
    var ta =  document.getElementById("g_current_guide"); // textarea
    ta.value = pointArrayToAsyGuide(g_current_guide);
}

function outputResult() {
    var ta =  document.getElementById("g_result"); // textarea
    ta.value = g_result.map(function(x){return pointArrayToAsyGuide(x);}).join(",\r");
    console.log("guide[] gg = {" + ta.value + "}");
}


function drawImageAndGrid() {
    /*
     * draw the image, scale within the canvas size, as much as possible, but also keep the aspect ratio
     */
    var img_ar = img.width / img.height;  // image aspect ratio
    var can_ar = CANVAS_WIDTH / CANVAS_HEIGHT; // canvas aspect ratio

    if(can_ar >= img_ar) {
        ctx.drawImage(img, 0, 0, c.height * img_ar, c.height);
    } else {
        ctx.drawImage(img, 0, 0, c.width, c.width / img_ar);
    }
    

    // draw the grid
    ctx.lineWidth = 0.2;
    ctx.strokeStyle = "grey";

    // horizontal lines
    for (var i = 0;i <= c.width / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(0, i * GRID_SIZE);
	ctx.lineTo(c.width, i * GRID_SIZE);
	ctx.stroke();
    }
    
    // vertical lines
    for (var i = 0; i <= c.height / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(i * GRID_SIZE, 0);
	ctx.lineTo(i * GRID_SIZE, c.height);
	ctx.stroke();
    }
}

function drawResult(){

    ctx.clearRect(0, 0, c.width, c.height);

    drawImageAndGrid();

    // draw lines
    ctx.lineWidth = 0.5;
    ctx.strokeStyle = "black";

    // add the current g_current_guide into the g_result
    var res_temp = JSON.parse(JSON.stringify(g_result)); // deep copy
    res_temp.push(g_current_guide);  

    for(var i = 0; i < res_temp.length; i ++) {
        for(var j = 0; j < res_temp[i].length - 1; j ++) {
            ctx.beginPath();
            ctx.moveTo(res_temp[i][j][0], res_temp[i][j][1]);
            ctx.lineTo(res_temp[i][j+1][0], res_temp[i][j+1][1]);
            ctx.stroke();
        }
    }
    res_temp = null;
}

function onLoad() {

    c = document.getElementById("myCanvas");

    c.width = CANVAS_WIDTH;
    c.height = CANVAS_HEIGHT;

    // event hooks
    c.onclick = onClick;
    c.ondblclick = onDoubleClick;
    c.oncontextmenu = onRightClick;
    c.onmousemove = onMouseMove;
    c.onmousewheel = onMouseWheel;

    ctx = c.getContext('2d');

    drawImageAndGrid();

    // set button callbacks
    start_btn = document.getElementById("startPath");
    stop_btn = document.getElementById("stopPath");
    undo_btn = document.getElementById("undoPath");
    cycle_btn = document.getElementById("cyclePath");

    start_btn.onclick = startPath;
    stop_btn.onclick = stopPath;
    undo_btn.onclick = undoPath;
    cycle_btn.onclick = cyclePath;

}


window.onload = onLoad;
</script>
    </head>
    <body>
    <div id="div1" style="float: left;">
    <canvas id="myCanvas" width="100" height="512" style="border:2px solid green;"></canvas>
    </div>
    <div id="div2" style="float: left;">
    <form>
    <input id="startPath" type="button" value="Start Path"/>
    <input id="undoPath" type="button" value="Undo Path"/>
    <input id="stopPath" type="button" value="Stop Path"/>
    <input id="cyclePath" type="button" value="Stop Cyclic Path"/>
    </form>
    <br>
    <textarea id="g_current_guide" rows="50" cols="50"></textarea>
    <textarea id="g_result" rows="50" cols="50"></textarea>
    </div>
    </body>
    </html>
