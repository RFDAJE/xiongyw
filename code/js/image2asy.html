    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <style type="text/css">
    body {
        margin: 0px;
        padding: 0px;
    }
</style>
    <script type="text/javascript" src="jh1986.js"></script>
    <script type="text/javascript">


/* 
 * todos:
 * 
 * + support cyclic guide
 * + output coordinates in normal y direction (up): canvas y is down, asy y is up;
 * - add button to load picture from file system or url
 * - add button/check_box to display/hide the picture, if loaded
 * - add selection of the current point/path connection types
 * - make it possible to make comments for a path
 * - make it possible to specify draw/fill color for a path
 * + hilights nodes on the paths
 * - snap to nodes on the paths
 * - make it possible to manually adjust point position, at any time (by selecting the path first)
 * + make it possible to draw cubic curves in canvas to reflect what's going to be drawn in asy
 * - make it possible to export SVG format data
 * + detect when mouse move out of canvas (and update the draw accordingly)
 * + add keyboard event (up/down/left/right) support: http://dbp-consulting.com/tutorials/canvas/CanvasKeyEvents.html
 * + add connector support: "--", "&&"
 * - read: http://www.williammalone.com/articles/create-html5-canvas-javascript-drawing-app/
 */

// constants
var CANVAS_WIDTH = 1020;
var CANVAS_HEIGHT = 1024;
var GRID_SIZE = 8;

var LEFT_KEY = 37;
var UP_KEY = 38;
var RIGHT_KEY = 39;
var DOWN_KEY = 40;
var ENTER_KEY = 13; 

// canvas context constants
var GRID_LINE_WIDTH = 0.2;
var GRID_STROKE_STYLE = "grey";
var POLYGON_LINE_WIDTH = 1;
var POLYGON_STROKE_STYLE = "red";
var BEZIER_LINE_WIDTH = 3;
var BEZIER_STROKE_STYLE = "blue";
var DOT_RADIUS = 4;
var DOT_FILL_STYLE = "black";
var CURSUR_LINE_WIDTH = 1; // cursor in the center or the dot
var CURSUR_SIZE = 4;
var CURSUR_STROKE_STYLE = "white";

var g_result = []; // an array of array of points, representing the guides
var g_current_guide = [];  // an array of points, representing the current g_current_guide
var g_current_guide_started = false;

var img = new Image();
var c, ctx; // canvas and its context
var start_btn, stop_btn, cycle_btn, undo_btn; // buttons

//img.src = "http://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Sine_cosine_one_period.svg/300px-Sine_cosine_one_period.svg.png";
//img.src = "test.png";


function getCanvasPos(ctx, e) {
    var c = ctx.canvas; 

    var bb = c.getBoundingClientRect(); 

    // Translate and scale mouse event coordinates to canvas coordinates
    var x = (e.clientX-bb.left)*(c.width/bb.width);
    var y = (e.clientY-bb.top)*(c.height/bb.height);

    return [x, y];
}

// canvas hooks
function onClick(e) {
    if (g_current_guide_started === true) {
        var cur = getCanvasPos(ctx, e);
        //console.log(cur);
        // preventing the two _adjacent_ nodes having the same position
        var n= g_current_guide.length;
        if (n > 1 && 
            g_current_guide[n-1][0] === cur[0] &&
            g_current_guide[n-1][1] === cur[1]) {
            console.log("you click too quick!");
            return;
        }
        g_current_guide.push(cur);
        displayCurrentGuide();
    }
}

function onDoubleClick(e) {
    console.log("onDoubleClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onRightClick(e) {
    console.log("onRightClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

//
// the fact: canvas fires onmousemove events even the mouse position is not moved.
// the impact: when click event happens, the current position is added into the path, but
//   a mouse move event with the same position will be emitted. if we want to draw the
//   current path, the last two points are identical...then the Bezier curve will not be draw,
//   probably because the linear equations are not properly formed...
// the remedy: omit mouse move event when the position is not changed. use closure the keep the 
//   previous positions;
var onMouseMove = (function() {
    // previous e.clientX and e.clientY
    var pre_x = -1;
    var pre_y = -1;
    return function(e){
        if(pre_x === e.clientX && pre_y === e.clientY) {
            // console.log("move without position change!");
            return;
        }
        pre_x = e.clientX;
        pre_y = e.clientY;
        //console.log("onMouseMove: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);

        if (g_current_guide_started != true) {
            return;
        }

        g_current_guide.push(getCanvasPos(ctx, e));
        redrawCanvas();
        g_current_guide.pop(); // remove it immediately, as the node is a temp one
    }
}());

function onMouseWheel(e) {
    console.log("onMouseWheel: dx=" + e.deltaX + ", dy=" + e.deltaY);
}

function onMouseLeave(e) {
    //console.log("onMouseLeave: e=" + e);
    redrawCanvas();
}

// button hooks
function startPath() {
    console.log("startPath: ");
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }
 
    // init the guide
    g_current_guide = [];
    g_current_guide.curl_begin = jh.DEFAULT_CURL_BEGIN;
    g_current_guide.curl_end = jh.DEFAULT_CURL_END;
    g_current_guide.cyclic = false;

    displayCurrentGuide();
    g_current_guide_started = true;
}

function stopPath() {
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_current_guide_started = false;

    outputResult();
    redrawCanvas();
}

//
// when exporting to Asymptote, use buildcycle() to make the path cyclic
//
function buildCycle() {
    if (g_current_guide.length > 1) {
        // push the first point
        g_current_guide.push(g_current_guide[0]);
        g_current_guide.buildcycle = true;
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_current_guide_started = false;

    outputResult();
    redrawCanvas();
}


// this also end the current path
function cyclePath() {
    if (g_current_guide.length > 0) {  // should be > 1?
        g_current_guide.cyclic = true;
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_current_guide_started = false;

    outputResult();
    redrawCanvas();
}


/*
 * discard the last point of the current guide
 */
function undoPoint() {
    if (g_current_guide.length > 0) {
        g_current_guide.pop();
    }

    displayCurrentGuide();
    redrawCanvas();
}

// by default it's free conn, so not needed
//
//function onFreeConn () {
//    if (g_current_guide_started && g_current_guide.length > 0) {
//        g_current_guide[g_current_guide.length-1].conn = jh.conn.FREE_CURVE;
//    }
//}

function onStraightConn () {
    if (g_current_guide_started && g_current_guide.length > 0) {
        g_current_guide[g_current_guide.length-1].conn = jh.conn.STRAIGHT_LINE;
    }
}

function onMySpliceConn () {
    if (g_current_guide_started && g_current_guide.length > 0) {
        var last = g_current_guide[g_current_guide.length-1];
        last.conn = MY_SPLICE;
        // insert the last node again
        var n = [];
        n[0] = last[0];
        n[1] = last[1];
        n.conn = jh.conn.FREE_CURVE;
        g_current_guide.push(n);
    }
}

function pointArrayToAsyGuide(G) {
    // for each subpath, return the guide
    function _for_each_sub(sub) {
        return "" + sub.map(function(x) {
            return "(" + x[0].toFixed(3) + "," + -x[1].toFixed(3) + ")";
        }).join(sub[0].conn);
    }

    var subs = divideOnePath(G);
    var txt = "" + subs.map(function(sub){return _for_each_sub(sub);}).join(",");

    console.log(txt);

    // use buildcycle() if G.buildcycle=true, or G.cyclic=true and (subs.length > 1)
    if (G.buildcycle === true) {
        if(subs.length === 1){
            // only one sub, this means the first and last points are the same, 
            // we only need to close the path now
            // if we buildcycle() on this single path, it will not work, as buildcycle()
            // expects at least two paths.
            txt = txt + "--cycle";
        } else {
            txt = "buildcycle(" + txt + ")";
        }
    } else if (G.cyclic === true) {
        console.log("subs.length:", subs.length);
        if(subs.length === 1) {
            txt = txt + (G[G.length-1].conn || jh.conn.FREE_CURVE) + "cycle";
        } else {
            txt = "buildcycle(" + txt + ")";
        }
    }

    return txt;
}

function displayCurrentGuide() {
    var ta =  document.getElementById("g_current_guide"); // textarea
    ta.value = pointArrayToAsyGuide(g_current_guide);
}

function outputResult() {
    var ta =  document.getElementById("g_result"); // textarea
    ta.value = g_result.map(function(x){return pointArrayToAsyGuide(x);}).join(",\r");
    console.log("guide[] gg = {" + ta.value + "}");
}


function drawImageAndGrid() {
    /*
     * draw the image, scale within the canvas size, as much as possible, but also keep the aspect ratio
     */
    var img_ar = img.width / img.height;  // image aspect ratio
    var can_ar = CANVAS_WIDTH / CANVAS_HEIGHT; // canvas aspect ratio

    if(can_ar >= img_ar) {
        ctx.drawImage(img, 0, 0, c.height * img_ar, c.height);
    } else {
        ctx.drawImage(img, 0, 0, c.width, c.width / img_ar);
    }
    

    // draw the grid
    ctx.lineWidth = GRID_LINE_WIDTH;
    ctx.strokeStyle = GRID_STROKE_STYLE;

    // horizontal lines
    for (var i = 0;i <= c.width / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(0, i * GRID_SIZE);
	ctx.lineTo(c.width, i * GRID_SIZE);
	ctx.stroke();
    }
    
    // vertical lines
    for (var i = 0; i <= c.height / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(i * GRID_SIZE, 0);
	ctx.lineTo(i * GRID_SIZE, c.height);
	ctx.stroke();
    }
}

// my splice: the idea is to build path with charp corners without using explicit
// direction specifier. the way is to concat smooth paths together, without
// discarding the last node of the previous subpath. e.g.,
// "z1..z2..z3&&z3..z4..z5" purely means "z1..z2..z3" plus "z3..z4..z5",
// so effectively this is itself an array of path.
// Be noted that the two nodes surround "&&" must be the same;
// if we want the path array to be cyclic (in Asymptote), use buildcycle()
var MY_SPLICE ="&&"; 


//
// draw a free path: connectors between nodes are all free connector ".."
// 
function drawFreePath(p) {

    //
    // draw bezier
    //
    var u, v;

    if (p.length < 2) {
        return;
    }

    // get the control points
    jh.solve_angles(p);
    jh.find_control_points(p);

    ctx.lineWidth = BEZIER_LINE_WIDTH;
    ctx.strokeStyle = BEZIER_STROKE_STYLE;
    ctx.beginPath();
    ctx.moveTo(p[0][0], p[0][1]);
    u = p[0].u;
    for(j = 1; j < p.length; j ++) {
        v = p[j].v;
        ctx.bezierCurveTo(u[0], u[1], v[0], v[1], p[j][0], p[j][1]);
        u = p[j].u;
    }
    if (p.cyclic) {
        v = p[0].v;
        ctx.bezierCurveTo(u[0], u[1], v[0], v[1], p[0][0], p[0][1]);
        ctx.closePath();
    }
    ctx.stroke();

    //
    // draw polygons
    //
    if (p.length < 1) {
        return;
    }

    ctx.lineWidth = POLYGON_LINE_WIDTH;
    ctx.strokeStyle = POLYGON_STROKE_STYLE;
    ctx.beginPath();
    ctx.moveTo(p[0][0], p[0][1]);
    for(j = 1; j < p.length; j ++) {
        ctx.lineTo(p[j][0], p[j][1]);
    }
    if (p.cyclic) {
        ctx.closePath();
    }
    ctx.stroke();
}

//
// draw a straight path: connectors between nodes are all straightline connector "--"
// 
function drawStraightPath(p) {
    //
    // draw polygons
    //
    if (p.length < 1) {
        return;
    }

    ctx.lineWidth = BEZIER_LINE_WIDTH;
    ctx.strokeStyle = BEZIER_STROKE_STYLE;
    ctx.beginPath();
    ctx.moveTo(p[0][0], p[0][1]);
    for(j = 1; j < p.length; j ++) {
        ctx.lineTo(p[j][0], p[j][1]);
    }
    if (p.cyclic) {
        ctx.closePath();
    }
    ctx.stroke();
}

// clone a node
function cloneOneNode(n) {
    var c = [];
    c[0] = n[0];
    c[1] = n[1];
    c.conn = n.conn;
    return c;
}

// clone a path
function cloneOnePath(p) {
    var i, c=[];
    c.cyclic = p.cyclic;
    c.buildcycle = p.buildcycle;
    p.map(function(n){c.push(cloneOneNode(n))});
    return c;
}

//
// divide a path into a subpath array, each subpath is either a free curve,
// or a polygon. curve or straight is determined by the conn property 
// of the 1st node of the subpath
//
// input: p, read-only
// return: an array of subpath; the "&&" connectors, if any, will be removed from the return
//
// e.g. a test case: z0..z1--z2..z3&&z3..z4--z5
//
//   var g=[[0,0],[1,1],[2,2],[3,3],[3,3],[4,4],[5,5]];
//   g[1].conn = "--";
//   g[3].conn = "&&";
//   g[5].conn = "--";
//
// it should returns:
// - z0..z1
// - z2..z3
// - z3..z4
// - z4--z5
// if the path is cyclic:
//   if z5.conn is free (default): prepend z5 to the first free curve (so it becomes z5..z0..z1)
//   if z5.conn is straight: append z0 to the last straight line (so it becomes z4--z5--z0)
function divideOnePath(P) {
    var p=cloneOnePath(P);
    var mysplice=[], subs=[];  // array of array
    var i, sub = [];  // the current subpath
    var pre_conn, cur_conn;

    // making sure each node has a connector property
    for (i = 0; i < p.length; i ++) {
        p[i].conn = p[i].conn || jh.conn.FREE_CURVE;
    }

    //
    // first remove all "&&", to build mysplice[]
    //
    sub = [];
    for (i = 0; i < p.length; i ++) {
        if (p[i].conn === MY_SPLICE){
            p[i].conn = jh.conn.FREE_CURVE; // change it to default connector
            sub.push(p[i]);
            mysplice.push(sub);
            sub = [];
        } else {
            sub.push(p[i]);
        }
    }

    if (sub.length != 0) {
        mysplice.push(sub);
    }

    // 
    // for each mysplice: connectors now can be either STRAIGHT_LINE or FREE_CURVE
    // split straight line and curve into different subpaths, i.e., into subs[]
    //
    subs=[];
    mysplice.map(function(sp){
        sub=[];
        sub.push(sp[0]);
        pre_conn = sp[0].conn;
        for (i = 1; i < sp.length; i ++) {
            cur_conn = sp[i].conn;
            if (pre_conn === cur_conn) {
                sub.push(sp[i]);
            } else {
                // previous subpath ends
                sub.push(sp[i]);
                subs.push(sub);
                // start a new subpath with the current node
                sub = [];
                sub.push(sp[i]);
                pre_conn = cur_conn;
            }
        }

        if (sub.length > 0) {
            subs.push(sub);
        }
    });

    //
    // now each subpath in subs[] is either straight line or free curve (i.e., not mixed), 
    // in order of the original path;
    // the conn of the 1st node of each subpath tells if it's a straight line or a curve
    // 
    
    // handle the last node for cyclic path
    if (p.cyclic) {
        if(p[p.length-1].conn === jh.conn.STRAIGHT_LINE || p[0].conn === jh.conn.STRAIGHT_LINE) {
            subs[subs.length-1].push(p[0]);
        } else { 
            if (subs.length > 1) {
                // concat two free curves into one: prepend last subpath into the 1st subpath
                subs[subs.length-1].reverse().map(function(n){subs[0].unshift(n);});
                // remove the last subpath
                subs.pop();
            }
        }

        // this is to draw cyclic curve in Canvas
        if (subs.length == 1) {
            subs[0].cyclic = true;
        }
    }

    return subs;
}



//
// draw polygon (thiner) on top of bezier (thicker)
// 
function drawOnePath(P) {

    var subs = divideOnePath(P);
    subs.map(function(x){
        if (x[0].conn === jh.conn.STRAIGHT_LINE) {
            drawStraightPath(x);
        } else {
            drawFreePath(x);
        }
    });
}

function dotAllNodes() {
    function _dot(x, y) {
        // dot
        ctx.beginPath(); 
        ctx.arc(x, y, DOT_RADIUS, 0, Math.PI*2, true); 
        ctx.fillStyle = DOT_FILL_STYLE; 
        ctx.fill();

        // cursor
        ctx.beginPath();
        ctx.lineWidth = CURSUR_LINE_WIDTH;
        ctx.strokeStyle = CURSUR_STROKE_STYLE;
        ctx.moveTo(x-CURSUR_SIZE, y);
        ctx.lineTo(x+CURSUR_SIZE, y);
        ctx.moveTo(x, y-CURSUR_SIZE);
        ctx.lineTo(x, y+CURSUR_SIZE);
        ctx.stroke();
    }

    function _dotPath(p) {
        p.map(function(k){return _dot(k[0], k[1]);});
    }

    g_result.map(function(p){return _dotPath(p);});
    _dotPath(g_current_guide);
}

function redrawCanvas (){
//    console.log("redrawCanvas...");
    ctx.clearRect(0, 0, c.width, c.height);
    drawImageAndGrid();
    g_result.map(function(x){return drawOnePath(x);});
    drawOnePath(g_current_guide);
    dotAllNodes();
}

function handleFocus(e) {
    if(e.type == 'mouseover'){
        //console.log("mouseover");
        c.focus();
        return false;
    }else if(e.type == 'mouseout'){
        c.blur();
        return false;
    }
    return true;
};

function handleKeyDown(e) {
    console.log("key down:" + e.keyCode);

    if (!g_current_guide_started) {
        return true;
    }

    var key_id = e.keyCode || e.which;

    // todo: simulate mouse move event, pixel by pixel
    if (key_id === LEFT_KEY) {
    } else if (key_id === RIGHT_KEY) {
    } else if (key_id === UP_KEY) {
    } else if (key_id === DOWN_KEY) {
    } else if (key_id === ENTER_KEY) {
        // todo: simulate the click event
    } else {
        return true;
    }

    return false;
};


function onLoad() {

    c = document.getElementById("myCanvas");

    c.width = CANVAS_WIDTH;
    c.height = CANVAS_HEIGHT;

    // event hooks
    c.onclick = onClick;
    c.ondblclick = onDoubleClick;
    c.oncontextmenu = onRightClick;
    c.onmousemove = onMouseMove;  // note that this is a closure
    c.onmousewheel = onMouseWheel;
    c.onmouseleave = onMouseLeave;
    c.addEventListener('mouseover',handleFocus,false);
    c.addEventListener('mouseout',handleFocus,false);
    c.addEventListener('keydown',handleKeyDown,false);



    ctx = c.getContext('2d');

    drawImageAndGrid();

    // set button callbacks
    start_btn = document.getElementById("startPath");
    stop_btn = document.getElementById("stopPath");
    undo_btn = document.getElementById("undoPoint");
    cycle_btn = document.getElementById("cyclePath");
    buildcycle_btn = document.getElementById("buildCycle");

//    free_btn = document.getElementById("connFree");
    mysplice_btn = document.getElementById("connMySplice");
    straight_btn = document.getElementById("connStraight");

    start_btn.onclick = startPath;
    stop_btn.onclick = stopPath;
    undo_btn.onclick = undoPoint;
    cycle_btn.onclick = cyclePath;
    buildcycle_btn.onclick = buildCycle;

//    free_btn.onclick = onFreeConn;
    mysplice_btn.onclick = onMySpliceConn;
    straight_btn.onclick = onStraightConn;
}


window.onload = onLoad;
</script>
    </head>
    <body>
    <div id="div1" style="float: left;">
    <canvas id="myCanvas" width="100" height="512" tabindex="0" style="border:2px solid green;"></canvas>
    </div>
    <div id="div2" style="float: left;">
    <form>
    <input id="startPath" type="button" value="Start Path"/>
    <input id="undoPoint" type="button" value="Undo Point"/>
    <input id="stopPath" type="button" value="End Path"/>
    <input id="cyclePath" type="button" value="Cycle Path"/>
    <input id="buildCycle" type="button" value="buildcycle()"/>
    

    <!--input id="connFree" type="button" value=".."/>  --> <!-- default connection type -->
    <input id="connMySplice" type="button" value="&&"/>
    <input id="connStraight" type="button" value="--"/>
    </form>
    <br>
    <textarea id="g_current_guide" rows="50" cols="50"></textarea>
    <textarea id="g_result" rows="50" cols="50"></textarea>
    </div>
    </body>
    </html>
