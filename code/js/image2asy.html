    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <style type="text/css">
    body {
        margin: 0px;
        padding: 0px;
    }
</style>
    <script type="text/javascript" src="jh1986.js"></script>
    <script type="text/javascript">


/* 
 * todos:
 * 
 * + support cyclic guide
 * + output coordinates in normal y direction (up): canvas y is down, asy y is up;
 * - add button to load picture from file system or url
 * - add button/check_box to display/hide the picture, if loaded
 * - add selection of the current point/path connection types
 * - make it possible to make comments for a path
 * - make it possible to specify draw/fill color for a path
 * - make it possible to manually adjust point position, at any time (by selecting the path first)
 * + make it possible to draw cubic curves in canvas to reflect what's going to be drawn in asy
 * - make it possible to export SVG format data
 */

// constants
var CANVAS_WIDTH = 1020;
var CANVAS_HEIGHT = 1024;
var GRID_SIZE = 8;

// canvas context constants
var GRID_LINE_WIDTH = 0.2;
var GRID_STROKE_STYLE = "grey";
var POLYGON_LINE_WIDTH = 0.6;
var POLYGON_STROKE_STYLE = "red";
var BEZIER_LINE_WIDTH =2;
var BEZIER_STROKE_STYLE = "blue";

var g_result = []; // an array of array of points, representing the guides
var g_current_guide = [];  // an array of points, representing the current g_current_guide
var g_current_guide_started = false;

var img = new Image();
var c, ctx; // canvas and its context
var start_btn, stop_btn, cycle_btn, undo_btn; // buttons

img.src = "http://10.12.6.250:8080/test.png";
//img.src = "test.png";


function getCanvasPos(ctx, e) {
    var c = ctx.canvas; 

    var bb = c.getBoundingClientRect(); 

    // Translate and scale mouse event coordinates to canvas coordinates
    var x = (e.clientX-bb.left)*(c.width/bb.width);
    var y = (e.clientY-bb.top)*(c.height/bb.height);

    return [x, y];
}

// canvas hooks
function onClick(e) {
    if (g_current_guide_started === true) {
        var cur = getCanvasPos(ctx, e);
        console.log(cur);
        g_current_guide.push(cur);
        displayCurrentGuide();
        //redrawCanvas();
    }
}

function onDoubleClick(e) {
    console.log("onDoubleClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onRightClick(e) {
    console.log("onRightClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onMouseMove(e) {
    //console.log("onMouseMove: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    if (g_current_guide_started != true) {
        return;
    }

    var cur = getCanvasPos(ctx, e); // current position

    g_current_guide.push(cur);
    redrawCanvas();
    g_current_guide.pop();
}

function onMouseWheel(e) {
    console.log("onMouseWhell: dx=" + e.deltaX + ", dy=" + e.deltaY);
}

// button hooks
function startPath() {
    console.log("startPath: ");
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }
 
    // init the guide
    g_current_guide = [];
    g_current_guide.curl_begin = jh.DEFAULT_CURL_BEGIN;
    g_current_guide.curl_end = jh.DEFAULT_CURL_END;
    g_current_guide.cyclic = false;

    displayCurrentGuide();
    g_current_guide_started = true;
}

function stopPath() {
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_current_guide_started = false;

    outputResult();
    redrawCanvas();
}

// this also end the current path
function cyclePath() {
    if (g_current_guide.length > 0) {  // should be > 1?
        g_current_guide.cyclic = true;
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_current_guide_started = false;

    outputResult();
    redrawCanvas();
}

/*
 * discard the last point of the current guide
 */
function undoPath() {
    if (g_current_guide.length > 0) {
        g_current_guide.pop();
    }

    displayCurrentGuide();
}

function pointArrayToAsyGuide(g) {
    // note: change the y direction from canvas to normal: inverse the sign
    var txt = "" + g.map(function(x) { return "(" + x[0].toFixed(3) + "," + -x[1].toFixed(3) + ")"; }).join("..");
    if (g.cyclic) {
        txt = txt + "..cycle";
    }
    return txt;
}


function displayCurrentGuide() {
    var ta =  document.getElementById("g_current_guide"); // textarea
    ta.value = pointArrayToAsyGuide(g_current_guide);
}

function outputResult() {
    var ta =  document.getElementById("g_result"); // textarea
    ta.value = g_result.map(function(x){return pointArrayToAsyGuide(x);}).join(",\r");
    console.log("guide[] gg = {" + ta.value + "}");
}


function drawImageAndGrid() {
    /*
     * draw the image, scale within the canvas size, as much as possible, but also keep the aspect ratio
     */
    var img_ar = img.width / img.height;  // image aspect ratio
    var can_ar = CANVAS_WIDTH / CANVAS_HEIGHT; // canvas aspect ratio

    if(can_ar >= img_ar) {
        ctx.drawImage(img, 0, 0, c.height * img_ar, c.height);
    } else {
        ctx.drawImage(img, 0, 0, c.width, c.width / img_ar);
    }
    

    // draw the grid
    ctx.lineWidth = GRID_LINE_WIDTH;
    ctx.strokeStyle = GRID_STROKE_STYLE;

    // horizontal lines
    for (var i = 0;i <= c.width / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(0, i * GRID_SIZE);
	ctx.lineTo(c.width, i * GRID_SIZE);
	ctx.stroke();
    }
    
    // vertical lines
    for (var i = 0; i <= c.height / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(i * GRID_SIZE, 0);
	ctx.lineTo(i * GRID_SIZE, c.height);
	ctx.stroke();
    }
}

function drawOnePath(p) {

    //
    // draw polygons
    //
    if (p.length < 1) {
        return;
    }

    ctx.lineWidth = POLYGON_LINE_WIDTH;
    ctx.strokeStyle = POLYGON_STROKE_STYLE;
    ctx.beginPath();
    ctx.moveTo(p[0][0], p[0][1]);
    for(j = 1; j < p.length; j ++) {
        ctx.lineTo(p[j][0], p[j][1]);
    }
    if (p.cyclic) {
        ctx.closePath();
    }
    ctx.stroke();

    //
    // draw bezier
    //
    var u, v;

    if (p.length < 2) {
        return;
    }

    // get the control points
    jh.solve_angles(p);
    jh.find_control_points(p);

    ctx.lineWidth = BEZIER_LINE_WIDTH;
    ctx.strokeStyle = BEZIER_STROKE_STYLE;
    ctx.beginPath();
    ctx.moveTo(p[0][0], p[0][1]);
    u = p[0].u;
    for(j = 1; j < p.length; j ++) {
        v = p[j].v;
        ctx.bezierCurveTo(u[0], u[1], v[0], v[1], p[j][0], p[j][1]);
        u = p[j].u;
    }
    if (p.cyclic) {
        v = p[0].v;
        ctx.bezierCurveTo(u[0], u[1], v[0], v[1], p[0][0], p[0][1]);
        ctx.closePath();
    }
    ctx.stroke();
}

function redrawCanvas (){
    console.log("redrawCanvas...");
    ctx.clearRect(0, 0, c.width, c.height);
    drawImageAndGrid();
    g_result.map(function(x){return drawOnePath(x);});
    drawOnePath(g_current_guide);
}

function onLoad() {

    c = document.getElementById("myCanvas");

    c.width = CANVAS_WIDTH;
    c.height = CANVAS_HEIGHT;

    // event hooks
    c.onclick = onClick;
    c.ondblclick = onDoubleClick;
    c.oncontextmenu = onRightClick;
    c.onmousemove = onMouseMove;
    c.onmousewheel = onMouseWheel;

    ctx = c.getContext('2d');

    drawImageAndGrid();

    // set button callbacks
    start_btn = document.getElementById("startPath");
    stop_btn = document.getElementById("stopPath");
    undo_btn = document.getElementById("undoPath");
    cycle_btn = document.getElementById("cyclePath");

    start_btn.onclick = startPath;
    stop_btn.onclick = stopPath;
    undo_btn.onclick = undoPath;
    cycle_btn.onclick = cyclePath;

}


window.onload = onLoad;
</script>
    </head>
    <body>
    <div id="div1" style="float: left;">
    <canvas id="myCanvas" width="100" height="512" style="border:2px solid green;"></canvas>
    </div>
    <div id="div2" style="float: left;">
    <form>
    <input id="startPath" type="button" value="Start Path"/>
    <input id="undoPath" type="button" value="Undo Path"/>
    <input id="stopPath" type="button" value="Stop Path"/>
    <input id="cyclePath" type="button" value="Stop Cyclic Path"/>
    </form>
    <br>
    <textarea id="g_current_guide" rows="50" cols="50"></textarea>
    <textarea id="g_result" rows="50" cols="50"></textarea>
    </div>
    </body>
    </html>
