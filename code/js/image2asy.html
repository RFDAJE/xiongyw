    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <style type="text/css">
    body {
        margin: 0px;
        padding: 0px;
    }
</style>
    <script type="text/javascript" src="jh1986.js"></script>
    <script type="text/javascript">


/* 
 * todos:
 * 
 * + support cyclic guide
 * - output coordinates in normal y direction (up): canvas y is down, asy y is up;
 * - add button to load picture from file system or url
 * - add button/check_box to display/hide the picture, if loaded
 * - add selection of the current point/path connection types
 * - add logic to produce mutliple paths (path[])
 * - make it possible to make comments for a path
 * - make it possible to specify draw/fill color for a path
 * - make it possible to manually adjust point position, at any time (by selecting the path first)
 * - make it possible to draw cubic curves in canvas to reflect what's going to be drawn in asy
 * - make it possible to export SVG format data
 */

// constants
var CANVAS_WIDTH = 1020;
var CANVAS_HEIGHT = 1024;
var GRID_SIZE = 8;

var g_result = []; // an array of array of points, representing the guides
var g_current_guide = [];  // an array of points, representing the current g_current_guide
var g_last_point = []; // the last point in the current g_current_guide
var g_current_guide_started = false;

var img = new Image();
var c, ctx; // canvas and its context
var start_btn, stop_btn, cycle_btn, undo_btn; // buttons

//img.src = "http://10.12.2.225:8080/test.png";
//img.src = "test.png";


function getCanvasPos(ctx, e) {
    var c = ctx.canvas; 

    var bb = c.getBoundingClientRect(); 

    // Translate and scale mouse event coordinates to canvas coordinates
    var x = (e.clientX-bb.left)*(c.width/bb.width);
    var y = (e.clientY-bb.top)*(c.height/bb.height);

    return [x, y];
}

// canvas hooks
function onClick(e) {
    //console.log("onClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    //console.log(g_result);
    if (g_current_guide_started === true) {
        g_last_point = getCanvasPos(ctx, e);
        // set some default properties
        g_last_point.alpha = jh.DEFAULT_ALPHA;
        g_last_point.beta = jh.DEFAULT_BETA;
        g_last_point.theta = 0;
        g_last_point.phi = 0;
        g_last_point.d_ant = 0;
        g_last_point.d_post = 0;

        // add the point to the current guide/path
        g_current_guide.push(g_last_point);
    }

    displayCurrentGuide();
    drawResult();
}

function onDoubleClick(e) {
    //console.log("onDoubleClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onRightClick(e) {
    console.log("onRightClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onMouseMove(e) {
    //console.log("onMouseMove: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    var cur = getCanvasPos(ctx, e); // current position
    drawResult();
    if(g_last_point.length > 0) {
            ctx.beginPath();
            ctx.moveTo(g_last_point[0], g_last_point[1]);
            ctx.lineTo(cur[0], cur[1]);
            ctx.stroke();
    }
}

function onMouseWheel(e) {
    console.log("onMouseWhell: dx=" + e.deltaX + ", dy=" + e.deltaY);
}

// button hooks
function startPath() {
    console.log("startPath: ");
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }
 
    // init the guide
    g_current_guide = [];
    g_current_guide.curl_begin = jh.DEFAULT_CURL_BEGIN;
    g_current_guide.curl_end = jh.DEFAULT_CURL_END;
    g_current_guide.cyclic = false;

    g_last_point = [];

    displayCurrentGuide();
    g_current_guide_started = true;
}

function stopPath() {
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_last_point = [];
    g_current_guide_started = false;

    outputResult();
    drawResult();
}

// this also end the current path
function cyclePath() {
    if (g_current_guide.length > 0) {  // should be > 1?
        g_current_guide.cyclic = true;
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_last_point = [];
    g_current_guide_started = false;

    outputResult();
    drawResult();
}

/*
 * discard the last point of the current guide
 */
function undoPath() {
    if (g_current_guide.length > 0) {
        g_current_guide.pop();
    }
    if (g_current_guide.length > 0) {
        g_last_point = g_current_guide[g_current_guide.length - 1];
    } else {
        g_last_point = [];
    }
    displayCurrentGuide();
}

function pointArrayToAsyGuide(g) {
    // note: change the y direction from canvas to normal: inverse the sign
    var txt = "" + g.map(function(x) { return "(" + x[0].toFixed(3) + "," + -x[1].toFixed(3) + ")"; }).join("..");
    if (g.cyclic) {
        txt = txt + "..cycle";
    }
    return txt;
}


function displayCurrentGuide() {
    var ta =  document.getElementById("g_current_guide"); // textarea
    ta.value = pointArrayToAsyGuide(g_current_guide);
}

function outputResult() {
    var ta =  document.getElementById("g_result"); // textarea
    ta.value = g_result.map(function(x){return pointArrayToAsyGuide(x);}).join(",\r");
    console.log("guide[] gg = {" + ta.value + "}");
}


function drawImageAndGrid() {
    /*
     * draw the image, scale within the canvas size, as much as possible, but also keep the aspect ratio
     */
    var img_ar = img.width / img.height;  // image aspect ratio
    var can_ar = CANVAS_WIDTH / CANVAS_HEIGHT; // canvas aspect ratio

    if(can_ar >= img_ar) {
        ctx.drawImage(img, 0, 0, c.height * img_ar, c.height);
    } else {
        ctx.drawImage(img, 0, 0, c.width, c.width / img_ar);
    }
    

    // draw the grid
    ctx.lineWidth = 0.2;
    ctx.strokeStyle = "grey";

    // horizontal lines
    for (var i = 0;i <= c.width / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(0, i * GRID_SIZE);
	ctx.lineTo(c.width, i * GRID_SIZE);
	ctx.stroke();
    }
    
    // vertical lines
    for (var i = 0; i <= c.height / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(i * GRID_SIZE, 0);
	ctx.lineTo(i * GRID_SIZE, c.height);
	ctx.stroke();
    }
}

function drawResult(){
    var i, j;

    ctx.clearRect(0, 0, c.width, c.height);

    drawImageAndGrid();


    // draw polygons
    function _for_each_path_straight(p) {
        if (p.length < 1) {
            return;
        }

        ctx.beginPath();
        ctx.moveTo(p[0][0], p[0][1]);
        for(j = 1; j < p.length; j ++) {
            ctx.lineTo(p[j][0], p[j][1]);
        }
        if (p.cyclic) {
            ctx.closePath();
        }
        ctx.stroke();
    }

    // draw bezier
    function _for_each_path_bezier(p) {
        var u, v;

        if (p.length < 2) {
            return;
        }

        // get the control points
        jh.solve_angles(p);
        jh.find_control_points(p);

        ctx.beginPath();
        ctx.moveTo(p[0][0], p[0][1]);
        u = p[0].u;
        for(j = 1; j < p.length; j ++) {
            v = p[j].v;
            ctx.bezierCurveTo(u[0], u[1], v[0], v[1], p[j][0], p[j][1]);
            u = p[j].u;
        }
        if (p.cyclic) {
            v = p[0].v;
            ctx.bezierCurveTo(u[0], u[1], v[0], v[1], p[0][0], p[0][1]);
            ctx.closePath();
        }
        ctx.stroke();
    }

    // straight lines
    ctx.lineWidth = 0.5;
    ctx.strokeStyle = "blue";
    for (i = 0; i < g_result.length; i ++) {
        _for_each_path_straight(g_result[i]);
    }
    _for_each_path_straight(g_current_guide);

    // bezier curves
    ctx.lineWidth = 1;
    ctx.strokeStyle = "red";
    for (i = 0; i < g_result.length; i ++) {
        _for_each_path_bezier(g_result[i]);
    }
    _for_each_path_bezier(g_current_guide);
}

function onLoad() {

    c = document.getElementById("myCanvas");

    c.width = CANVAS_WIDTH;
    c.height = CANVAS_HEIGHT;

    // event hooks
    c.onclick = onClick;
    c.ondblclick = onDoubleClick;
    c.oncontextmenu = onRightClick;
    c.onmousemove = onMouseMove;
    c.onmousewheel = onMouseWheel;

    ctx = c.getContext('2d');

    drawImageAndGrid();

    // set button callbacks
    start_btn = document.getElementById("startPath");
    stop_btn = document.getElementById("stopPath");
    undo_btn = document.getElementById("undoPath");
    cycle_btn = document.getElementById("cyclePath");

    start_btn.onclick = startPath;
    stop_btn.onclick = stopPath;
    undo_btn.onclick = undoPath;
    cycle_btn.onclick = cyclePath;

}


window.onload = onLoad;
</script>
    </head>
    <body>
    <div id="div1" style="float: left;">
    <canvas id="myCanvas" width="100" height="512" style="border:2px solid green;"></canvas>
    </div>
    <div id="div2" style="float: left;">
    <form>
    <input id="startPath" type="button" value="Start Path"/>
    <input id="undoPath" type="button" value="Undo Path"/>
    <input id="stopPath" type="button" value="Stop Path"/>
    <input id="cyclePath" type="button" value="Stop Cyclic Path"/>
    </form>
    <br>
    <textarea id="g_current_guide" rows="50" cols="50"></textarea>
    <textarea id="g_result" rows="50" cols="50"></textarea>
    </div>
    </body>
    </html>
