    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <style type="text/css">
    body {
        margin: 0px;
        padding: 0px;
    }
</style>
    <script type="text/javascript">


/* 
 * todos:
 * 
 * + support cyclic guide
 * - output coordinates in normal y direction (up): canvas y is down, asy y is up;
 * - add button to load picture from file system or url
 * - add button/check_box to display/hide the picture, if loaded
 * - add selection of the current point/path connection types
 * - add logic to produce mutliple paths (path[])
 * - make it possible to make comments for a path
 * - make it possible to specify draw/fill color for a path
 * - make it possible to manually adjust point position, at any time (by selecting the path first)
 * - make it possible to draw cubic curves in canvas to reflect what's going to be drawn in asy
 * - make it possible to export SVG format data
 */

// constants
var CANVAS_WIDTH = 1020;
var CANVAS_HEIGHT = 1024;
var GRID_SIZE = 8;

/*
 * a point is represented by a number array, which has only two elements: [x, y];
 * it can optionally contain a property "cyclic", if "cyclic" is "true", it means
 * the path/guide this point belongs to is cyclic, thus its own x and y are ignored.
 */
var g_result = []; // an array of array of points, representing the guides
var g_current_guide = [];  // an array of points, representing the current g_current_guide
var g_last_point = []; // the last point in the current g_current_guide
var g_current_guide_started = false;

var img = new Image();
var c, ctx; // canvas and its context
var start_btn, stop_btn, cycle_btn, undo_btn; // buttons

//img.src = "http://10.12.2.225:8080/test.png";
img.src = "test.png";


/*
 * velocity function f(theta, phi) from "John Hobby 1986", for metafont/metapost
 *
 * theta: departure angle (in rad) at the first point z0, relative to z1-z0
 * phi: arrival angle (in rad) at the second point z1, relative to z1-z0
 */
function mp_f(theta, phi) {
    var n = 2+Math.sqrt(2)*(Math.sin(theta)-Math.sin(phi)/16)*(Math.sin(phi)-Math.sin(theta)/16)*(Math.cos(theta)-Math.cos(phi));
    var m = 3*(1 + 0.5*(Math.sqrt(5)-1)*Math.cos(theta) + 0.5*(3-Math.sqrt(5))*Math.cos(phi));
    return n/m;
}

/*
 * return u and v in an array: [[ux,uy], [vx,vy]]
 */
function mp_uv(z0, z1, theta, phi, alpha, beta) {
    // the formula using complex numbers:
    // u = z0+exp(i*theta)*(z1-z0)*f(theta,-phi)/alpha
    // v = z1-exp(i*phi)*(z1-z0)*f(-phi,theta)/beta

    // return the complex sum
    function _sum(z0, z1) {
        return [z0[0]+z1[0], z0[1]+z1[1]];
    }

    // return the complex sub
    function _sub(z0, z1) {
        return [z0[0]-z1[0], z0[1]-z1[1]];
    }

    // return the complex production
    function _prod(z0, z1) {
        return [z0[0]*z1[0]-z0[1]*z1[1], z0[0]*z1[1]+z0[1]*z1[0]];
    }

    var l = [z1[0]-z0[0], z1[1]-z0[1]];  // l = z1-z0
    var t = [Math.cos(theta), Math.sin(theta)];  // exp(i*theta)
    var p = [Math.cos(phi), Math.sin(phi)];    // exp(i*phi)

    var u = _sum(z0, _prod(t,_prod(l,[mp_f(theta,-phi)/alpha,0])));
    var v = _sub(z1, _prod(p,_prod(l,[mp_f(-phi,theta)/beta,0])));

    return [u,v];
}

function getCanvasPos(ctx, e) {
    var c = ctx.canvas; 

    var bb = c.getBoundingClientRect(); 

    // Translate and scale mouse event coordinates to canvas coordinates
    var x = (e.clientX-bb.left)*(c.width/bb.width);
    var y = (e.clientY-bb.top)*(c.height/bb.height);

    return [x, y];
}

// canvas hooks
function onClick(e) {
    //console.log("onClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    console.log(g_result);
    if (g_current_guide_started === true) {
        //g_last_point = [e.clientX, e.clientY]; 
        g_last_point = getCanvasPos(ctx, e);
        g_current_guide.push(g_last_point);
    }
    displayCurrentGuide();

}

function onDoubleClick(e) {
    //console.log("onDoubleClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onRightClick(e) {
    console.log("onRightClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onMouseMove(e) {
    //console.log("onMouseMove: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    var cur = getCanvasPos(ctx, e); // current position
    drawResult();
    if(g_last_point.length > 0) {
            ctx.beginPath();
            ctx.moveTo(g_last_point[0], g_last_point[1]);
            ctx.lineTo(cur[0], cur[1]);
            ctx.stroke();
    }
}

function onMouseWheel(e) {
    console.log("onMouseWhell: dx=" + e.deltaX + ", dy=" + e.deltaY);
}

// button hooks
function startPath() {
    console.log("startPath: ");
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }
    g_current_guide = [];
    g_last_point = [];
    displayCurrentGuide();
    g_current_guide_started = true;
}

function stopPath() {
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_last_point = [];
    g_current_guide_started = false;

    outputResult();
    drawResult();
}

function cyclePath() {
    if (g_current_guide.length > 0) {
        g_current_guide.push({"cycle":true});
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_last_point = [];
    g_current_guide_started = false;

    outputResult();
    drawResult();
}

/*
 * discard the last point of the current guide
 */
function undoPath() {
    if (g_current_guide.length > 0) {
        g_current_guide.pop();
    }
    if (g_current_guide.length > 0) {
        g_last_point = g_current_guide[g_current_guide.length - 1];
    } else {
        g_last_point = [];
    }
    displayCurrentGuide();
}

function pointArrayToAsyGuide(g) {
    // note: change the y direction from canvas to normal: inverse the sign
    return "" + g.map(function(x) { return x.cycle? "cycle" : "(" + x[0].toFixed(3) + "," + -x[1].toFixed(3) + ")"; }).join("..");
}


function displayCurrentGuide() {
    var ta =  document.getElementById("g_current_guide"); // textarea
    ta.value = pointArrayToAsyGuide(g_current_guide);
}

function outputResult() {
    var ta =  document.getElementById("g_result"); // textarea
    ta.value = g_result.map(function(x){return pointArrayToAsyGuide(x);}).join(",\r");
    console.log("guide[] gg = {" + ta.value + "}");
}


function drawImageAndGrid() {
    /*
     * draw the image, scale within the canvas size, as much as possible, but also keep the aspect ratio
     */
    var img_ar = img.width / img.height;  // image aspect ratio
    var can_ar = CANVAS_WIDTH / CANVAS_HEIGHT; // canvas aspect ratio

    if(can_ar >= img_ar) {
        ctx.drawImage(img, 0, 0, c.height * img_ar, c.height);
    } else {
        ctx.drawImage(img, 0, 0, c.width, c.width / img_ar);
    }
    

    // draw the grid
    ctx.lineWidth = 0.2;
    ctx.strokeStyle = "grey";

    // horizontal lines
    for (var i = 0;i <= c.width / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(0, i * GRID_SIZE);
	ctx.lineTo(c.width, i * GRID_SIZE);
	ctx.stroke();
    }
    
    // vertical lines
    for (var i = 0; i <= c.height / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(i * GRID_SIZE, 0);
	ctx.lineTo(i * GRID_SIZE, c.height);
	ctx.stroke();
    }
}

function drawResult(){

    ctx.clearRect(0, 0, c.width, c.height);

    drawImageAndGrid();

    // draw lines
    ctx.lineWidth = 0.5;
    ctx.strokeStyle = "black";

    // add the current g_current_guide into the g_result
    var res_temp = JSON.parse(JSON.stringify(g_result)); // deep copy
    res_temp.push(g_current_guide);  

    for(var i = 0; i < res_temp.length; i ++) {
        for(var j = 0; j < res_temp[i].length - 1; j ++) {
            ctx.beginPath();
            ctx.moveTo(res_temp[i][j][0], res_temp[i][j][1]);
            ctx.lineTo(res_temp[i][j+1][0], res_temp[i][j+1][1]);
            ctx.stroke();
        }
    }
    res_temp = null;
}

function onLoad() {

    c = document.getElementById("myCanvas");

    c.width = CANVAS_WIDTH;
    c.height = CANVAS_HEIGHT;

    // event hooks
    c.onclick = onClick;
    c.ondblclick = onDoubleClick;
    c.oncontextmenu = onRightClick;
    c.onmousemove = onMouseMove;
    c.onmousewheel = onMouseWheel;

    ctx = c.getContext('2d');

    drawImageAndGrid();

    // set button callbacks
    start_btn = document.getElementById("startPath");
    stop_btn = document.getElementById("stopPath");
    undo_btn = document.getElementById("undoPath");
    cycle_btn = document.getElementById("cyclePath");

    start_btn.onclick = startPath;
    stop_btn.onclick = stopPath;
    undo_btn.onclick = undoPath;
    cycle_btn.onclick = cyclePath;

}


window.onload = onLoad;
</script>
    </head>
    <body>
    <div id="div1" style="float: left;">
    <canvas id="myCanvas" width="100" height="512" style="border:2px solid green;"></canvas>
    </div>
    <div id="div2" style="float: left;">
    <form>
    <input id="startPath" type="button" value="Start Path"/>
    <input id="undoPath" type="button" value="Undo Path"/>
    <input id="stopPath" type="button" value="Stop Path"/>
    <input id="cyclePath" type="button" value="Stop Cyclic Path"/>
    </form>
    <br>
    <textarea id="g_current_guide" rows="50" cols="50"></textarea>
    <textarea id="g_result" rows="50" cols="50"></textarea>
    </div>
    </body>
    </html>
