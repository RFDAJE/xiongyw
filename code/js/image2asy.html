    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <style type="text/css">
    body {
        margin: 0px;
        padding: 0px;
    }
</style>
    <script type="text/javascript">


/* 
 * todos:
 * 
 * + support cyclic guide
 * - output coordinates in normal y direction (up): canvas y is down, asy y is up;
 * - add button to load picture from file system or url
 * - add button/check_box to display/hide the picture, if loaded
 * - add selection of the current point/path connection types
 * - add logic to produce mutliple paths (path[])
 * - make it possible to make comments for a path
 * - make it possible to specify draw/fill color for a path
 * - make it possible to manually adjust point position, at any time (by selecting the path first)
 * - make it possible to draw cubic curves in canvas to reflect what's going to be drawn in asy
 * - make it possible to export SVG format data
 */

// constants
var CANVAS_WIDTH = 1020;
var CANVAS_HEIGHT = 1024;
var GRID_SIZE = 8;

/*
 * a point is represented by a number array, which has only two elements: [x,y];
 * it can optionally contain a property "cycle", if "cycle" is "true", it means:
 * - the guide this point belongs to is cyclic;
 * - its own x and y are ignored;
 * - it's the last element in the array
 */
var g_result = []; // an array of array of points, representing the guides
var g_current_guide = [];  // an array of points, representing the current g_current_guide
var g_last_point = []; // the last point in the current g_current_guide
var g_current_guide_started = false;

var img = new Image();
var c, ctx; // canvas and its context
var start_btn, stop_btn, cycle_btn, undo_btn; // buttons

//img.src = "http://10.12.2.225:8080/test.png";
//img.src = "test.png";


// return the complex sum
function c_sum(z0, z1) {
    return [z0[0]+z1[0], z0[1]+z1[1]];
}

// return the complex sub
function c_sub(z0, z1) {
    return [z0[0]-z1[0], z0[1]-z1[1]];
}

// return the complex production
function c_prod(z0, z1) {
    return [z0[0]*z1[0]-z0[1]*z1[1], z0[0]*z1[1]+z0[1]*z1[0]];
}

// return the length of the vector
function c_mod(z) {
    return Math.sqrt(z[0]*z[0] + z[1]*z[1]);
}

// return the angle (in rad) of a vector
function c_arg(z) {
    if (z[0] == 0) {
        if (z[1] > 0) {
            return Math.PI/2;
        } else if (z[1] < 0) {
            return -Math.PI/2;
        } else {
            return 0; // ?
        }
    } else {
        return Math.atan(z[1]/z[0]);
    }
}

/*
 * velocity function f(theta, phi) from "John Hobby 1986", for metafont/metapost
 *
 * theta: departure angle (in rad) at the first point z0, relative to z1-z0
 * phi: arrival angle (in rad) at the second point z1, relative to z1-z0
 */
function mp_f(theta, phi) {
    var n = 2+Math.sqrt(2)*(Math.sin(theta)-Math.sin(phi)/16)*(Math.sin(phi)-Math.sin(theta)/16)*(Math.cos(theta)-Math.cos(phi));
    var m = 3*(1 + 0.5*(Math.sqrt(5)-1)*Math.cos(theta) + 0.5*(3-Math.sqrt(5))*Math.cos(phi));
    return n/m;
}

/*
 * return u and v in an array: [[ux,uy], [vx,vy]]
 */
function mp_uv(z0, z1, theta, phi, alpha, beta) {
    // the formula using complex numbers:
    // u = z0+exp(i*theta)*(z1-z0)*f(theta,-phi)/alpha
    // v = z1-exp(i*phi)*(z1-z0)*f(-phi,theta)/beta

    var l = [z1[0]-z0[0], z1[1]-z0[1]];  // l = z1-z0
    var t = [Math.cos(theta), Math.sin(theta)];  // exp(i*theta)
    var p = [Math.cos(phi), Math.sin(phi)];    // exp(i*phi)

    var u = c_sum(z0, c_prod(t,c_prod(l,[mp_f(theta,-phi)/alpha,0])));
    var v = c_sub(z1, c_prod(p,c_prod(l,[mp_f(-phi,theta)/beta,0])));

    return [u,v];
}

/*
 * http://en.wikipedia.org/wiki/Gaussian_elimination
 *
 * A: matrix (an array of array, mxn, i.e. m rows and n columns)
 * b: vector (mx1)
 * m,n: size of the matrix
 * return: x, a vector (array of m elements)
 *
 * sample usage:
 *
 * var A=[[2,1,-1],[-3,-1,2],[-2,1,2]];
 * var b=[8,-11,-3];
 * var x=mp_solve_matrix(A,b,3,3);
 *
 * then: x=[2, 3, -0.9999999999999999];
 */
function mp_solve_matrix(A, b, m, n) {
    var i, j, k, u, maxi, tmp, pivot, sum;
    var M = [], x = [];

    // deep copy A and b into M as combined
    for (i = 0; i < m; i ++) {
        var row = [];
        for (j = 0; j < n; j ++) {
            row.push(A[i][j]);
        }
        row.push(b[i]);
        M.push(row);
    }

    /*
     * elimination 
     */
    i = 0;  // row 
    j = 0;  // col
    while (i < m && j < n) {
        // find pivot (i.e. its row index) in col j, starting from row i
        maxi = i;  // idx of the row whose column j is the max
        for (k = i+1; k < m; k ++) {
            if (Math.abs(M[k][j]) > Math.abs(M[maxi][j])) {
                maxi = k;
            }
        }

        if (M[maxi][j] != 0) {
            // swap row maxi and i
            if (maxi != i) { 
                tmp = M[maxi];
                M[maxi] = M[i];
                M[i] = tmp;
            }
            pivot = M[i][j];

            // divide i row by the pivot
            for (k = 0; k < n + 1; k ++) {
                M[i][k] = M[i][k] / pivot;
            }
            // now the pivot M[i][j] = 1

            // substract M[u][j] * row i from row u 
            for (u = i+1; u < m; u ++) {
                pivot = M[u][j];
                for (k = 0; k < n + 1; k ++) {
                    M[u][k] = M[u][k] - M[i][k] * pivot;
                }
            }
            i = i + 1;
        }
        j = j +1;
    }

    /* 
     * get the results
     */
    if (m == n) {
        x[m-1] = M[m-1][m];
        for (i = m-2; i >=0; i --) {
            sum = 0;
            for (j = i+1; j < m; j ++) {
                sum = sum + M[i][j] * x[j];
            }
            x[i] = M[i][m] - sum;
        }
    }

    return x;
}

/*
 * the following routines are "cloned" from the original python code:
 * http://tex.stackexchange.com/questions/54771/curve-through-a-sequence-of-points-with-metapost-and-tikz
 */

/* 
 * traverses the guide and computes the distance between adjacent points, and the 
 * turning angles of the polyline which joins them
 *
 * g: an array of points (which forms an asymptote guide)
 * output: none. but following properties of each point g[k] (treated as a complex number here) is added or updated:
 *  "d_ant": |g[k]-g[k-1]|
 *  "d_post": |g[k+1]-g[k]|
 *  "xi": turning angle at g[k], in rad: arg((g[k+1]-g[k])/(g[k]-g[k-1]))
 */
function mp_compute_distances_and_angles(g) {

    var i = 0, l_post, l_ant, arg_post, arg_ant; 
    var cyclic = g[g.length-1].cycle? true: false;
    var n = g.length - (cyclic? 1: 0); // number of nodes
    
    if (n < 2) {
        return;
    }
    
    // middle nodes
    for (i = 1; i < n-1; i ++) {
        l_post = c_sub(g[i+1], g[i]);
        l_ant = c_sub(g[i], g[i-1]);
        arg_post = c_arg(l_post);
        arg_ant = c_arg(l_ant);

        g[i].d_post = c_mod(l_post);
        g[i].d_ant = c_mod(l_ant);
        g[i].xi = arg_post - arg_ant;
    }

    // first/last node: what if Javascript supports cyclic array!!!
    if (cyclic) {
        // first node
        l_post = c_sub(g[1], g[0])
        l_ant = c_sub(g[0], g[n-1]);
        arg_post = c_arg(l_post);
        arg_ant = c_arg(l_ant);

        g[0].d_ant = c_mod(l_ant);
        g[0].d_post = c_mod(l_post);
        g[0].xi = arg_post - arg_ant;

        // last node
        l_post = c_sub(g[0], g[n-1])
        l_ant = c_sub(g[n-1], g[n-2]);
        arg_post = c_arg(l_post);
        arg_ant = c_arg(l_ant);

        g[n-1].d_ant = c_mod(l_ant);
        g[n-1].d_post = c_mod(l_post);
        g[n-1].xi = arg_post - arg_ant;
    } else {
        // first node
        g[0].d_ant = 0;
        g[0].d_post = c_mod(c_sub(g[1], g[0]));
        g[0].xi = 0;
        // last node
        g[n-1].d_ant = c_mod(c_sub(g[n-1], g[n-2]));
        g[n-1].d_post = 0;
        g[n-1].xi = 0;
    }
}

/*
 * This function creates five vectors which are coefficients of a
 * linear system which allows finding the right values of "theta" at
 * each point of the path (being "theta" the angle of departure of the
 * path at each point). The theory is from METAFONT book."""
 */
/*
function build_coefficients(g) {
    A=[];  B=[];  C=[];  D=[];   R=[]
    pre_compute_distances_and_angles(path)
    if not path.cyclic:
        # In this case, first equation doesnt follow the general rule
        A.append(0)
        B.append(0)
        curl = path.curl_begin
        alpha_0 = path[0].alpha
        beta_1 = path[1].beta
        xi_0 = (alpha_0**2) * curl / (beta_1**2)
        xi_1 = path[1].xi
        C.append(xi_0*alpha_0 + 3 - beta_1)
        D.append((3 - alpha_0)*xi_0 + beta_1)
        R.append(-D[0]*xi_1)

    # Equations 1 to n-1 (or 0 to n for cyclic paths)
    for k in path.range():
        A.append(   path[k-1].alpha  / ((path[k].beta**2)  * path[k].d_ant))
        B.append((3-path[k-1].alpha) / ((path[k].beta**2)  * path[k].d_ant))
        C.append((3-path[k+1].beta)  / ((path[k].alpha**2) * path[k].d_post))
        D.append(   path[k+1].beta   / ((path[k].alpha**2) * path[k].d_post))
        R.append(-B[k] * path[k].xi  - D[k] * path[k+1].xi)

    if not path.cyclic:
        # The last equation doesnt follow the general form
        n = len(R)     # index to generate
        C.append(0)
        D.append(0)
        curl = path.curl_end
        beta_n = path[n].beta
        alpha_n_1 = path[n-1].alpha
        xi_n = (beta_n**2) * curl / (alpha_n_1**2)
        A.append((3-beta_n)*xi_n + alpha_n_1)
        B.append(beta_n*xi_n + 3 - alpha_n_1)
        R.append(0)
    return (A, B, C, D, R)
}

function mp_solve_for_thetas(A, B, C, D, R) {
    """This function receives the five vectors created by
    build_coefficients() and uses them to build a linear system with N
    unknonws (being N the number of points in the path). Solving the system
    finds the value for theta (departure angle) at each point"""
    L=len(R)
    a = np.zeros((L, L))
    for k in range(L):
       prev = (k-1)%L
       post = (k+1)%L
       a[k][prev] = A[k]
       a[k][k]    = B[k]+C[k]
       a[k][post] = D[k]
    b = np.array(R)
    return np.linalg.solve(a,b)
}

function mp_solve_angles(g) {
    """This function receives a path in which each point is "open", i.e. it
    does not specify any direction of departure or arrival at each node,
    and finds these directions in such a way which minimizes "mock
    curvature". The theory is from METAFONT book."""

    # Basically it solves
    # a linear system which finds all departure angles (theta), and from
    # these and the turning angles at each point, the arrival angles (phi)
    # can be obtained, since theta + phi + xi = 0  at each knot"""
    x = solve_for_thetas(*build_coefficients(path))
    L = len(path)
    for k in range(L):
        path[k].theta = x[k]
    for k in range(L):
        path[k].phi = - path[k].theta - path[k].xi
}

function mp_find_controls(g) {
    """This function receives a path in which, for each point, the values
    of theta and phi (leave and enter directions) are known, either because
    they were previously stored in the structure, or because it was
    computed by function solve_angles(). From this path description
    this function computes the control points for each knot and stores
    it in the path. After this, it is possible to print path to get
    a string suitable to be feed to tikz."""
    r = []
    for k in range(len(path)):
        z0 = path[k].z
        z1 = path[k+1].z
        theta = path[k].theta
        phi = path[k+1].phi
        alpha = path[k].alpha
        beta = path[k+1].beta
        u,v=control_points(z0, z1, theta, phi, alpha, beta)
        path[k].u_right = u
        path[k+1].v_left = v
}
*/

function getCanvasPos(ctx, e) {
    var c = ctx.canvas; 

    var bb = c.getBoundingClientRect(); 

    // Translate and scale mouse event coordinates to canvas coordinates
    var x = (e.clientX-bb.left)*(c.width/bb.width);
    var y = (e.clientY-bb.top)*(c.height/bb.height);

    return [x, y];
}

// canvas hooks
function onClick(e) {
    //console.log("onClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    console.log(g_result);
    if (g_current_guide_started === true) {
        //g_last_point = [e.clientX, e.clientY]; 
        g_last_point = getCanvasPos(ctx, e);
        g_current_guide.push(g_last_point);
    }
    displayCurrentGuide();

}

function onDoubleClick(e) {
    //console.log("onDoubleClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onRightClick(e) {
    console.log("onRightClick: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
}

function onMouseMove(e) {
    //console.log("onMouseMove: x=" + e.clientX + ", y=" + e.clientY + ", detail=" + e.detail);
    var cur = getCanvasPos(ctx, e); // current position
    drawResult();
    if(g_last_point.length > 0) {
            ctx.beginPath();
            ctx.moveTo(g_last_point[0], g_last_point[1]);
            ctx.lineTo(cur[0], cur[1]);
            ctx.stroke();
    }
}

function onMouseWheel(e) {
    console.log("onMouseWhell: dx=" + e.deltaX + ", dy=" + e.deltaY);
}

// button hooks
function startPath() {
    console.log("startPath: ");
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }
    g_current_guide = [];
    g_last_point = [];
    displayCurrentGuide();
    g_current_guide_started = true;
}

function stopPath() {
    if (g_current_guide.length > 0) {
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_last_point = [];
    g_current_guide_started = false;

    outputResult();
    drawResult();
}

function cyclePath() {
    if (g_current_guide.length > 0) {
        g_current_guide.push({"cycle":true});
        g_result.push(g_current_guide);
    }

    g_current_guide = [];
    g_last_point = [];
    g_current_guide_started = false;

    outputResult();
    drawResult();
}

/*
 * discard the last point of the current guide
 */
function undoPath() {
    if (g_current_guide.length > 0) {
        g_current_guide.pop();
    }
    if (g_current_guide.length > 0) {
        g_last_point = g_current_guide[g_current_guide.length - 1];
    } else {
        g_last_point = [];
    }
    displayCurrentGuide();
}

function pointArrayToAsyGuide(g) {
    // note: change the y direction from canvas to normal: inverse the sign
    return "" + g.map(function(x) { return x.cycle? "cycle" : "(" + x[0].toFixed(3) + "," + -x[1].toFixed(3) + ")"; }).join("..");
}


function displayCurrentGuide() {
    var ta =  document.getElementById("g_current_guide"); // textarea
    ta.value = pointArrayToAsyGuide(g_current_guide);
}

function outputResult() {
    var ta =  document.getElementById("g_result"); // textarea
    ta.value = g_result.map(function(x){return pointArrayToAsyGuide(x);}).join(",\r");
    console.log("guide[] gg = {" + ta.value + "}");
}


function drawImageAndGrid() {
    /*
     * draw the image, scale within the canvas size, as much as possible, but also keep the aspect ratio
     */
    var img_ar = img.width / img.height;  // image aspect ratio
    var can_ar = CANVAS_WIDTH / CANVAS_HEIGHT; // canvas aspect ratio

    if(can_ar >= img_ar) {
        ctx.drawImage(img, 0, 0, c.height * img_ar, c.height);
    } else {
        ctx.drawImage(img, 0, 0, c.width, c.width / img_ar);
    }
    

    // draw the grid
    ctx.lineWidth = 0.2;
    ctx.strokeStyle = "grey";

    // horizontal lines
    for (var i = 0;i <= c.width / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(0, i * GRID_SIZE);
	ctx.lineTo(c.width, i * GRID_SIZE);
	ctx.stroke();
    }
    
    // vertical lines
    for (var i = 0; i <= c.height / GRID_SIZE; i ++){
	ctx.beginPath();
	ctx.moveTo(i * GRID_SIZE, 0);
	ctx.lineTo(i * GRID_SIZE, c.height);
	ctx.stroke();
    }
}

function drawResult(){

    ctx.clearRect(0, 0, c.width, c.height);

    drawImageAndGrid();

    // draw lines
    ctx.lineWidth = 0.5;
    ctx.strokeStyle = "black";

    // add the current g_current_guide into the g_result
    var res_temp = JSON.parse(JSON.stringify(g_result)); // deep copy
    res_temp.push(g_current_guide);  

    for(var i = 0; i < res_temp.length; i ++) {
        for(var j = 0; j < res_temp[i].length - 1; j ++) {
            ctx.beginPath();
            ctx.moveTo(res_temp[i][j][0], res_temp[i][j][1]);
            ctx.lineTo(res_temp[i][j+1][0], res_temp[i][j+1][1]);
            ctx.stroke();
        }
    }
    res_temp = null;
}

function onLoad() {

    c = document.getElementById("myCanvas");

    c.width = CANVAS_WIDTH;
    c.height = CANVAS_HEIGHT;

    // event hooks
    c.onclick = onClick;
    c.ondblclick = onDoubleClick;
    c.oncontextmenu = onRightClick;
    c.onmousemove = onMouseMove;
    c.onmousewheel = onMouseWheel;

    ctx = c.getContext('2d');

    drawImageAndGrid();

    // set button callbacks
    start_btn = document.getElementById("startPath");
    stop_btn = document.getElementById("stopPath");
    undo_btn = document.getElementById("undoPath");
    cycle_btn = document.getElementById("cyclePath");

    start_btn.onclick = startPath;
    stop_btn.onclick = stopPath;
    undo_btn.onclick = undoPath;
    cycle_btn.onclick = cyclePath;

}


window.onload = onLoad;
</script>
    </head>
    <body>
    <div id="div1" style="float: left;">
    <canvas id="myCanvas" width="100" height="512" style="border:2px solid green;"></canvas>
    </div>
    <div id="div2" style="float: left;">
    <form>
    <input id="startPath" type="button" value="Start Path"/>
    <input id="undoPath" type="button" value="Undo Path"/>
    <input id="stopPath" type="button" value="Stop Path"/>
    <input id="cyclePath" type="button" value="Stop Cyclic Path"/>
    </form>
    <br>
    <textarea id="g_current_guide" rows="50" cols="50"></textarea>
    <textarea id="g_result" rows="50" cols="50"></textarea>
    </div>
    </body>
    </html>
