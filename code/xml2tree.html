    <html><head><title>xml2tree</title><style>

body {background-color: white}

table {
    border-collapse: collapse;
}

td {
    font-size: 9pt; 
    text-decoration: none;
    text-align: left;
    vertcal-align: middle;
    white-space:nowrap;
    padding: 0px;
}


.icon {
height: 16px;
width: 16px;
background-image:url('./images/sprite16.png');
}

.nodeplus      { background-position:    0px    0px; }
.nodeminus     { background-position:  -16px    0px; }
.node          { background-position:  -32px    0px; }
.nodepluslast  { background-position:  -48px    0px; }
.nodeminuslast { background-position:  -64px    0px; }
.nodelast      { background-position:  -80px    0px; }
.vertical      { background-position:  -96px    0px; }
.blank         { background-position: -112px    0px; }

.folder        { background-position:    0px  -16px; }
.file1         { background-position:  -16px  -16px; }
.file2         { background-position:  -32px  -16px; }
.cube1         { background-position:  -48px  -16px; }
.cube2         { background-position:  -64px  -16px; }
.packets       { background-position:  -80px  -16px; }
.packet        { background-position:  -96px  -16px; }
.private       { background-position: -112px  -16px; }

.numbers       { background-position:    0px  -32px; }
.number        { background-position:  -16px  -32px; }
.otv           { background-position:  -32px  -32px; }
.dvb           { background-position:  -48px  -32px; }
.table         { background-position:  -64px  -32px; }
.program       { background-position:  -80px  -32px; }
.audio         { background-position:  -96px  -32px; }
.video         { background-position: -112px  -32px; }

.at            { background-position:    0px  -48px; }
.sharp         { background-position:  -16px  -48px; }
.braces        { background-position:  -32px  -48px; }
.brackets      { background-position:  -48px  -48px; }
.dollar        { background-position:  -64px  -48px; }
.percent       { background-position:  -80px  -48px; }
.and           { background-position:  -96px  -48px; }
.star          { background-position: -112px  -48px; }

.parens        { background-position:    0px  -64px; }
.exclaim       { background-position:  -16px  -64px; }
.plus          { background-position:  -32px  -64px; }
.minus         { background-position:  -48px  -64px; }
.bar           { background-position:  -64px  -64px; }
.slash         { background-position:  -80px  -64px; }
.backslash     { background-position:  -96px  -64px; }
.question      { background-position: -112px  -64px; }

.lt            { background-position:    0px  -80px; }
.gt            { background-position:  -16px  -80px; }
.zero          { background-position:  -32px  -80px; }
.one           { background-position:  -48px  -80px; }
.two           { background-position:  -64px  -80px; }
.three         { background-position:  -80px  -80px; }
.four          { background-position:  -96px  -80px; }
.five          { background-position: -112px  -80px; }

.six           { background-position:    0px  -96px; }
.seven         { background-position:  -16px  -96px; }
.eight         { background-position:  -32px  -96px; }
.nine          { background-position:  -48px  -96px; }

</style></head><body><script language='javascript'>


/* xml2json converter based on "http://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html"
 *
 * rewrite(bruin, 2013-11-26)
 * last updated(bruin, 2013-11-28)
 */

/* 
 * utilities 
 */

/* save typing */
function $(id){
    return window.document.getElementById(id);
}

/* is o an array? */
function arrayp(o){
    return typeof o === 'object' && Object.prototype.toString.call(o) === '[object Array]';
}

/* get unique id, also has a method for reset: uid(), uid.reset() */
var uid = (function(){
    var _id = 0;
    var fn = function(){
        return _id ++;
    }
    fn.reset = function(){ _id = 0};
    return fn;
}());

/* some constants */
var NON_SPACE = /[^ \f\n\r\t\v]/;
var SHARP_TEXT = "#text";
var SHARP_CDATA = "#cdata";

/* 
 * convert a xml text string into a normalized, white-removed dom object 
 */
function xml2dom(xml) {
    var MIME = "text/xml";
    var dom = null;
    /* recursively remove all pure white TEXT_NODE from the element, in place */
    var remove_white = function (e) {
        var node, next;
        if(!e)
            return;
        e.normalize();
        for(node = e.firstChild; node;) {
            if(node.nodeType == Node.TEXT_NODE) {
                if(!node.nodeValue.match(NON_SPACE)) {
                    next = node.nextSibling;
                    e.removeChild(node);
                    node = next;
                } else
                    node = node.nextSibling;
            } else if(node.nodeType == Node.ELEMENT_NODE) {
                remove_white(node);
                node = node.nextSibling;
            } else {
                node = node.nextSibling;
            }
        }
        return e;
    }

    if(!xml) {
        return null;
    }
    if(window.DOMParser) {
        dom = (new DOMParser()).parseFromString(xml, MIME);
    } else if(window.ActiveXObject) {
        dom = new ActiveXObject('Microsoft.XMLDOM');
        dom.async = false;
        if(!dom.loadXML(xml)) {
            window.alert(dom.parseError.reason + dom.parseError.srcText);
            dom = null;
        }
    } else {
        window.alert("Error: your browser does not support parsing XML to DOM!");
    }
    return remove_white(dom);
}


/*
 * convert the dom into a simpler js object
 */
function dom2obj(dom) {
    var o = {};
    var i, n;

    var escape = function (txt) {
        return txt.replace(/[\\]/g, "\\\\")
            .replace(/[\"]/g, '\\"')
            .replace(/[\n]/g, '\\n')
            .replace(/[\r]/g, '\\r');
    }

    var _as_xml = function (n) {
        var i, c;
        var s = "";
        if(n.nodeType == Node.ELEMENT_NODE) {
            s += "<" + n.nodeName;
            for(i = 0; i < n.attributes.length; i++) {
                s += " " + n.attributes[i].nodeName + "=\"" + (n.attributes[i].nodeValue || "").toString() + "\"";
            }
            if(n.firstChild) {
                s += ">";
                for(c = n.firstChild; c; c = c.nextSibling) {
                    s += _as_xml(c);
                }
                s += "</" + n.nodeName + ">";
            } else {
                s += "/>";
            }
        } else if(n.nodeType == Node.TEXT_NODE) {
            s += n.nodeValue;
        } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
            s += "<![CDATA[" + n.nodeValue + "]]>";
        }
        return s;
    }

    var _inner_xml = function (node) {
        if("innerHTML" in node)
            return node.innerHTML;
        var s = "";
        for(var c = node.firstChild; c; c = c.nextSibling) {
            s += _as_xml(c);
        }
        return s;
    }

    if(!dom)
        return null;
    if(dom.nodeType == Node.DOCUMENT_NODE) {
        var O = {};
        O[dom.documentElement.nodeName] = dom2obj(dom.documentElement);
        return O;
    }
    if(dom.nodeType == Node.ELEMENT_NODE) {
        if(!dom.attributes.length && !dom.firstChild) {
            return null;
        }
        // converts attributes[] into properties
        if(dom.attributes.length) {
            for(i = 0; i < dom.attributes.length; i++) {
                o["@" + dom.attributes[i].nodeName] = (dom.attributes[i].nodeValue || "").toString();
            }
        }
        if(dom.firstChild) { // element has child nodes ..
            var textChild = 0;
            var cdataChild = 0;
            var hasElementChild = false;
            for(n = dom.firstChild; n; n = n.nextSibling) {
                if(n.nodeType == Node.ELEMENT_NODE) {
                    hasElementChild = true;
                } else if(n.nodeType == Node.TEXT_NODE && n.nodeValue.match(NON_SPACE)) {
                    textChild++; // non-whitespace text
                } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
                    cdataChild++; // cdata section node
                }
            }
            if(hasElementChild) {
                if(textChild < 2 && cdataChild < 2) { // structured element with a single text or/and cdata node
                    // remove_white(dom); // why remove white again?
                    for(n = dom.firstChild; n; n = n.nextSibling) {
                        if(n.nodeType == Node.TEXT_NODE) {
                            o[SHARP_TEXT] = escape(n.nodeValue);
                        } else if(n.nodeType == Node.CDATA_SECTION_NODE) {
                            o[SHARP_CDATA] = escape(n.nodeValue);
                        } else if(o[n.nodeName]) { // multiple occurence of element ..
                            if(o[n.nodeName] instanceof Array) {
                                o[n.nodeName][o[n.nodeName].length] = dom2obj(n);
                            } else {
                                o[n.nodeName] = [o[n.nodeName], dom2obj(n)];
                            }
                        } else { // first occurence of element..
                            o[n.nodeName] = dom2obj(n);
                        }
                    }
                } else { // mixed content
                    if(!dom.attributes.length)
                        o = escape(_inner_xml(dom));
                    else
                        o[SHARP_TEXT] = escape(_inner_xml(dom));
                }
            } /* hasElementChild */
            else if(textChild) { // pure text
                if(!dom.attributes.length)
                    o = escape(_inner_xml(dom));
                else
                    o[SHARP_TEXT] = escape(_inner_xml(dom));
            } else if(cdataChild) { // cdata
                if(cdataChild > 1)
                    o = escape(_inner_xml(dom));
                else {
                    for(n = dom.firstChild; n; n = n.nextSibling)
                        o[SHARP_CDATA] = escape(n.nodeValue);
                }
            }
        }
    } else {
        window.alert("unhandled node type: " + dom.nodeType);
    }
    return o;
}

/* xml to obj */
function xml2obj(xml){
    var dom = xml2dom(xml);
    return dom2obj(dom);
}

/* xml to json string */
function xml2json(xml){
    var obj = xml2obj(xml);
    return JSON.stringify(obj, null, 4);
}


/* sanity tests */
(function () {
    var xmls = [undefined,
                null,
                "<e/>",
                "<e>text</e>",
                "<e name='value'/>",
                "<e name='value'>text</e>",
                "<e><a>text</a><b>text2</b></e>",
                "<e><a>text</a><a>text2</a></e>",
                "<e>text<a>text2</a>text3</e>",
                "<?xml version='1.0'?><e><!--comments-->text</e>"
               ];
    xmls.map(function (xml) {
        console.log(xml);
        console.log(xml2json(xml));
        console.log('--------------');
    }).join("");
}());


/**
 * created(bruin, 2003-02-01): first creation, support MSIE only
 * updated(bruin, 2004-07-08): support mozilla, cleanup code, and add code comments
 * updated(bruin, 2013-11-29): some cosmetic changes 
 *
 * notes:
 *
 Names for other types of objects depend on the id, in the following rule:

 "N" + id: the node object (eg, N128 is the node object whose id is "128"
 "D" + id: the DIV object of the node (yes, each node has a corresponding DIV)
 "J" + id: the node's joint icon image object in html document. 
 the joint icon is to represent the status of the 
 node in browser. there are 6 possible status for a node: 
 
   |          |         |         |         |        |
 +---+      +---+       |       +---+     +---+      |
 | + |--    | - |--     +----   | + |--   | - |--    +----
 +---+      +---+       |       +---+     +---+
   |          |         |         
 
 (a)        (b)       (c)       (d)       (e)       (f)
 
 (a) a closed node having kid(s)  
 (b) an opened/collapsed node having kid(s)
 (c) a leaf node having no kids
 (d) a last closed node having kid(s)
 (e) a last opened/collapsed node having kid(s)
 (f) a last leaf node having no kids
 
 Clicking on nodes cause the node to open/close, so the joint icon should also change accordingly.
*/   


/* 
 * constructor of node object: MyNode(id, desc, type, href)
 *
 * @param {string) id: an unique id of the node object to be created. 
 * @param {string} desc: text description of the node
 * @param {string} type: icon class for node type, optional
 * @param {string} href: link page, optional
 */
function MyNode(id, desc, type, href){

    /* get node name */ 
    function _node_name(){
        return "N" + this.id;
    }

    /* get the id of the corresponding DIV */
    function _div_id(){
        return "D" + this.id;
    }

    /* get the id of the corresponding DIV for joint icon */
    function _joint_id(){
        return "J" + this.id;
    }

    function _add_kid(kid){
        this.kids[this.kids.length] = kid;
        kid.dad = this;
        return kid;
    }

    /**
     * recursively set "left_code" and "lastp" properties
     * of each node in the tree. called by the root of the tree
     * after the tree structure been built
     *
     * @param {boolean} lastp: "false" if it's not the last child of its parent; otherwise "true";
     * @param {array} left_code: an array of 0/1 representing the left side icons
     * @return: nothing
     */
    function _set_left_n_last(lastp, left_code){
        var i;
        
        this.lastp = lastp;
        this.left_code = left_code.slice(0); // copy the array
        
        if(lastp){
            left_code.push(0);   
        }
        else{
            left_code.push(1);   
        }
        
        for(i = 0; i < this.kids.length; i ++){
    	    if(i == this.kids.length - 1){
                this.kids[i].set_left_n_last(true, left_code.slice(0));
            }
            else{
                this.kids[i].set_left_n_last(false, left_code.slice(0));
            }
        }
    }

    /* Generate html elements of the node. for each node, its corresponding html elements 
       could be divided into 2 parts: a one row TABLE, followed by a DIV:

       Node in html => TABLE + DIV

       The TABLE contains the following variable number of TDs (columns):
       1. left side icons: a series of blank and/or vertline icons each is a TD; none for root nodes;
       2. joint icon: one of 6 icons as described above. one TD for each node;
       3. type icon: icon representing the type of the node. one TD for each node;
       4. description text: plain text or anchored text. one TD for each node;

       The DIV element is the container of child nodes' html elements, which in turn contains a 
       list of TABLE+DIV bundle, one for each child node. DIVs can be controlled to show or hide. 
       Showing a node's DIV opens/collapses the node, while hiding the node's DIV closes the node.
    */
    function _render(){ 

        var docW = "<table><tr>";

        // 1. left side icons
        docW += this.get_left_icons();

        // 2. joint icon 
        docW += this.get_joint_icon();

        // 3. type icon
        docW += this.get_type_icon();

        // 4. desc text, xml-escaped first
        var desc = this.desc.replace(/>/g,'&gt;').replace(/</g,'&lt;').replace(/"/g,'&quot;');
        docW += "<td>&nbsp;<code>" + desc + "</code></td></tr></table>";


	// 5. div object: only needed for non-leaf nodes
        if(this.kids.length > 0){
            docW += "<div id='D" + this.id + "'></div>";
        }
        
        return docW;
    } 

    /* toggle betw. open & close of the node
     */
    function _onclick(){
        var div = $(this.div_id());
        if(!div)  return;
        if(!div.innerHTML){
    	    var kids = [];
    	    for(var i = 0; i < this.kids.length; i ++){
    		kids[i] = this.kids[i].render();
	    }
	    div.innerHTML = kids.join('');
        }

        // toggle visibility of its kids
        if(this.openp == false){
    	    div.style.display = "block";
    	    this.openp = true;
        }
        else{
            div.style.display = "none";
            this.openp = false;
        }
        
        // update the joint icon in the joint DIV
        var jdiv = $(this.joint_id());
        if(jdiv){
            jdiv.className = "icon " + this.get_joint_icon_class();    
        }
    }

    /* get left side icons of a node (componsed by blank and vertline) */ 
    function _get_left_icons(){
        var left_code = this.left_code.slice(1);
        return left_code.map(function(v){ 
            return "<td><div class='icon " + (v == 1? "vertical" : "blank") + "'/></td>";}).join('');
    }

    function _get_joint_icon_class(){
        if(this.dad == null){
            return "";  // no joint icon for root node
        }
        else{
            if(this.lastp){
                if(this.kids.length > 0){
                    if(this.openp)
                        return "nodeminuslast";
                    else
                        return "nodepluslast";
                }
                else{
                    return "nodelast";
                }
            }
            else{ // not last node 
                if(this.kids.length > 0){
                    if(this.openp)
                        return "nodeminus";
                    else
                        return "nodeplus";
                }
                else{
                    return "node";
                }
            }
        }
    }

    function _get_joint_icon(){
      
        if(this.dad == null){
            return "";  // no joint icon for root node
        }

        var icon = this.get_joint_icon_class();

        var href = "";
        if(this.kids.length > 0){
            href = "<a href='javascript: N" + this.id + ".onclick()'>";
        }

        return "<td>" + href + "<div id='" + this.joint_id() + "' class='icon " + icon + "'/></td>";
    }

    /* get the type icon of the node, according to its type */
    function _get_type_icon(){
        return "<td><div class='icon " + this.type + "'/></td>";
    }

    // tree's data structure
    this.dad = null;
    this.kids = [];

    // static properties assigned
    this.id = id;
    this.desc = desc;
    this.type = type || "cube1";
    this.href = href;

    // properties determined during tree_init()
    this.left_code = [];   // array element: 0 means space, 1 means vertical bar
    this.lastp = false;    // is the last kid of its parent?
    
    // dynamic properties
    this.openp = false;  // is collapsed or not? 
    
    // methods
    this.add_kid         = _add_kid;
    this.set_left_n_last = _set_left_n_last;
    this.node_name       = _node_name;
    this.div_id          = _div_id;
    this.joint_id        = _joint_id;
    this.get_joint_icon_class = _get_joint_icon_class;

    this.get_left_icons  = _get_left_icons;  
    this.get_joint_icon   = _get_joint_icon;   
    this.get_type_icon   = _get_type_icon;   

    this.render          = _render;          
    this.onclick         = _onclick;
}


/**
 * build a tree from the object: 
 * - creating(new) all nodes in global space
 * - attaching nodes to form a tree
 * - initialize misc info in all nodes
 *
 * @param {object} o: the object converted from a xml
 * @return {object}: the root node
 */
function build_tree(o){

    var root = null;

    /*
     * @param {string} name: property name
     * @parm {object or string} val: property value
     * @return: the tree of nodes
     */
    var _build_tree = function(name, val){

        var desc, node, type;

        /* description */
        if(typeof val === 'string'){
            desc = name + ": " + val;
        }
        else if(arrayp(val)){
            desc = name + ": " + val.join(",");
        }
        else{
            desc = name;
        }

        /* type */
        if(typeof val === 'object'){
            if(arrayp(val))
                type = "brackets";
            else
                type = "folder";
        }
        else{
            if(name[0] === '@'){
                type = "at";
            }
            else if(name[0] === '#'){
                type = "sharp";
            }
            else{
                    type = "cube1";
            }
        }

        node = new MyNode(uid(), desc, type, "");
        window[node.node_name()] = node;
        
        if(typeof val === 'object' && !arrayp(val)){ // it has kids
            for(var p in val){
                kid = _build_tree(p, val[p]);
                node.add_kid(kid);
            }
        }
        return node;
    }

    if(o && typeof o === 'object' && !arrayp(o)){
        for(var p in o){
            root = _build_tree(p, o[p]);
            /* we assume the tree has only 1 property at top level */
            break; 
        }
    }

    root.set_left_n_last(true, []);
    return root;
}

function tree_init(root){
    root.set_left_n_last(true, "");
    
    document.write(root.render());
    root.onclick();    
}

var test_tree = "<network name='starhub'>text<siconfig><regionID>100</regionID><networkClass>mynetwork</networkClass></siconfig><schemas><ts><column>onid</column><column>tsid</column></ts><svl>text1<column>lcn</column><column>svc_name</column>text2</svl></schemas></network>";
console.log(xml2json(test_tree));

var root = build_tree(xml2obj(test_tree));
document.write(root.render());
root.onclick();

</script></body></html>
