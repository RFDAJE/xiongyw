
       - what happens internally at "var xxx = xxx || {};" when "xxx" exists?
       - expr vs. stmt: http://en.wikipedia.org/wiki/CAL_Actor_Language#Statements_and_expressions
       - prototype vs __proto__: __proto__ type is supposed to be a hidden link, so prototype is provided...
         http://anykoro.sinaapp.com/2012/01/31/javascript%E4%B8%ADfunctionobjectprototypes__proto__%E7%AD%89%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/
         http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html
         http://hi-gp.iteye.com/blog/1460980


         0. environment & basic operators
            - Chrome w/ F12; node.js; emacs (js-comint, M-x run-js)
            - ===, typeof
            - alert(), console.log()
            - multi-line console in chrome DevTool: shift+enter
         1. data types:
            - 5 immutable primitives: boolean, number, string, null, undefined
            - 1 compounded mutable data type: object (unsorted, named/keyed; associative-array; hash; map; dictionary)
            - primitives are reference by values (while objects are referenced by pointers)
              http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm

              > var a = 1, b = a;
              undefined
              > b
              1
              > a = 2;
              2
              > b
              1
              >             

              > var a = "a"
              undefined
              > var b = a;
              undefined
              > b
              'a'
              > a="x"
              'x'
              > b
              'a'
              > 
            - the 3 primitives (boolean, number, string) have their JSE built-in object equivalent (i.e., wrapper object): Boolean, Number, String;
              JSE *automatically* and *temporarily* creates wrapper objects for primitives when the context suggests so.
                > var i=1.2;
                undefined
                > typeof i;
                'number'
                > i.p="blahblah";
                'blahblah'
                > i.p
                undefined
                > typeof i;
                'number'
            - null and undefined: http://www.2ality.com/2013/04/quirk-undefined.html
              http://martinrinehart.com/frontend-engineering/engineers/javascript/other/undefined.html
            - arrays are just special objects (i.e., arr[0] === arr["0"]):

                > var arr=[];
                undefined
                > typeof arr;
                'object'
                > typeof [];
                'object'
                > arr.length;
                0
                > arr[0]="0";
                '0'
                > arr[1]="1";
                '1'
                > arr.length;
                2
                > arr["two"]="2";
                '2'
                > arr.length;
                2
                > for(prop_name in arr) console.log(prop_name+":"+arr[prop_name]);
                0:0
                1:1
                two:2
                undefined
                > arr["0"]
                '0'
                > arr["1"]
                '1'
                > arr["0"]="zero";
                'zero'
                > arr[0]
                'zero'
                > arr[0] === arr["0"]
                true
                > arr[1] === arr["1"]
                true
                > arr[2] === arr["2"]
                true
                > arr[200] === arr["200"]
                true
                >
            - http://martinrinehart.com/frontend-engineering/engineers/javascript/arrays/sparse-arrays.html
            - objects can also have indexed properties: http://www.herongyang.com/JavaScript/Object-Indexed-Property.html
                > var o={};
                undefined
                > o[0]=0;
                0
                > o[1]=1;
                1
                > o.length
                undefined
                > o['0']
                0
                > o['1']
                1
                > typeof o
                'object'
                >
                undefined
                > var o={0:0, 1:1, 2:2}
                undefined
                > o[0]
                0
                > o[1]
                1
                > o[2]
                2
                > o.length
                undefined
                >                              
            - function type is another special object type
            - JSE built-in objects: Global (invisible), Math, JSON, and function objects: Boolean, Number, String, Object, Function, Array, RegExp, Error, Date
            - objects are passed around by references, they are *never* copied.

         2. objects, function objects, objects created by "new func()"
            - objects are containers of key-value pairs;
            - each object has both properties: "__proto__" and "constructor"
              what's behind this is that an automatical wrapper is created: http://tobyho.com/2011/01/28/checking-types-in-javascript/
              > var a = 1;
              undefined
              > typeof a
              'number'
              > typeof a.constructor
              'function'
              > a.constructor
              [Function: Number]
              >
            - Object.prototype.toString() and Function.prototype.toString().
            - function objects are those created by "function" keyword or "new Function()";
            - functions are objects which has some more properties:  "prototype", code, "apply", "call", "bind"...& "context (this)", "arguments", "return value" at invocation time;
            - what happens when a function object is invoked by "new": http://hi-gp.iteye.com/blog/1460980
               "var x = new f()" can be regarded as executed in 3 steps:
                  a) var x = {};
                  b) x.__proto__ = f.prototype;
                  c) f.call(x);

                typeof f === "function"
                typeof x === "object"
                x.__proto__ === f.prototype;
            - what happens when a function object is created:
                function foo(){...}

            - function "invocation context": "this" is determined at the invocation time, not by the definition time.
              (), apply(), call(), new

      + var declaration hoisting: 
        - "the good parts", p 113: function statements are subject to hoisting. (function stmt is a shortcut of var stmt)
        - "the definitive guide": $4.3.1, JS has no block scope;
        - because of the hoist, function stmt is forbidden in for/if stmt; and because of this restriction, function declaration is not a true stmt;
        - var declaration is hoisted, but assignment is not. see the 3rd example for function expression in an assginement stmt.

             > var scope="g";
             undefined
             > function f(){
             ... console.log(scope);
             ... var scope="l";
             ... console.log(scope);
             ... }
             undefined
             > f();
             undefined
             l
             undefined
             >

             > function o(){
             ... var priv=0;
             ... i();
             ... function i(){ priv += 1; console.log(priv);}
             ... i();
             ... }
             undefined
             > o();
             1
             2
             undefined
             >
             > function o(){
             ... if(typeof f === "undefined")
             ... console.log("undefined");
             ... else
             ... f();
             ... var f=function(){console.log("f is assgined")}
             ... }
             undefined
             > o();
             undefined
             undefined
             >
      + definition and declaration: C & JavaScript
        - "undefined" in JS really means "unassigned".
      + function arguments evaluation strategy: applicative-order vs. normal order
      + execution context, call object, scope chain: bind, call, apply

+ "https://github.com/kaizouman/fpsmeter": why this (self.rate=...) is possible, what does it mean, and what happened under the hood?

        var self = window.FPSMeter = {
           run : function(rate) {
               self.rate = rate ? rate : 1;
           ......

function scope? anything about closure?

> var obj={
... f:function(){
..... obj.p = 3.1415926;
..... console.log(obj.p);
..... }
... }
undefined
> typeof obj
'object'
> typeof obj.f
'function'
> typeof obj.p
'undefined'
> obj
{ f: [Function] }
> obj.f()
3.1415926
undefined
> typeof obj.p
'number'
> obj.p
3.1415926
> 

+ for(var p in o){
     console.log(o[p])
  }


> var o={"name":"bob"};
undefined
> for(var p in o) {console.log(o[p]);}
bob
undefined
> o.p === o["p"]
true
> typeof p
'string'
> p
'name'
> o.p !== o[p]
true
>     



+ self-modifying code: toString(), new Function(), and eval()
  - http://www.i-programmer.info/programming/javascript/989-javascript-jems-self-modifying-code.html






It's difficult to write some thing satisfactory or really meaningful...but somehow I still decided to start writing something.

It's difficult because I don't exactly know what to write, although I felt that I have a lot to say (particularly when on bed with eyes closed). And for the same reason I decided to write something, hoping that the writing process can force me to clarify the fuzzy thoughts a little bit...in certain sense, languagization of thoughts is pretty much the same as visualization of data: you need to sort out the data first before mapping it into one of its representations.

Of course, it will be even better if the notes are interesting to others, and of some relevance to our daily work. I will add/update it when applicable...and I am afraid that it will probably never reach its "finished" state, as it's *wild*.

...Content, content, and content. Give the audience a reason to care...Do you want to be interesting? Then forget the graphics and the glitz. First and foremost, have something to say.
-- Eric S. Raymond, http://catb.org/~esr/html-hell.html

1. Tensions

By "tension" I meant a *conflict* of interests or approaches, which is usually visualized (and simplified at the same time) as a tug-of-war, or a balance with a fulcrum, etc. Or, tension can be explained better by its counterpart, trade off.

The relevance of the concept of "tension" with the a programming language can be probably appreciated when we put the language in the perspective of its evolution history: what it strives for, what were/are the contenders, how and why it evolves, etc. 

The idea here is that, besides of knowing and mastering the features/constructs/paradigms of a language (JavaScript), we'd better to appreciate the reasons behind the design decisions of the language, in the perspectives of the groups of tensions: what were/are the tensions, and where the decisions stands (in the spectrum or space of the "tensions"), and to what extend the design decision applies to practical projects, etc.

It would be ideal to group tensions into *pairs* and then analysis the groups one by one with regard to a particular language in question. But it seems it's not easy, or probably impossible, as the conflicts turn out neither to be simple one-to-one pairs nor always exhibit a linear spectrum of choices. They are somewhat inter-tangled, or worse, recursively tangled.

The first thing we can do is to list some of the elements of tensions we are aware of, e.g.,:

performance, footprint, portability, memory consumption, expressiveness, procedural, imperative, declarative, functional, object oriented, academic, engineering, hybrid, pure, statically typed, dynamically typed, lazy, garbage collection, pointer...

and then pick up some of them to discuss the relevance with JavaScript language design.

2. Type

At the surface, JavaScript looks familiar to C programmers, except one "small" nuisance: the dynamic variable type. This is the most uncomfortable thing I felt about JavaScript at the begining. Without a fixed grasp on the types of the variables, how serious a program can be?...I lost the "anchor point" where the ideas connect to programs as I did in C, pretty much like a slave who losts his direction once been told that he is free.

One lesson I learnt was that, whenever these is a _single_ thing looks difficult to comprehend or appreciate, most likely it indicates that there is an _area_ of stuff I am not aware of or not good at (yet). As I digged more, it turns out that, there was, is, and will be a fierce tension between two schools in terms of types: typed or untyped, is a question.

2.1 Antidotes for C Programmers

The followings are quotes I collected so far, which may serve as an antidote for those who are accustomed to "thinking in C".

The fundamental problem addressed by a type theory is to ensure that programs have meaning. The fundamental problem caused by a type theory is that meaningful programs may not have meanings ascribed to them. The quest for richer type systems results from this tension.

-- Mark Manasse, http://en.wikipedia.org/wiki/Type_system


The fashion in most programminglanguages today demands strong typing. The theory is that strong typing allows a compiler to detect a large class of errors at compile time. The sooner we can detect and repair errors, the less they cost us. JavaScript is a loosely typed language, so JavaScript compilers are unable to detect type errors. This can be alarming to people who are coming to JavaScript from strongly typed languages. But it turns out that strong typing does not eliminate the need for careful testing. And I have found in my work that the sorts of errors that strong type checking finds are not the errors I worry about. On the other hand, I find loose typing to be liberating. I don't need to form complex class hierarchies. And I never have to cast or wrestle with the type system to get the behavior that I want.

-- Douglas Crockford, JavaScript: The Good Parts, 2008, p3.

Some people are completely religious about type systems and as a mathematician I love the idea of type systems, but nobody has ever come up with one that has enough scope. If you combine Simula and Lisp—Lisp didn’t have data structures, it had instances of objects—you would have a dynamic type system that would give you the range of expression you need.

It would allow you to think the kinds of thoughts you need to think without worrying about what type something is, because you have a much, much wider range of things. What you’re paying for is some of the checks that can be done at runtime, and, especially in the old days, you paid for it in some efficiencies. Now we get around the efficiency stuff the same way Barton did on the B5000: by just saying, “Screw it, we’re going to execute this important stuff as directly as we possibly can.” We’re not going to worry about whether we can compile it into a von Neumann computer or not, and we will make the microcode do whatever we need to get around these inefficiencies because a lot of the inefficiencies are just putting stuff on obsolete hardware architectures.

-- Alan Kay, A Conversation with Alan Kay, http://queue.acm.org/detail.cfm?id=1039523

2.2 Types in JavaScript

"Dynamically typed" means the variables do not have fixed type, i.e., its type can change over time. The type of a variable is the type of the value (to which the variable refers at the time). Or put it in short: variables have no type, values have types.

JavaScript defines 8 value types, which can be classified into two categories: primitive types and object types. The following diagram summarizes the types and their characteristics.

The following page talks about the differences between "by value" or "by reference" in JavaScript: http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm
For more details, the latest edition (6th ed) of the book "JavaScript: the definitve guide" has a whole chapter for this: "Chapter 3: Types, Values, and Variables".

However, before jumping into the links mentioned above, I would recommend to take a look of the following first, as, if there is anything could still be fuzzy, it would be the quirks about "undefined", which should be settled down first:
http://martinrinehart.com/frontend-engineering/engineers/javascript/other/undefined.html

Among other things, it explains the logic why "undefined" is both a type and a value: as each value carries its own type info stored somewhere (which is implementation depedent), so if a value is undefined, its type has to be undefined too. 

But the "undefined" quirks do not stop here...as in JavaScript, "undefined" also means "non-exist" when you access a non-exist property of an object or non-exist element in a sparse array. To distinguish "undefined" between a value (or type) and a (non-exist) state, you have to use the "in" operator.

Probably because of these quirks, JSON does not include "undefined" as one of its six value types (the other type dropped by JSON is "function" as JSON is meant to represent data only).

2.3 Reflection

To tell the type of a value, JavaScript provides a "typeof" operator, a "type introspection" http://en.wikipedia.org/wiki/Type_introspection facility, which can be regarded as a limited (i.e., read-only) "reflection" capability. http://en.wikipedia.org/wiki/Reflection_(computer_programming)

 The limitation with "typeof" operator is that, although it's good at distinguish primitive types (except "null" whose typeof is "objecct"), it can not distinguish different kinds of objects, as it always returns "object" for all kinds of objects, including array, function, null, and customized types; Another "feature" (or a quirk, depends on your PoV) of "typeof" is that it happily operates on undeclared variable without throwing an error, it returns "undefined", the same for the value "undefined"...Btw, it's a bit fuzzy in JavaScript about the states of variables (which are clear in C): declared, defined, initialized, and/or assigned.

One day, Juriy Zaytsev came with a neat solution (which becomes the de facto standard today) for detecting JSE built-in and browser-host built-in types, i.e., using Object.prototype.toString.call() by utilizing the "class" attribute string of an object. The limitation is that it can not distinguish customized objects, as there is no way for customized types to set the "class" attribute, it will be "Object" by default. This method has an important practical merit that it can be used for checking types from different HTML frames...

There is another operator "instanceof" which also addresses the limitation of "typeof". "instanceof" can distinguish all object/reference types including the custom types...but...again...with one practical limitation, in distinguish same type of objects from different HTML frames.... 

Another way is to use the "constructor" property as its a public interface. But it has the same limitation of "instanceof" (in multiple frames, or multiple execution contexts scenarios), and not all JavaScript objects have such a property.

Later ECMAScript5 formally provided Array.isArry() for detecting array types...

The reality is that, checking value types in JavaScript is a mess: http://tobyho.com/2011/01/28/checking-types-in-javascript/

As there is no problem-free approach, the trade off is to take one step back, and we end up at the position called "duck-typing":

When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.

-- James Whitcomb Riley

Why is that? My perception is that, it reflects a failure when struggling with the "web" of tensions. You want to satisfy everyone? You will probably end up with satisfying none.

2.4 TypeScript etc

Still, some people strongly outweight the merit of a typed system over the liberty of a untyped one, and they cann't get rid of JavaScript (yet) in the web domain as of today. One approach, as TypeScript took, is to extend the JavaScript language to support strictly typed variables, and provides facilities to do static analysis and converting from TypeScript programs into JavaScript programs. Check http://en.wikipedia.org/wiki/Typescript for more.

You felt the type tension, no?

3. Abstraction

3.1 Does it matter?

Under the cover of the faimilar C syntax, JavaScript is a very different language. The most significant difference is the *functional* programming paradigm it offers, hybrided with the imperative one as available in C.

JavaScript's functions are first class objects with (mostly) lexical scoping. JavaScript is the first lambda language to go mainsteam. Deep down, JavaScript has more in common with Lisp and Scheme than with Java. It is Lisp in C's clothing. This makes JavaScript a remarkably powerful language.

-- Douglas Crockford, JavaScript: The Good Parts, 2008, p3

In the citation above, it's worth to note an interesting "contradition": JavaScript is the first ... to go mainstream...This makes javaScript a remarkably powerful language. The question is, if functional laungages (Lisp/Scheme/Erlang/Haskell/etc) are so powerful, why these do not go mainstream (yet)? Also note that, JavaScript went mainstream dose not necessarily mean that its functional style is in mainstream, or, probably the main reason of its prevalence has more to do with the bloom of web rather than its functional style.

To me, again, the main reasons can be appreciated in the perspective of tensions: 
- performance vs. elegance/expressivness
- intuitive vs. abstract
- engineering vs. academic

This section focus on the intuitive vs. abstract tension, discussing the concept of abstraction (in functional programming), for setting up the context for the following may-come sections. 

For programmers, functional stuff is abstract, counter-intuitive, thus difficult to learn and master; as a consequence, for empolyeers, in general, it's difficult to hire and maintain a group of good "functional" (pun not intended:)) engineers. This "vicious circle" may partially explain the "why not go mainstream (yet)" question. In this case, as a programmer, one may rightfully ask, why should I bother? I don't know. It depends on personal choice, taste, and PoV. After all, the first version of the well-known functional-advocating article "Why Functional Programming Matters" http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf was drafted 30 years ago (in 1984), and it seems do not matter so much today yet!

The logical substratum where Lisp and Scheme are founded demand that modern users must read programs that use (and even abuse) advanced technology, that is, higher-order functions, objects, continuations, and so forth. Tomorrow's concepts will be built on these bases, so not knowing them blocks your path to the future.

-- Christian Queinnec, Lisp in Small Pieces (English version), 1994.

In its second edition, Principes d'implantation de Scheme et Lisp (in French, 2007), Christian added a footnote to the statement above, as below:

La première édition de ce livre date de 1994 et les adjonctions à cette préface apparaissent dans ces notes de bas de page. Depuis 1994, Perl, Python, C# se sont mis à proposer des fermetures, les classes internes de Java sont également des sortes de fermetures. Le terme de continuation est apparu dans le contexte des systèmes d’exploitation [DBRD91]. Le moteur Rhino implantant JavaScript procure également des continuations. 

3.2 Separation

I always felt that it's hard to get a "firm grasp" of the meaning of the word "abstraction" (or "generalization"). Yes the words are familiar, but whenever I challenge myself on what does it really mean (in the contexts where it appears), I had to pause and think for a while. It indicates that these concepts have not become as a part of my body (yet), and/or I simply don't have the kind of talent for dealing abstract stuff. 

This situation does not improve...until one day (2013-07-02) when I stumbled across a paper which briefly mentioned the etymology of "abstraction".

This issue has been with us, of course, forever: the general question of abstraction, as separating what we want from what we are presented with. It is neatly packaged in the Greek verb aphairein , as interpreted by Aristotle in the later books
of the Metaphysics to mean simply separation: if it is whiteness we want to think about, we must somehow separate it from white horse, white house, white hose, and all the other white things that it invariably must come along with, in order for us to experience it at all.

-- Barry Mazur, When is one thing equal to some other things? [http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf], 2007

This "revelation", particularly the mention of "whiteness" & "horse", immediately reminded me an ancient Chinese philosopher "Gongsun Long" who remarkably claimed, among other things, "a white horse is not a horse" and "separating the whiteness from the hardness (of a white hard stone)" [http://en.wikipedia.org/wiki/Gongsun_Long]. The sad thing, or the tragety, is that his way of thinking was not compatible with the then established and thus been stifled for more than 2000 years... 

Just at the time of this writing, I also realized that the Chinese translation for "abstraction", 抽象, literally and exactly reflects the meaning of "separation (from) the reprentation". Why I did not realize this before? Probably the word is too familiar to understand...

In short, for me, the transitive verb "separate" is more tangible than "abstract" and "generalize", and I now interprete abstraction as "separating the physically-inseparables". This gives me a whole lot of confidence when encountering "abstraction" or "generation". 

YMMV, I don't know.


3.3 Open-Texture

I encountered the term "Open Texture" for the first time when browsing a review of (or criticism [http://www.logicmatters.net/resources/pdfs/CTT.pdf] on) the symposium "Church's Thesis After 70 Years" [http://www.amazon.com/Churchs-Thesis-After-Years-Mathematical/dp/3938793090]. In its section 14 of the review, it recommended a paper by Steward Shapiro: "Computability, Proof, and Open-Texture". I did not find the online version of this paper but only a sketch of it [https://www.dpmms.cam.ac.uk/~tf/Shapiro-Church-Lakatoshandout.pdf] 

I don't really understand most of the stuff the paper was talking about...what impressed me most is the concept of Open-Texture and its possible connection to the understanding of one aspect of abstraction (or separation): the concept of open-texture suggests that the "separation" can be carried on forever (as you wish or as you are required), because there will be always an open-texture --whether you are aware of it or not--to the topic under discussion.

In engineering project practices, open-texture (of a project) is pretty much like those what we want to capture by "assumptions", "prerequisites", or "dependencies", and we know that we can never capture all of them, even at the end of the project; In programming, we have the concept of "environment" or "context", which can also be regarded as a sort of open-texture to the program or process...

With the understanding that a function is an abstraction (and a function call is an application), I have a vague metaphoric analogy (in a pejorative sense here) of open-texture into the context of functional programming for explaining the possibility of unlimited orders of high-order functions and/or unlimited parameters of functions...

Probably the analogy can go further beyond the programing languages. In natural languages, according to Otto Jespersen [http://en.wikipedia.org/wiki/Otto_Jespersen], a Danish linguist, the boundary between nouns and adjectives is vague (or not essential). In the lights of open-texture or abstraction/application, probably nouns and adjectives can be seen as applications of varargs functions. With a presumably fixed open-texture, the difference between nous and adjectives is just the number of arguments/parameters supplied in the applications: less parameters yield adjectives, and more parameters yield nouns; Take open-texture into consideration, a noun is still a varargs function as there is no limitation for "apply"ing more attributes to it. Probably those who speak French can appreciate this better, as I heard that, in French, a "noun phrase", theoretically, can contain unlimited number of words, as you can always apply attributes to the main noun by appending adjectives to the phrase, e.g.:

un tricot
un tricot noir
un tricot noir en mohair
un tricot noir en mohair feutré
......





the distinction betw values and functions;

tools shape thinking.

functional on top of xxx lanugage.

joke football player: left leg and right leg.
