<html>
<head>
<meta charset="UTF-8">
</head>
<body>

<h1>Principes d’implantation de Scheme et Lisp</h1>

Christian Queinnec, UPMC<br>
Paracamplus, 2007<br>

<h3> Missions de Paracamplus :</h3>
<p>Paracamplus a pour vocation de procurer, à tous les étudiants en
université, des ouvrages (annales corrigées, compléments de cours) et
des environnements informatiques de travail, bref, des ressources
pédagogiques propres à permettre, accélérer et <a href=""
title="maintain">entretenir</a> l’apprentissage des connaissances
enseignées.

Les ouvrages des éditions Paracamplus bénéficient d’une conception
nous permettant de vous les proposer à des coûts très abordables.

Découvrez-nous <a href="" title="further">plus avant</a> sur notre
site www.paracamplus.com.

<p>Il est interdit de reproduire intégralement ou partiellement la
présente publication sans autorisation du Centre Français
d’exploitation du droit de Copie (CFC) - 20 rue des Grands-Augustins -
75006 PARIS - Téléphone : 01 44 07 47 70, Fax : 01 46 34 67 19.<br>

c 2007 Copyright retenu par l’auteur.<br>
SARL Paracamplus<br>
7, rue Viollet-le-Duc, 75009 Paris – France<br>
ISBN 978-2-916466-03-3<br>

<h2>Avis au lecteur</h2>


<p><a href="" title="although">Quoique</a> la littérature sur Lisp
soit abondante et déjà <a href="" title="widely">largement</a>
accessible au public français, un ouvrage <a href="" title="yet,
however">pourtant</a> manquait que vous tenez entre les mains ! 

Le substrat mathématico-logique sur <a href="" title="le + quel:
which">lequel</a> est fondé Lisp/Scheme <a href="" title="demand,
require">exige</a> que ses utilisateurs modernes <a href=""
title="ne...point: not...at all">ne répugnent point</a> à lire des
programmes usant, <a href="" title="even">voire</a> abusant, de haute
technologie, c’est-à-dire de fonctionnelles d’ordre très largement
supérieur et/ou de continuations. Les concepts de demain sont élaborés
sur ces bases ; <a href="" title="disregard/ignore (them) would make
the future the most worrisome">les méconnaître rendrait l’avenir plus
inquiétant</a>.

<p>Expliquer ces entités, leur <a href="" title="origin">genèse</a>,
leurs variantes est un point que ce livre <a href="" title="try to
cover">tente de couvrir</a> en <a href="" title="beaucoup
de">moult</a> détails.

Le folklore nous enseigne que si le lispien moyen connaît la valeur de
chacune des constructions qu’il emploie, il en ignore généralement le
coût.

Cet ouvrage <a href="" title="fill">comble</a> aussi cette <a href=""
title="gap, blank">lacune</a> par une étude approfondie de la
sémantique et de l’implantation canonique des différents traits de
Lisp <a href="" title="(such) as">tels que</a> sédimentés par plus de
trente ans d’histoire.

<p>Lisp est un langage <a href="" title="pleasant,
enjoyable">plaisant</a> en lequel de nombreux problèmes fondamentaux,
non triviaux, peuvent être simplement étudiés.

Lisp est, avec ML qui privilégie le typage et l’absence <a href=""
title="side effects">d’effets de bord</a>, le plus représentatif des
langages applicatifs.

Les concepts qu’illustre cette classe de langages doivent absolument
être maîtrisés par les étudiants et les <a href="" title="computer
scientists">informaticiens</a> d’aujourd’hui ou de demain.

<a href="" title="based on">Fondés sur</a> la notion de fonction que
des siècles de mathématique ont lentement <a href=""
title="mature">mûrie</a>, les langages applicatifs sont omniprésents
en informatique sous des formes variées (shell et <a href=""
title="streams">flots</a> d’UN⋆X, langage d’extension d’édition de
texte en Emacs ou de dessin assisté sous AutoCAD . . .).

Ne pas reconnaître ces modèles, c’est méconnaître la composabilité de
leurs éléments primitifs et donc se limiter à un <a href=""
title="word by word">mot à mot</a> <a href=""
title="painful">pénible</a> pour l’écriture de programmes sans
architecture.

<p>Note 1: La première édition de ce livre date de 1994 et les
adjonctions à cette préface apparaissent dans ces notes de bas de
page. Depuis 1994, Perl, Python, C# se sont mis à proposer des
fermetures, les classes internes de Java sont également des sortes de
fermetures. Le terme de continuation est apparu dans le contexte
<a href="" title="operating systems">des systèmes d’exploitation</a>
[DBRD91]. Le <a href="" title="engine">moteur</a> Rhino implantant
JavaScript <a href="" title="provide">procure</a> également des
continuations.

<p>Note 2: Les modèles d’exécution des langages dynamiques <a href=""
title="such as">tels que</a> JavaScript, Perl, Python, Ruby, Scheme
mais aussi Java sont macroscopiquement assez <a href=""
title="close">proches</a>.

<h2><a href="" title="audience">Public</a></h2>

<p>Cet ouvrage s'adresse:<br>
<p>– aux étudiants de master qui ont à étudier l’implantation de
langages (applicatifs ou pas) par interprétation et/ou compilation ;

<p>– à tous les programmeurs (et computistes) en Lisp ou Scheme qui
<a href="" title="pouvoir">pourront</a> comprendre finement le coût ou
la <a href="" title="subtlety, nuance">subtilité</a> des constructions
qu’ils emploient <a href="" title="to (the) end (of): in order
to">afin</a> de <a href="" title="improve, enhance">s’améliorer</a>
dans leur art et produire des programmes plus <a href=""
title="efficient">efficaces</a> et plus portables ;

<p>– aux nombreux amoureux des langages de programmation qui y
trouveront de multiples <a href="" title="track, path">pistes</a> de
réflexion sur leur langage favori.

<h2>Philosophie</h2>

<p>Le présent ouvrage s’inspire de cours professés en DEA ITCP, en
DESS GLA de l’université Pierre et Marie Curie (Paris 6) <a href=""
title="and, together with">ainsi qu</a>’en enseignement
d’approfondissement à l’École Polytechnique. 

Il prend typiquement <a href="" title="à la suite de (qqn): following
(sth)">la suite d</a>’un cours d’initiation à un langage applicatif
(Lisp, Scheme, ML . . .), qui <a href="" title="culminate, reach the
peak point (in the end of the course)">culmine</a> généralement par
une description du langage en lui-même. 

L’ouvrage a pour ambition de très largement couvrir la sémantique et
l’implantation d’interprètes ou de compilateurs pour des langages
applicatifs. 

Il présente en effet <a href="" title="no less (than)">pas moins</a>
de douze interprètes et deux compilateurs (<a href=""
title="into">vers</a> du code-octet et vers le langage C) sans oublier
un système d’objets (dérivé du populaire MEROON). Contrairement à de
nombreux livres, cet ouvrage ne néglige aucunement des aspects aussi
importants que la réflexivité, l’introspection, l’évaluation dynamique
sans oublier les macros, tous phénomènes essentiels de la famille des
dialectes de Lisp.

<p>La <a href="" title="make, style">facture</a> de ce livre s’inspire
principalement de deux ouvrages : Anatomy of Lisp [All78] qui couvrait
l’implantation de Lisp des années soixante-dix et Operating System
Design : The XINU Approach [Com84] dont les programmes ne <a href=""
title="celer: hide, conceal">celaient</a> aucun détail et, <a href=""
title="by the same: thereby">par là même</a>, <a href=""
title="acquire, obtain, gain">s’acquéraient</a> la totale confiance
des lecteurs.

Nous avons donc souhaité réaliser un ouvrage précis dont le thème
central est la sémantique des langages applicatifs et de Scheme en
particulier. Au travers de multiples implantations explorant
différents aspects, la construction d’un tel système est entièrement
explicitée.

La plupart des grandes variations <a href="" title="schismatic:
separation, disunity">schismatiques</a> qu’ont <a href=""
title="pouvoir">pu</a> connaître les langages applicatifs est
analysée, démontée, implantée et comparée. Tous les détails, même les
plus <a href="" title="infinitesimal, tiny">infimes</a>,
sont <a href="" title="divulged, revealed,
disclosed">divulgués</a>. Cela permet au lecteur de ne point se
bloquer par manque d’informations, le <a href="" title="confirm,
strengthen, reinforce">conforte</a> dans l’idée que l’on ne lui cache
rien, le met, enfin,
<a href="http://www.linternaute.com/expression/langue-francaise/13950/a-pied-d-oeuvre/" title="ready">à pied d’œuvre</a> 
pour expérimenter par lui-même les concepts manipulés
<a href="" title="since">puisque</a> tous les programmes de ce livre
peuvent être <a href="" title="recover, retrieve">récupérés</a>
électroniquement.

<h2>Structure</h2>

<p>L’ouvrage est formé de deux parties. La première est une
progression partant de l’implantation d’un interprète naïf pour Lisp
et <a href="" title="dé+boucher, uncork: lead/progress
to">débouchant</a> sur la sémantique de Scheme. Le fil conducteur est
le besoin <a href="successively clarify, refine, and define">de
préciser, d’affiner et de définir successivement</a> les espaces de
noms (Lisp1 , Lisp2 . . .), les continuations (et les multiples formes
de contrôle associées), les <a href="" title="assignment, allocation,
appointment">affectations</a> et les écritures dans les structures de
données.

<p>Cette lente augmentation du langage défini s’accompagne d’une
régression du langage de définition qui <a href="" title="grow poorer,
impoverished">s’appauvrit</a> jusqu’à ne plus être qu’une sorte de
λ-calcul. La description obtenue à ce <a href=""
title="stage">stade</a> est alors convertie en son équivalent
dénotationnel par une simple curryfication. La nécessité de ce
<a href="" title="go through">parcours</a> <a href=""
title="almost/virtualy/practically initiatory">quasi initiatique</a>
de recherche de précision dans le langage décrit <a href="" title="it
seems that">nous semble</a>, après plus de six ans d’enseignement, une
très bonne approche de la sémantique dénotationnelle qui <a href=""
title="surge, raise, appear">surgit</a> ainsi justifiée et non
parachutée.

<p>La seconde partie est un voyage inverse. Partant de la sémantique
dénotationnelle et en quête d’efficacité, nous abordons
l’interprétation rapide (par prétraitement des parties statiques),
puis ce conditionnement (cette précompilation) est mis en œuvre pour
un compilateur de code-octet. Sont alors traitées, dans ce cadre
séparant bien la préparation des programmes de leur exécution :
l’évaluation dynamique (eval), les aspects réflexifs (environnements
de première classe, interprète auto-interprétable et tour
d’interprètes) et les sémantiquement redoutables macros. Pour
sacrifier à la mode, un second compilateur vers le langage C est
présenté. 

<p>Enfin le livre se clôt par l’implantation d’un système d’objets,
objets qui sont justement utilisés pour décrire finement
l’implantation de certains interprètes et de certains compilateurs.
La répétition est mère de la pédagogie. La multiplicité des
interprètes présentés, écrits dans des styles volontairement variés
(naïf, par objets, par fermetures, déno- tationnel . . .) couvre
l’essentiel des techniques utilisées pour l’implantation des langages
applicatifs et permet d’exciter la réflexion des lecteurs quant aux
différences qu’ils présentent entre eux. C’est la (re)connaissance de
ces différences, esquissées en figure 1, qui fonde la compréhension
intime de ce que sont un langage et son im- plantation : Lisp n’est
pas une de ces implantations en particulier, c’est une famille de
dialectes qui tous composent leur propre cocktail à partir des traits
présentés.  De manière générale, les chapitres forment des entités
plutôt autonomes d’environ quarante pages et sont accompagnés
d’exercices, dont les corrigés sont donnés en fin d’ouvrage. La
bibliographie contient non seulement des références historiques
(permettant d’apprécier l’évolution de Lisp depuis 1960) mais aussi
des références aux travaux actuels de recherches.


<h2>Coda</h2>

<p>Si ce livre se veut divertissant et instructif tout à la fois, il
n’est pas nécesssai- rement simple à lire. Certains sujets ne
dévoilent leur beauté que pressés de près et seulement si l’ardeur
mise à leur siège est à la mesure de leur complexité. L’étude des
langages de programmation est une ascèse qui ne se peut apprendre sans
au moins quelques outils théoriques comme le λ-calcul ou la sémantique
dénotationnelle. Le dessein de cet ouvrage est d’amener le lecteur à
ces connaissances suivant un ordre harmonieux qui ne supprime pas pour
autant tout effort de sa part.

<p>Il va de soi que cet ouvrage nécessite quelques connaissances
préalables de Lisp ou de Scheme : le lecteur doit connaître les
quelque trente fonctions de base qui suf- fisent pour débuter et être
à même de déchiffrer sans trop d’efforts des programmes récursifs. Le
langage adopté pour cet ouvrage est Scheme dont un abrégé apparaît
plus loin, augmenté d’une couche d’objets, nommée M EROON, qui n’est
utilisée que lorsqu’il s’agira d’exhiber les problèmes de
représentation et d’implantation. Tous ces programmes ont été testés
et tournent sous Scheme. Ils ne devraient pas poser de pro- blèmes de
portage aux lecteurs ayant assimilé ce livre !

<p>Il ne me reste plus qu’à remercier les organismes qui m’ont procuré
les machines (Apple Mac SE30 puis Sony News 32603 ) et les moyens qui
m’ont permis de composer cet ouvrage : l’École Polytechnique,
l’Institut National de Recherche en Informa- tique et Automatique
(INRIA–Rocquencourt) et le Greco-PRC de Programmation du Centre
National de la Recherche Scientifique (CNRS)4 . Je remercie aussi tous
ceux qui ont concouru à l’élaboration de ce livre par tous les moyens
dont ils disposaient et qu’ils ont su me permettre d’apprécier. Que
soient donc remerciés Sophie Anglade, Josy Baron, Jérôme Chailloux,
Marc Feeley, Jean-Marie Geffroy, Christian Jullien, Jean-Jacques
Lacrampe, Michel Lemaître, Luc Moreau, Jean-François Perrot, Daniel
Ribbens, Bernard Serpette, Manuel Serrano, Pierre Weis ainsi que ma
muse préférée, Claire N⋆⋆⋆ . Bien entendu les erreurs, qui
certainement (et bien malheureusement) subsistent, sont miennes.

</body>
</html>
