<html>
<head>
<meta charset="UTF-8">
</head>
<body>

<h1><a href="http://paracamplus.com/Books/Cours/LiSP/4/extrait.pdf">Principes d’implantation de Scheme et Lisp</a></h1>

<a href="http://pagesperso-systeme.lip6.fr/Christian.Queinnec/WWW/Queinnec.html">Christian Queinnec</a>, <a href="http://www.upmc.fr/">UPMC</a><br>
Paracamplus, 2007<br>

<h3> Missions de Paracamplus :</h3>
<p>Paracamplus a pour vocation de procurer, à tous les étudiants en
université, des ouvrages (annales corrigées, compléments de cours) et
des environnements informatiques de travail, bref, des ressources
pédagogiques propres à permettre, accélérer et <a href=""
title="maintain">entretenir</a> l’apprentissage des connaissances
enseignées.

Les ouvrages des éditions Paracamplus bénéficient d’une conception
nous permettant de vous les proposer à des coûts très <a href=""
title="a+bord+able: approachable, i.e. affordable">abordables</a>.

Découvrez-nous <a href="" title="further">plus avant</a> sur notre
site www.paracamplus.com.

<p>Il est interdit de reproduire intégralement ou partiellement la
présente publication sans autorisation du Centre Français
d’exploitation du droit de Copie (CFC) - 20 rue des Grands-Augustins -
75006 PARIS - Téléphone : 01 44 07 47 70, Fax : 01 46 34 67 19.<br>

c 2007 Copyright retenu par l’auteur.<br>
SARL Paracamplus<br>
7, rue Viollet-le-Duc, 75009 Paris – France<br>
ISBN 978-2-916466-03-3<br>

<h2>Avis au lecteur</h2>


<p><a href="" title="although">Quoique</a> la littérature sur Lisp
soit abondante et déjà <a href="" title="widely">largement</a>
accessible au public français, un ouvrage <a href="" title="yet,
however">pourtant</a> manquait que vous tenez entre les mains ! 

Le substrat mathématico-logique sur <a href="" title="le + quel:
which">lequel</a> est fondé Lisp/Scheme <a href="" title="demand,
require">exige</a> que ses utilisateurs modernes <a href=""
title="ne...point: not...at all">ne répugnent point</a> à lire des
programmes usant, <a href="" title="even">voire</a> abusant, de haute
technologie, c’est-à-dire de fonctionnelles d’ordre très largement
supérieur et/ou de continuations. Les concepts de demain sont élaborés
sur ces bases ; <a href="" title="disregard/ignore (them) would make
the future the most worrisome">les méconnaître rendrait l’avenir plus
inquiétant</a>.

<p>Expliquer ces entités, leur <a href="" title="origin">genèse</a>,
leurs variantes est un point que ce livre <a href="" title="try to
cover">tente de couvrir</a> en <a href="" title="beaucoup
de">moult</a> détails.

Le folklore nous enseigne que si le lispien moyen connaît la valeur de
chacune des constructions qu’il emploie, il en ignore généralement le
coût.

Cet ouvrage <a href="" title="fill">comble</a> aussi cette <a href=""
title="gap, blank">lacune</a> par une étude approfondie de la
sémantique et de l’implantation canonique des différents traits de
Lisp <a href="" title="(such) as">tels que</a> sédimentés par plus de
trente ans d’histoire.

<p>Lisp est un langage <a href="" title="pleasant,
enjoyable">plaisant</a> en lequel de nombreux problèmes fondamentaux,
non triviaux, peuvent être simplement étudiés.

Lisp est, avec ML qui privilégie le typage et l’absence <a href=""
title="side effects">d’effets de bord</a>, le plus représentatif des
langages applicatifs.

Les concepts qu’illustre cette classe de langages doivent absolument
être maîtrisés par les étudiants et les <a href="" title="computer
scientists">informaticiens</a> d’aujourd’hui ou de demain.

<a href="" title="based on">Fondés sur</a> la notion de fonction que
des siècles de mathématique ont lentement <a href=""
title="mature">mûrie</a>, les langages applicatifs sont omniprésents
en informatique sous des formes variées (shell et <a href=""
title="streams">flots</a> d’UN⋆X, langage d’extension d’édition de
texte en Emacs ou de dessin assisté sous AutoCAD . . .).

Ne pas reconnaître ces modèles, c’est méconnaître la composabilité de
leurs éléments primitifs et donc se limiter à un <a href=""
title="word by word">mot à mot</a> <a href=""
title="painful">pénible</a> pour l’écriture de programmes sans
architecture.

<p>Note 1: La première édition de ce livre date de 1994 et les
adjonctions à cette préface apparaissent dans ces notes de bas de
page. Depuis 1994, Perl, Python, C# <a href="" title="se mettre à:
begin">se sont mis à</a> proposer des fermetures, les classes internes
de Java sont également des sortes de fermetures. Le terme de
continuation est apparu dans le contexte
<a href="" title="operating systems">des systèmes d’exploitation</a>
[DBRD91]. Le <a href="" title="engine">moteur</a> Rhino implantant
JavaScript <a href="" title="provide">procure</a> également des
continuations.

<p>Note 2: Les modèles d’exécution des langages dynamiques <a href=""
title="such as">tels que</a> JavaScript, Perl, Python, Ruby, Scheme
mais aussi Java sont macroscopiquement assez <a href=""
title="close">proches</a>.

<h2><a href="" title="audience">Public</a></h2>

<p>Cet ouvrage s'adresse:<br>
<p>– aux étudiants de master qui ont à étudier l’implantation de
langages (applicatifs ou pas) par interprétation et/ou compilation ;

<p>– à tous les programmeurs (et computistes) en Lisp ou Scheme qui
<a href="" title="pouvoir">pourront</a> comprendre finement le coût ou
la <a href="" title="subtlety, nuance">subtilité</a> des constructions
qu’ils emploient <a href="" title="to (the) end (of): in order
to">afin</a> de <a href="" title="improve, enhance">s’améliorer</a>
dans leur art et produire des programmes plus <a href=""
title="efficient">efficaces</a> et plus portables ;

<p>– aux nombreux amoureux des langages de programmation qui y
trouveront de multiples <a href="" title="track, path">pistes</a> de
réflexion sur leur langage favori.

<h2>Philosophie</h2>

<p>Le présent ouvrage s’inspire de cours professés en DEA ITCP, en
DESS GLA de l’université Pierre et Marie Curie (Paris 6) <a href=""
title="and, together with">ainsi qu</a>’en enseignement
d’approfondissement à l’École Polytechnique. 

Il prend typiquement <a href="" title="à la suite de (qqn): following
(sth)">la suite d</a>’un cours d’initiation à un langage applicatif
(Lisp, Scheme, ML . . .), qui <a href="" title="culminate, reach the
peak point (in the end of the course)">culmine</a> généralement par
une description du langage en lui-même. 

L’ouvrage a pour ambition de très largement couvrir la sémantique et
l’implantation d’interprètes ou de compilateurs pour des langages
applicatifs. 

Il présente en effet <a href="" title="no less (than)">pas moins</a>
de douze interprètes et deux compilateurs (<a href=""
title="into">vers</a> du code-octet et vers le langage C) sans oublier
un système d’objets (dérivé du populaire MEROON). Contrairement à de
nombreux livres, cet ouvrage ne néglige aucunement des aspects aussi
importants que la réflexivité, l’introspection, l’évaluation dynamique
sans oublier les macros, tous phénomènes essentiels de la famille des
dialectes de Lisp.

<p>La <a href="" title="make, style">facture</a> de ce livre s’inspire
principalement de deux ouvrages : Anatomy of Lisp [All78] qui couvrait
l’implantation de Lisp des années soixante-dix et Operating System
Design : The XINU Approach [Com84] dont les programmes ne <a href=""
title="celer: hide, conceal">celaient</a> aucun détail et, <a href=""
title="by the same: thereby">par là même</a>, <a href=""
title="acquire, obtain, gain">s’acquéraient</a> la totale confiance
des lecteurs.

Nous avons donc souhaité réaliser un ouvrage précis dont le thème
central est la sémantique des langages applicatifs et de Scheme en
particulier. Au travers de multiples implantations explorant
différents aspects, la construction d’un tel système est entièrement
explicitée.

La plupart des grandes variations <a href="" title="schismatic:
separation, disunity">schismatiques</a> qu’ont <a href=""
title="pouvoir">pu</a> connaître les langages applicatifs est
analysée, démontée, implantée et comparée. Tous les détails, même les
plus <a href="" title="infinitesimal, tiny">infimes</a>,
sont <a href="" title="divulged, revealed,
disclosed">divulgués</a>. Cela permet au lecteur de ne point se
bloquer par manque d’informations, le <a href="" title="confirm,
strengthen, reinforce">conforte</a> dans l’idée que l’on ne lui cache
rien, le met, enfin,
<a href="http://www.linternaute.com/expression/langue-francaise/13950/a-pied-d-oeuvre/" title="ready">à pied d’œuvre</a> 
pour expérimenter par lui-même les concepts manipulés
<a href="" title="since">puisque</a> tous les programmes de ce livre
peuvent être <a href="" title="recover, retrieve">récupérés</a>
électroniquement.

<h2>Structure</h2>

<p>L’ouvrage est formé de deux parties. La première est une
progression partant de l’implantation d’un interprète naïf pour Lisp
et <a href="" title="dé+boucher, uncork: lead/progress
to">débouchant</a> sur la sémantique de Scheme. Le fil conducteur est
le besoin <a href="successively clarify, refine, and define">de
préciser, d’affiner et de définir successivement</a> les espaces de
noms (Lisp1 , Lisp2 . . .), les continuations (et les multiples formes
de contrôle associées), les <a href="" title="assignment, allocation,
appointment">affectations</a> et les écritures dans les structures de
données.

<p>Cette lente augmentation du langage défini s’accompagne d’une
régression du langage de définition qui <a href="" title="grow
poorer, impoverished">s’appauvrit</a> jusqu’à <a href="" title=
"ne (plus que): not more than">ne plus être qu</a>’une sorte de
λ-calcul. La description obtenue à ce <a href=""
title="stage">stade</a> est alors convertie en son équivalent
dénotationnel par une simple curryfication. La nécessité de ce
<a href="" title="go through">parcours</a> <a href=""
title="almost/virtualy/practically initiatory">quasi initiatique</a>
de recherche de précision dans le langage décrit <a href=""
title="?">nous semble</a>, après plus de six ans d’enseignement, une
très bonne approche de la sémantique dénotationnelle qui <a href=""
title="surge, raise, appear">surgit</a> ainsi justifiée et non
parachutée.

<p>La seconde partie est un voyage inverse. Partant de la sémantique
dénotationnelle et <a href="" title="questing, seeking">en quête</a>
d’efficacité, nous <a href="" title="a+bord: approach, land,
broach">abordons</a> l’interprétation rapide (par prétraitement des
parties statiques), puis ce conditionnement (cette précompilation)
est <a href="" title="mettre en œuvre: put in work,
i.e. implemented">mis en œuvre</a> pour un compilateur de
code-octet. Sont alors <a href="" title="treated,
processed">traitées</a>, <a href="" title="in the
context/framework/background where">dans ce cadre</a> séparant bien
la préparation des programmes de leur exécution : l’évaluation
dynamique (eval), les aspects réflexifs (environnements de première
classe, interprète auto-interprétable et <a href=""
title="tower">tour</a> d’interprètes) et les sémantiquement
<a href="" title="formidable, daunting, dangerous, impressive, très
fort">redoutables</a> macros. Pour <a href="" title="be a slave to
fashion, to conform to fashion, be a fashion victim">sacrifier à la
mode</a>, un second compilateur vers le langage C est présenté.

<p>Enfin le livre <a href="" title="clore: closed">se clôt</a> par
l’implantation d’un système d’objets, objets qui sont <a href=""
title="justly, rightly, exactly">justement</a> utilisés pour décrire
finement l’implantation de certains interprètes et de certains
compilateurs.  

<p>La répétition est mère de la pédagogie. La multiplicité des
interprètes présentés, écrits dans des styles <a href=""
title="willingly, delibrately">volontairement</a> variés (naïf, par
objets, par fermetures, dénotationnel . . .)  couvre l’essentiel des
techniques utilisées pour l’implantation des langages applicatifs et
permet d’exciter la réflexion des lecteurs <a href="" title="as
for/to the, in regard to the">quant aux</a> différences
qu’<a href="" title="des interprètes">ils</a> présentent
<a href="" title="among, parmi">entre</a> <a href="" title="them: the
interpreters">eux</a>.

C’est la (re)connaissance de ces différences, <a href=""
title="sketched, outlined">esquissées</a> en figure 1, qui fonde la
compréhension <a href="" title="intimate,
inner">intime</a> <a href="" title="????">de ce que sont</a> un
langage et son implantation : Lisp n’est pas <a href="" title="one
of">une de</a> ces implantations en particulier, c’est une famille de
dialectes <a href="" title="all of which">qui tous</a> composent leur
<a href="" title="own">propre</a> <a href=""
title="mixture">cocktail</a> <a href="" title="(starting) from, using,
based on">à partir des</a> traits présentés.  

<p>De manière générale, les chapitres forment des entités plutôt
autonomes d’environ quarante pages et sont accompagnés d’exercices,
dont les corrigés sont donnés en fin d’ouvrage. La bibliographie
contient non seulement des références historiques (permettant
d’apprécier l’évolution de Lisp depuis 1960) mais aussi des
références aux travaux <a href="" title="current,
up-to-date">actuels</a> de recherches.


<h2>Coda</h2>

<p>Si ce livre <a href="" title="se vouloir: want or claim to be">se
veut</a> <a href="" title="entertaining">divertissant</a> et
instructif tout <a href="" title="at once, at the same time">à la
fois</a>, il n’est pas nécesssairement simple à lire. Certains sujets
ne <a href="" title="dé+voiler: unveil, disclose">dévoilent</a> leur
beauté que pressés <a href="" title="closely">de près</a> et seulement
si l’ardeur mise à leur siège est <a href="" title="commensurate
with">à la mesure de</a> leur complexité. L’étude des langages de
programmation est une <a href="" title="asceticism">ascèse</a> qui ne
se peut apprendre sans <a href="" title="at least">au moins</a>
quelques outils théoriques comme le λ-calcul ou la sémantique
dénotationnelle. Le dessein de cet ouvrage est d’amener le lecteur à
ces connaissances suivant un ordre harmonieux qui ne supprime
pas <a href="" title="for all that, therefore">pour autant</a> tout
effort de sa part.

<p>Il <a href="" title="self-evidence, naturally">va de soi</a> que
cet ouvrage nécessite quelques connaissances préalables de Lisp ou de
Scheme : le lecteur doit connaître les quelque trente fonctions de
base qui suffisent pour débuter et <a href="" title="be able to">être
à même de</a> déchiffrer sans trop d’efforts des programmes
récursifs. Le langage adopté pour cet ouvrage est Scheme dont un
abrégé apparaît plus loin, augmenté d’une <a href=""
title="layer">couche</a> d’objets, nommée MEROON, qui n’est utilisée
que lorsqu’il s’agira d’exhiber les problèmes de représentation et
d’implantation. Tous ces programmes ont été testés et tournent sous
Scheme. Ils ne devraient pas poser de problèmes de portage aux
lecteurs ayant <a href="" title="assimilated, absorbed">assimilé</a>
ce livre !

<p><a href="" title="it only remains for me to">Il ne me reste plus
qu’à</a> remercier les organismes qui m’ont procuré les machines
(Apple Mac SE30 puis Sony News 32603 ) et les moyens qui m’ont permis
de composer cet ouvrage : l’École Polytechnique, l’Institut National
de Recherche en Informatique et Automatique (INRIA–Rocquencourt) et le
Greco-PRC de Programmation du Centre National de la Recherche
Scientifique (CNRS). Je remercie aussi tous ceux qui ont concouru à
l’élaboration de ce livre par tous les moyens dont ils disposaient et
qu’ils <a href="" title="avoir savoir: were able to">ont su</a> me
permettre d’apprécier. <a href="" title="so that ... are thanked">Que
soient donc remerciés</a> Sophie Anglade, Josy Baron, Jérôme
Chailloux, Marc Feeley, Jean-Marie Geffroy, Christian Jullien,
Jean-Jacques Lacrampe, Michel Lemaître, Luc Moreau, Jean-François
Perrot, Daniel Ribbens, Bernard Serpette, Manuel Serrano, Pierre Weis
<a href="" title="and">ainsi que</a> <a href="" title="my muse">ma
muse</a> préférée, Claire N⋆⋆⋆ . <a href="" title="of course">Bien
entendu</a> les erreurs, qui certainement (et bien malheureusement)
subsistent, sont <a href="" title="mien+ne+s">miennes</a>.

</body>
</html>
