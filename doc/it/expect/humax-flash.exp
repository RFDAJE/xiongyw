#!/usr/bin/expect --

# created(bruin, 2014-05-30)
# last updated: 2014-06-10
#
#

########################################################
# customize the following to fit your stb/environment!!!
########################################################

set REBOOT_LOG "BCM97430B0 CFE v.*"   ;# first boot trace
set CFE_PROMPT "CFE> "
set LNX_PROMPT "# "
set CTRL_C     \x03       ;# "$ ascii ^C"
set CTRL_C_ACCEPTED "Automatic startup canceled via Ctrl-C"
set CFE_SUCCESS "*** command status = 0"

set tftp  192.168.1.2      ;# assume using the same tftp server

set supported_models [list 2t 3p]

set images_path(2t) "humax7430/hnb100/p2/2t20140612-13"
set images_path(3p) "humax7430/hnb200/p2/BLD_2_1"
set kernel_name(2t) "vmlinuz-main"
set kernel_name(3p) $kernel_name(2t)
set initrd_kernel(2t) "humax7430/vmlinuz-initrd-humax-7430" 
set initrd_kernel(3p) $initrd_kernel(2t) 
set initrd_kernel_linkup(2t) "eth0: link up,"
set initrd_kernel_linkup(3p) "eth2: link up,"

# cfe commands
set cfe_startup(2t) "setenv -p STARTUP \"boot -z -elf nandflash0.opentv: 'ubi.mtd=0 root=ubi0:rootfs rootfstype=ubifs rw bmem=192M@64M bmem=512M@512M mtdparts=spi0.0:64K@2304K(mfr)ro,64K(mbox);brcmnand.0:0xDA00000@0x2600000(rootfs)'\""
set cfe_startup(3p) "setenv -p STARTUP \"boot -z -elf nandflash0.opentv: 'ubi.mtd=0 root=ubi0:rootfs rootfstype=ubifs rw bmem=192M@64M bmem=512M@512M'\""
set cfe_ifconfig(2t) "ifconfig eth0 -auto"   ;# "MULTITV" port on rear panel
set cfe_ifconfig(3p) "ifconfig eth1 -auto"   ;# usb2rj45 port on front panel
set cfe_flash_kernel(2t) "flash -noheader ${tftp}:${images_path(2t)}\/${kernel_name(2t)} nandflash0.opentv"
set cfe_flash_kernel(3p) "flash -noheader ${tftp}:${images_path(3p)}\/${kernel_name(3p)} nandflash0.opentv"
set cfe_boot_initrd(2t) "boot -elf ${tftp}:${initrd_kernel(2t)} 'bmem=192M@64M mtdparts=brcmnand.0:0xDA00000@0x2600000(rootfs)'"
set cfe_boot_initrd(3p) "boot -elf ${tftp}:${initrd_kernel(3p)} bmem=192M@64M"
# stbutil cmd
set stbutil(2t) "stbutil -a 2 ${tftp}:${images_path(2t)}"
set stbutil(3p) "stbutil -a 2 ${tftp}:${images_path(3p)}"
set stbutil_done "Finished writing rootfs to flash."
set flash_boot_time(2t)   60   ;# in seconds, boot from flash into linux shell
set flash_boot_time(3p)   $flash_boot_time(2t)

set logfile ~/humax-flash.log


########################################################################
# define some procedures
########################################################################
# this proc returns the model of the box: "2t" or "3p"
proc parse_argv {$argv} {
    global supported_models
    set usage "Usage: $::argv0 <[join $supported_models |]>"
    set argc [llength $::argv]
    set argv_0 [lindex $::argv 0]

    if { $argc != 1 } {
        puts $usage
        exit 1
    }

    set hit  0
    foreach elem $supported_models {
        if { [string compare $elem $argv_0] == 0 } {
            set hit 1
            break
        }
    }
    
    if { $hit != 1 } {
        puts $usage
        exit 1
    }

    return $argv_0
}

proc my_send_user { msg } {
    send_user "\r\n\r\n"
    send_user "#############################################################\r\n"
    send_user "#\r\n"
    send_user "# $msg \r\n" 
    send_user "#\r\n"
    send_user "#############################################################\r\n"
    send_user "\r\n\r\n"
}

# da-jiang-you for a while...
proc standby { timeout } {
    expect
}

# return 1 for true
proc is_in_cfe {} {
    send "\r"
    set timeout 5
    expect {
        default { return 0 }
        $::CFE_PROMPT { return 1 }
    }
}

# return 1 for true
proc is_in_shell {} {
    send "uname\r"
    set timeout 2
    expect {
        default { return 0 }
        "Linux" { return 1 }
    }
}


proc reboot_into_cfe {} {

    # press return 
    send "\r\r\r"

    # reboot
    expect {
        $::CFE_PROMPT  { send "reboot\r" }
        $::LNX_PROMPT  { send "reboot\r" }
        default { 
            puts "Please make sure the box is either in CFE or in Linux shell,"
            puts "and then try the script again."
            exit 1
        }
    }

    # entering the CFE mode by sending CTRL-C
    expect -re $::REBOOT_LOG
    my_send_user "Sending ^C"
    send $::CTRL_C
    set timeout 10
    expect {
        $::CTRL_C_ACCEPTED { 
            my_send_user "Entering CFE..." 
        }
        timeout { 
            my_send_user "Failure: timeout!" 
            exit 1
        } 
    }

    standby 5     ;# wait CFE calms down
    send "\r"
    expect $::CFE_PROMPT
}

# execute a cmd and return status: 
# 0: success, 1: failure
proc exec_cfe_cmd { cmd timeout } {
    if { ![is_in_cfe] } {
        puts "Please make sure the box is in CFE mode before calling me."
        return 1
    }

    my_send_user "Run CFE command: $cmd"
    send $cmd\r
    expect {
        default { return 1 }
        $::CFE_SUCCESS { return 0 }
    }
}

proc cfe_set_startup { model } {
    my_send_user "Set STARTUP environment variable..."
    exec_cfe_cmd $::cfe_startup($model)  3
}

proc cfe_flash_kernel { model } {
    my_send_user "Flashing the kernel..."
    
    if { 0 != [exec_cfe_cmd $::cfe_ifconfig($model) 5] } {
        puts "Error on cmd: $::cfe_ifconfig($model)"
        return 1
    }

    exec_cfe_cmd $::cfe_flash_kernel($model) 10
}

# boot a kernel with initrd from tftp
proc cfe_boot_from_initrd { model } {
    my_send_user "Booting into a kernel with initrd..."

    if { 0 != [exec_cfe_cmd $::cfe_ifconfig($model) 5] } {
        puts "Error on cmd: $::cfe_ifconfig($model)"
        return 1
    }

    send $::cfe_boot_initrd($model)\r  ;# leaving CFE, so not call exec_cfe_cmd
    expect $::initrd_kernel_linkup($model)
    send "\r\r\r"
    expect $::LNX_PROMPT
    return 0
}

# flash rootfs by running "stbutil"
proc run_stbutil { model } {
    if { ![is_in_shell] } {
        puts "Please make sure the box booted into linux console."
        return 1
    }

    my_send_user "Run stbutil for flashing the rootfs..."
    send $::stbutil($model)\r
    expect $::stbutil_done
    send "\r\r\r"
    expect $::LNX_PROMPT
    return 0
}

proc boot_from_flash { model } {

    if { ![is_in_cfe] && ![is_in_shell] } {
        puts "Please make sure the box is either in CFE or in Linux console."
        return 1
    }

    my_send_user "Reboot from flash..."
    if { [is_in_shell] } {
        send "sync\r"
        standby 3  
    }
    send "reboot\r"
    standby $::flash_boot_time($model)
    is_in_shell
}

proc boot_from_nfs { model } {
}

# cp the file to a backup
proc backup_file { file backup } {
    if { ![is_in_shell] } {
        puts "Please make sure the box is in Linux console."
        return 1
    }

    my_send_user "Backup $file..."

    set timeout 1   ;# timeout below means the file already exists
    send "ls $file\r"
    expect {
        "No such file or directory" {
            puts "$file does not exist!"
            return 1
        }
    }

    send "ls $backup\r"
    expect {
        "No such file or directory" {
            send "cp $file $backup\r"
            expect $::LNX_PROMPT
        }
    }
    return 0
}

# update /etc/configman/configman.xml.network/%gconf-tree.xml
proc allow_disk_sharing { model } {
    set gconf "/etc/configman/configman.xml.network/%gconf-tree.xml"
    my_send_user "Update $gconf..."

    backup_file $gconf [set gconf].orig
    expect $::LNX_PROMPT

    send "sed -i \"s/\\\(allowDiskSharing.*\\\)false/\\1true/g\" $gconf\r"
# or using braces with less escapes, which is more intuitive
#    send {sed -i "s/\(allowDiskSharing.*\)false/\1true/g" }
#    send "$gconf\r"
    expect $::LNX_PROMPT

    send "diff $gconf $gconf.orig\r"
    expect $::LNX_PROMPT
    send "sync\r"
    expect $::LNX_PROMPT
    standby 3
}

proc update_dhclient_config { model } {
    set filename "/etc/dhcp/dhclient.conf"
    my_send_user "Update $filename..."
    set backup [set filename].orig
    backup_file $filename $backup

    send "dos2unix $filename\r"   ;# just in case...
    expect $::LNX_PROMPT
    send "sed -i \"s/domain-name/routers,domain-name/g\" $filename\r"
    expect $::LNX_PROMPT
    send "diff $backup $filename\r"
    expect $::LNX_PROMPT
    send "sync\r"
    expect $::LNX_PROMPT

    standby 3
}

proc update_load_driver_sh_3p {} {
    set filename "/usr/lib/modules/load_driver.sh"
    set backup [set filename].orig
    backup_file $filename $backup

    append sed_cmd "sed"
    append sed_cmd " -e 's/^ifconfig/#ifconfig/g'" 
    append sed_cmd " -e 's/^vconfig/#vconfig/g'"
    append sed_cmd " -e 's/^ip link/#ip link/g'"
    append sed_cmd " -e '/^#!/{n;s|$|\\n"
    append sed_cmd "ip link set dev eth0 name eth9\\n"
    append sed_cmd "ip link set dev eth2 name eth0\\n"
    append sed_cmd "ifconfig eth9 up\\n"
    append sed_cmd "vconfig add eth9 3\\n"
    append sed_cmd "ifconfig eth9.3 hw ether dc:d3:21:14:06:b4 up\\n"
    append sed_cmd "ifconfig eth9.3:0 192.168.17.10\\n"
    append sed_cmd "ifconfig eth9:0 192.168.17.10\\n"
    append sed_cmd "udhcpc -i eth9.3 -V \\\"OpenTV\\\" \\&\\n"
    append sed_cmd "ifconfig eth0 up\\n|}' "
    append sed_cmd $backup
    append sed_cmd >
    append sed_cmd $filename
    my_send_user "Update $filename ..."

    # send the sed command
    send $sed_cmd\r
    send $::CTRL_C
    expect $::LNX_PROMPT
    send "diff $backup $filename\r"
    expect $::LNX_PROMPT
}


# get connected to the serial port...
proc open_ttyS0 {} {
    global spawn_id         ;# put the spawn_id in global space
    spawn killall screen
    expect eof
    spawn screen /dev/ttyS0 115200
}

proc close_ttyS0 {} {
    spawn killall screen
    expect eof
}

# flash kernel and rootfs
proc flash { model } {
    reboot_into_cfe
    cfe_set_startup $model
    cfe_flash_kernel $model
    cfe_boot_from_initrd $model
    run_stbutil $model
    boot_from_flash $model

    # apply some workarounds
    allow_disk_sharing $model
    update_dhclient_config $model
    if { [string compare $model 3p] == 0 } {
        update_load_driver_sh_3p
    }
    boot_from_flash $model
}

########################################################################
# starting...
########################################################################

#exp_internal 1             ;# for debug purpose
set timeout -1              ;# wait forever, by default (in global space)

log_file -a $logfile
set model [parse_argv $argv]

open_ttyS0
flash $model
close_ttyS0



